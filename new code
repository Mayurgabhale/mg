const [rawSearch, setRawSearch] = useState(''); // <-- NEW: search string for Raw report (name or id)













{/* Employee search (only for Raw tab) */}
{tab === 1 && (
  <Box sx={{ mt: 2 }}>
    <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
      Employee (name or ID)
    </Typography>
    <TextField
      fullWidth
      placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
      label="Search Employee"
      value={rawSearch}
      onChange={(e) => setRawSearch(e.target.value)}
      sx={{
        '& .MuiInputBase-input': { color: '#fff' },
        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
      }}
      InputLabelProps={{ style: { color: '#FFCC00' } }}
    />
    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
      Leave empty to export all raw rows for the date range.
    </Typography>
  </Box>
)}











else if (tab === 1) {
  // Raw
  const params = {
    ...baseParams,
    startDate: formatLocalDate(from),
    endDate: formatLocalDate(to, true)
  };

  // Fetch raw rows (we pass params in case backend supports server-side filtering)
  const resp = await axios.get('/api/reports/raw', { params });

  // Normalize from/to to full-day bounds for client-side filtering
  const startDate = new Date(from);
  startDate.setHours(0, 0, 0, 0);
  const endDate = new Date(to);
  endDate.setHours(23, 59, 59, 999);

  // Filter to date-range first
  let rows = (resp.data && resp.data.data) ? resp.data.data.filter(r => {
    const date = new Date(r.DateOnly || r.LocaleMessageTime);
    return date >= startDate && date <= endDate;
  }) : [];

  // If user provided a search term, filter rows by EmployeeID or ObjectName1 (case-insensitive)
  if (rawSearch && rawSearch.trim() !== '') {
    const s = rawSearch.trim().toLowerCase();
    rows = rows.filter(r => {
      const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
      const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
      return id.includes(s) || name.includes(s);
    });
  }

  // Convert filtered rows to sheet and download (same as before)
  const ws = XLSX.utils.json_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Raw');

  const fileStart = startDate.toISOString().slice(0, 10);
  const fileEnd = endDate.toISOString().slice(0, 10);
  const filename = `RawReport_${region}_${fileStart}_to_${fileEnd}.xlsx`;

  XLSX.writeFile(wb, filename);
}
