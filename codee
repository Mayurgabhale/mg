// Handler: GET /api/occupancy-at?date=YYYY-MM-DD&time=HH:MM[:SS]  (or legacy ?at=ISO)
exports.getSnapshotAt = async (req, res) => {
  try {
    // Backwards-compatible: allow ?at=<ISO>
    if (req.query.at) {
      const atRaw = req.query.at;
      const atDate = new Date(atRaw);
      if (Number.isNaN(atDate.getTime())) {
        return res.status(400).json({ error: 'invalid "at" timestamp' });
      }
      // fetch events and compute using existing logic
      const events = await fetchEventsWindow(atDate);
      // Only keep events on the same local date as atDate and <= atDate
      const refDt = DateTime.fromJSDate(atDate, { zone: 'utc' }).setZone('Asia/Kolkata');
      const filtered = events.filter(evt => {
        if (!evt.Dateonly || !evt.Swipe_Time) return false;
        const evtDt = DateTime.fromISO(`${evt.Dateonly}T${evt.Swipe_Time}`, { zone: 'Asia/Kolkata' });
        return evt.Dateonly === refDt.toFormat('yyyy-LL-dd') && evtDt <= refDt;
      });
      const occupancy = await buildOccupancy(filtered);
      const visitedStats = buildVisitedForDate(events, atDate);
      occupancy.totalVisitedToday = visitedStats.total;
      occupancy.visitedToday = {
        employees: visitedStats.employees,
        contractors: visitedStats.contractors,
        total: visitedStats.total
      };
      occupancy.asOf = DateTime.fromJSDate(atDate, { zone: 'utc' }).setZone('Asia/Kolkata').toISO();
      return res.json(occupancy);
    }

    // New: require date + time
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({ error: 'expected ?date=YYYY-MM-DD&time=HH:MM[:SS]' });
    }

    // validate date
    const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(date);
    if (!dateMatch) return res.status(400).json({ error: 'invalid "date" format; expected YYYY-MM-DD' });

    // validate time (HH:MM or HH:MM:SS)
    const timeMatch = /^([0-1]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/.exec(time);
    if (!timeMatch) return res.status(400).json({ error: 'invalid "time" format; expected HH:MM or HH:MM:SS' });

    const year = Number(dateMatch[1]);
    const month = Number(dateMatch[2]);
    const day = Number(dateMatch[3]);
    const hour = Number(timeMatch[1]);
    const minute = Number(timeMatch[2]);
    const second = timeMatch[3] ? Number(timeMatch[3]) : 0;

    // Build target DateTime in Asia/Kolkata
    const atDt = DateTime.fromObject(
      { year, month, day, hour, minute, second, millisecond: 0 },
      { zone: 'Asia/Kolkata' }
    );

    if (!atDt.isValid) {
      return res.status(400).json({ error: 'invalid date+time combination' });
    }

    // Block future queries (compare in Asia/Kolkata)
    const nowLocal = DateTime.now().setZone('Asia/Kolkata');
    if (atDt > nowLocal) {
      return res.status(400).json({ error: 'Please select a relevant time â€” cannot be in the future' });
    }

    // Convert to UTC JS Date for SQL fetch (24h window ending at this instant)
    const untilJsDate = atDt.toUTC().toJSDate();

    // fetch events in 24h window ending at this instant
    const events = await fetchEventsWindow(untilJsDate);

    // Keep only events that are on requested local date AND <= requested time
    const targetDateStr = atDt.toFormat('yyyy-LL-dd');
    const eventsUpToTarget = events.filter(evt => {
      if (!evt.Dateonly || !evt.Swipe_Time) return false;
      if (evt.Dateonly !== targetDateStr) return false;
      const evtDt = DateTime.fromISO(`${evt.Dateonly}T${evt.Swipe_Time}`, { zone: 'Asia/Kolkata' });
      return evtDt <= atDt;
    });

    // Build occupancy using your existing builder (works same as live logic)
    const occupancy = await buildOccupancy(eventsUpToTarget);

    // visited counts for that date (uses helper expecting JS Date)
    const visitedStats = buildVisitedForDate(events, untilJsDate);

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = {
      employees: visitedStats.employees,
      contractors: visitedStats.contractors,
      total: visitedStats.total
    };

    // show asOf in local IST so it matches the input format
    occupancy.asOf = atDt.toISO(); // e.g. "2025-09-18T03:55:00.000+05:30"
    occupancy.requestedAsOfLocal = atDt.toISO();
    occupancy.requestedAsOfHuman = atDt.toFormat('yyyy-LL-dd HH:mm:ss');
    occupancy._meta = { eventsFetched: events.length, eventsConsidered: eventsUpToTarget.length };

    return res.json(occupancy);
  } catch (err) {
    console.error('getSnapshotAt error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
