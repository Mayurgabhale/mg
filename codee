// src/components/FloorInOutTable.jsx
import React, { useEffect, useMemo, useState } from 'react';
import { Card, Table, Modal, OverlayTrigger, Tooltip, Button } from 'react-bootstrap';
import * as XLSX from 'xlsx'

// Accent palette (gold / yellow)
const GOLD = '#FFC72C';
const GOLD_DEEP = '#FFDD00';
const BLACK_BG = '#0b0b0b';

const headerStyle = { background: GOLD_DEEP, color: '#000', fontWeight: '700' };
const modalHeaderStyle = { background: BLACK_BG, color: GOLD, borderBottom: `2px solid ${GOLD_DEEP}` };
const footerBtnStyle = { background: GOLD_DEEP, borderColor: GOLD_DEEP, color: '#000' };

const ROW_COLORS = [
  '#FFC72C', '#C9A9A6', '#FFE680',
  '#FFF5EE', '#FFD11A', '#96DED1', '#FFEB99',
];

const SECURITY_IDS = [
  "W0023386", "W0027969", "62082475", "W0027913", "C676439", "W0026151", "W0026455", "W0028120"
].map(id => id.toUpperCase());

const normalizeId = v => String(v || '').trim().toUpperCase();

const normalizeFloorName = (f) => {
  if (f === null || f === undefined) return '';
  const s = String(f).trim();
  if (!s) return '';
  // If it's just a number like '1' or '01', convert to 'Floor X'
  if (/^\d{1,2}$/.test(s)) {
    return `Floor ${parseInt(s, 10)}`;
  }
  // Normalize 'Floor 01' -> 'Floor 1', 'floor 01' -> 'Floor 1'
  const replaced = s.replace(/^floor\s*0*/i, 'Floor ');
  return replaced.trim();
};

// derive floor from Door/Location strings
function deriveFloorFromRecord(rec) {
  if (!rec) return 'Unknown';
  if (rec.floor && String(rec.floor).trim()) return normalizeFloorName(rec.floor);

  const door = String(rec.Door || rec.door || rec.Location || '').trim();
  if (!door) return 'Unknown';

  // Look for HQ 12 or HQ.12
  const mHQ = door.match(/HQ[.\s]*\s*(\d{1,2})\b/i);
  if (mHQ && mHQ[1]) return `Floor ${parseInt(mHQ[1], 10)}`;

  // If Location contains 'Floor X'
  const mFloorText = door.match(/Floor\s*(\d{1,2})/i);
  if (mFloorText && mFloorText[1]) return `Floor ${parseInt(mFloorText[1], 10)}`;

  // Simple number with guard (space, dot, or end)
  const mSimple = door.match(/\b(\d{1,2})\b/);
  if (mSimple && mSimple[1]) {
    const idx = door.indexOf(mSimple[1]);
    const after = door[idx + mSimple[1].length] || '';
    if (after === '' || /\s|\./.test(after)) {
      return `Floor ${parseInt(mSimple[1], 10)}`;
    }
  }

  return 'Unknown';
}

// Excel export helper (unchanged)
const mapRejectionForExport = (r) => {
  let localDate = '';
  let localTime = '';
  try {
    if (r.LocaleMessageTime) {
      const dt = new Date(r.LocaleMessageTime);
      localDate = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
      localTime = dt.toLocaleTimeString('en-GB', { timeZone: 'America/Denver' });
    } else if (r.DateOnly) {
      localDate = (typeof r.DateOnly === 'string' ? r.DateOnly.slice(0, 10) : new Date(r.DateOnly).toISOString().slice(0, 10));
      localTime = r.SwipeTime || '';
    }
  } catch (e) {
    localDate = (r.DateOnly || '').slice(0, 10);
    localTime = r.SwipeTime || '';
  }

  return {
    Date: localDate,
    Time: localTime,
    Name: r.ObjectName1 || '',
    EmployeeID: r.EmployeeID || '',
    CardNumber: r.CardNumber || '',
    PersonnelType: r.PersonnelType || '',
    Door: r.Door || r.Location || '',
    RejectionType: r.RejectionType || '',
    DerivedFloor: deriveFloorFromRecord(r) || ''
  };
};

const exportRejectionsToExcel = (rows, fileName = 'rejections.xlsx') => {
  if (!rows || rows.length === 0) return;
  const mapped = rows.map(mapRejectionForExport);
  const ws = XLSX.utils.json_to_sheet(mapped, { header: ['Date', 'Time', 'Name', 'EmployeeID', 'CardNumber', 'PersonnelType', 'Door', 'RejectionType', 'DerivedFloor'] });
  ws['!cols'] = [
    { wch: 6 }, { wch: 12 }, { wch: 10 }, { wch: 28 }, { wch: 14 }, { wch: 14 },
    { wch: 16 }, { wch: 48 }, { wch: 20 }
  ];
  const summary = [
    { Key: 'Export Date', Value: new Date().toLocaleString('en-CA') },
    { Key: 'Record Count', Value: mapped.length },
    { Key: 'Generated By', Value: 'FloorInOutTable' }
  ];
  const wsSummary = XLSX.utils.json_to_sheet(summary);
  wsSummary['!cols'] = [{ wch: 20 }, { wch: 30 }];
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Rejections');
  XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
  XLSX.writeFile(wb, fileName);
};


export default function FloorInOutTable({
  data = [],
  floorBreakdown = [],
  floorInOutSummary = []
}) {
  const securitySet = useMemo(() => new Set(SECURITY_IDS), []);

  const [showSecurityModal, setShowSecurityModal] = useState(false);
  const [selectedFloorSecurity, setSelectedFloorSecurity] = useState(null);
  const [selectedPeopleSecurity, setSelectedPeopleSecurity] = useState([]);

  const [rejectionDetails, setRejectionDetails] = useState({}); // { normFloor -> [records...] }
  const [rejectionSummaryMap, setRejectionSummaryMap] = useState({}); // { normFloor -> count }
  const [rejectionAllDetailsToday, setRejectionAllDetailsToday] = useState([]);
  const [rejectionsLoading, setRejectionsLoading] = useState(false);

  const [showRejectionModal, setShowRejectionModal] = useState(false);
  const [selectedRejectionFloor, setSelectedRejectionFloor] = useState(null);
  const [selectedRejectionList, setSelectedRejectionList] = useState([]);

  const [showAllSecurityModal, setShowAllSecurityModal] = useState(false);
  const [showAllRejectionsModal, setShowAllRejectionsModal] = useState(false);

  function isPresent(o = {}) {
    if (o.OutOfOffice === true) return false;
    if (o.IsOut === true) return false;
    if (o.IsOnLeave === true) return false;
    if (o.Absent === true) return false;
    if (o.OnLeave === true) return false;
    if (o.IsPresent === false) return false;
    if (o.InOffice === false) return false;
    const status = (o.Status || o.PersonnelStatus || o.WorkStatus || '').toString().toLowerCase();
    if (status && /(out|absent|leave|vacation|remote|off|offsite|wfh|working from home)/.test(status)) return false;
    const dir = (o.LastSwipeDirection || o.Direction || o.SwipeDirection || '').toString().toLowerCase();
    if (dir && /(out|exit)/.test(dir)) return false;
    const workloc = (o.WorkLocation || o.LocationType || '').toString().toLowerCase();
    if (workloc && /(remote|home|offsite|wfh)/.test(workloc)) return false;
    return true;
  }

  // Build securityByFloor _using normalized floor keys_
  const securityByFloor = useMemo(() => {
    const byFloor = {};

    (floorBreakdown || []).forEach(fb => {
      const normFloor = normalizeFloorName(fb.floor) || String(fb.floor || '');
      const people = [];
      (fb.occupants || []).forEach(o => {
        const empId = normalizeId(o.EmployeeID);
        if (!securitySet.has(empId)) return;
        if (!isPresent(o)) return;
        people.push(o);
      });
      if (people.length) {
        byFloor[normFloor] = (byFloor[normFloor] || []).concat(people);
      }
    });

    (floorInOutSummary || []).forEach(f => {
      const normFloor = normalizeFloorName(f.floor) || String(f.floor || '');
      (f.inOnlyPersons || []).forEach(pid => {
        const empId = normalizeId(pid);
        if (securitySet.has(empId)) {
          byFloor[normFloor] = (byFloor[normFloor] || []).concat([
            { EmployeeID: empId, ObjectName1: "(Unknown)", Swipe_Time: "—", Door: "—", PersonnelType: "—" }
          ]);
        }
      });
    });

    return byFloor;
  }, [floorBreakdown, floorInOutSummary, securitySet]);

  // flattened security list (each item has normalized floor property)
  const securityFlat = useMemo(() => {
    const arr = [];
    Object.keys(securityByFloor || {}).forEach(normFloor => {
      (securityByFloor[normFloor] || []).forEach(p => arr.push({ ...p, floor: normFloor }));
    });
    return arr;
  }, [securityByFloor]);

  // Load rejections (keeps only today's Denver records)
  useEffect(() => {
    let mounted = true;

    async function loadRejectionsTodayOnly() {
      setRejectionsLoading(true);
      try {
        const res = await fetch('/api/rejections');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();

        const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
        let detailsToday = [];
        const summaryMap = {};

        if (Array.isArray(payload.dateWise)) {
          const dayObj = payload.dateWise.find(d => d.date === todayDenver);
          if (dayObj && Array.isArray(dayObj.floors)) {
            dayObj.floors.forEach(f => {
              const key = normalizeFloorName(f.floor || '') || 'Unknown';
              summaryMap[key] = Number(f.rejectionCount || 0);
            });
          }
          if (Array.isArray(payload.details)) {
            detailsToday = payload.details.filter(d => {
              const raw = d.LocaleMessageTime || d.DateOnly;
              if (!raw) return false;
              try {
                const dt = new Date(raw);
                return dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' }) === todayDenver;
              } catch (e) {
                return String(raw).slice(0, 10) === todayDenver;
              }
            });
          }
        } else if (Array.isArray(payload.details)) {
          detailsToday = payload.details.filter(d => {
            const raw = d.LocaleMessageTime || d.DateOnly;
            if (!raw) return false;
            try {
              const dt = new Date(raw);
              return dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' }) === todayDenver;
            } catch (e) {
              return String(raw).slice(0, 10) === todayDenver;
            }
          });

          detailsToday.forEach(d => {
            const derived = deriveFloorFromRecord(d) || 'Unknown';
            const norm = normalizeFloorName(derived) || 'Unknown';
            summaryMap[norm] = (summaryMap[norm] || 0) + 1;
          });
        }

        // group details by normalized floor
        const detailsByFloor = {};
        detailsToday.forEach(d => {
          const derived = deriveFloorFromRecord(d) || 'Unknown';
          const norm = normalizeFloorName(derived) || 'Unknown';
          detailsByFloor[norm] = detailsByFloor[norm] || [];
          detailsByFloor[norm].push(d);
        });

        if (!mounted) return;
        setRejectionSummaryMap(summaryMap);
        setRejectionDetails(detailsByFloor);
        setRejectionAllDetailsToday(detailsToday);
      } catch (err) {
        console.error('Failed to load rejections:', err);
        if (mounted) {
          setRejectionSummaryMap({});
          setRejectionDetails({});
          setRejectionAllDetailsToday([]);
        }
      } finally {
        if (mounted) setRejectionsLoading(false);
      }
    }

    loadRejectionsTodayOnly();
    return () => { mounted = false; };
  }, []);

  // Build sorted rows and attach securityCount & today's rejectionCount (use normalized keys)
  const sorted = useMemo(() => {
    const rows = (Array.isArray(data) ? data : []).map(({ floor, inSwipes, outSwipes }) => {
      const normFloor = normalizeFloorName(floor) || String(floor || '');
      return {
        floor: normFloor, // use normalized value as the primary display field
        rawFloor: floor,
        normFloor,
        inSwipes: Number(inSwipes || 0),
        outSwipes: Number(outSwipes || 0),
        inconsistency: Number(inSwipes || 0) - Number(outSwipes || 0),
        securityCount: (securityByFloor[normFloor] || []).length,
        rejectionCount: rejectionSummaryMap[normFloor] || 0
      };
    });
    return rows.sort((a, b) => b.inconsistency - a.inconsistency);
  }, [data, securityByFloor, rejectionSummaryMap]);

  const top = sorted[0] || null;

  const handleSecurityCellClick = (floor) => {
    const people = securityByFloor[floor] || [];
    if (people.length > 0) {
      setSelectedFloorSecurity(floor);
      setSelectedPeopleSecurity(people);
      setShowSecurityModal(true);
    }
  };

  const handleRejectionCellClick = (normFloor, displayFloor) => {
    let list = rejectionDetails[normFloor] || [];

    if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0) {
      const numMatch = (normFloor && normFloor.match(/\d+/)) ? normFloor.match(/\d+/)[0] : null;
      if (numMatch && Array.isArray(rejectionAllDetailsToday)) {
        const regex = new RegExp(`\\b${numMatch}\\b`);
        list = rejectionAllDetailsToday.filter(d => {
          const door = String(d.Door || d.door || d.Location || '');
          return regex.test(door);
        });
      }
    }

    setSelectedRejectionFloor(displayFloor || normFloor);
    setSelectedRejectionList(list || []);
    setShowRejectionModal(true);
  };

  const handleSecurityHeaderClick = () => {
    if ((securityFlat || []).length > 0) setShowAllSecurityModal(true);
  };

  const handleRejectionHeaderClick = () => {
    if ((rejectionAllDetailsToday || []).length > 0) setShowAllRejectionsModal(true);
  };

  const renderRejectionTooltip = (floor) => {
    const nf = normalizeFloorName(floor);
    const byFloor = rejectionDetails[nf] || [];
    const knownCount = rejectionSummaryMap[nf] || 0;
    if (!byFloor.length && !knownCount) return 'No rejections today';
    const lines = [];
    if (knownCount && !byFloor.length) {
      lines.push(`Total today: ${knownCount}`);
      lines.push('');
      lines.push('Details not available (count only)');
      return lines.join('\n');
    }
    lines.push(`Total today: ${byFloor.length}`);
    lines.push('');
    lines.push('Recent:');
    byFloor.slice(0, 6).forEach(d => {
      const date = d.LocaleMessageTime ? d.LocaleMessageTime.slice(0, 10) : (d.DateOnly ? (typeof d.DateOnly === 'string' ? d.DateOnly.slice(0, 10) : new Date(d.DateOnly).toISOString().slice(0, 10)) : '');
      const time = d.SwipeTime || (d.LocaleMessageTime ? d.LocaleMessageTime.slice(11, 19) : '');
      lines.push(`${date} ${time} — ${d.RejectionType || ''} — ${d.Door || d.Location || ''}`);
    });
    if (byFloor.length > 6) lines.push(`… +${byFloor.length - 6} more`);
    return lines.join('\n');
  };

  return (
    <>
      <Card className="mb-4 shadow-sm" style={{ background: '#1a1a1a', border: '2px solid #FFC72C' }}>
        <Card.Header className="text-center fw-bold" style={{ background: '#000', color: '#FFC72C' }}>
          Floor In vs Out Swipe Summary (Rejections — Today)
        </Card.Header>

        <Card.Body style={{ height: 450, padding: '1rem', overflowY: 'auto' }}>
          {top && (
            <div className="mb-3" style={{ color: '#fff', fontSize: '1rem' }}>
              Highest inconsistency:&nbsp;
              <span style={{ color: '#FFC72C', fontWeight: 'bold' }}>{top.inconsistency}</span>
              &nbsp;on&nbsp;
              <span style={{ color: '#FFC72C', fontWeight: 'bold' }}>{top.floor}</span>
            </div>
          )}

          <Table striped bordered hover size="sm" variant="dark" className="mb-0">
            <thead>
              <tr>
                <th>Floor</th>
                <th>In Swipes</th>
                <th>Out Swipes</th>
                <th>In − Out</th>
                <th
                  style={{ cursor: (securityFlat && securityFlat.length) ? 'pointer' : 'default', textDecoration: (securityFlat && securityFlat.length) ? 'underline' : 'none' }}
                  onClick={handleSecurityHeaderClick}
                  title={securityFlat && securityFlat.length ? `Show all security (${securityFlat.length})` : 'No security'}
                >
                  Security
                </th>
                <th
                  style={{ cursor: (rejectionAllDetailsToday && rejectionAllDetailsToday.length) ? 'pointer' : 'default', textDecoration: (rejectionAllDetailsToday && rejectionAllDetailsToday.length) ? 'underline' : 'none' }}
                  onClick={handleRejectionHeaderClick}
                  title={rejectionAllDetailsToday && rejectionAllDetailsToday.length ? `Show all rejections today (${rejectionAllDetailsToday.length})` : 'No rejections today'}
                >
                  Rejection
                </th>
              </tr>
            </thead>

            <tbody>
              {sorted.map((row, idx) => (
                <tr key={row.normFloor || idx} style={{ backgroundColor: row.securityCount > 0 ? '#333300' : undefined }}>
                  <td style={{ color: '#fff' }}>{row.floor}</td>
                  <td style={{ color: ROW_COLORS[idx % ROW_COLORS.length] }}>{row.inSwipes}</td>
                  <td style={{ color: ROW_COLORS[(idx + 1) % ROW_COLORS.length] }}>{row.outSwipes}</td>
                  <td style={{ color: ROW_COLORS[(idx + 2) % ROW_COLORS.length], fontWeight: 'bold' }}>
                    {row.inconsistency}
                  </td>

                  <td
                    style={{
                      color: row.securityCount > 0 ? '#FFC72C' : '#aaa',
                      fontWeight: row.securityCount > 0 ? 'bold' : 'normal',
                      cursor: row.securityCount > 0 ? 'pointer' : 'default',
                      textDecoration: row.securityCount > 0 ? 'underline' : 'none'
                    }}
                    onClick={() => { if (row.securityCount > 0) handleSecurityCellClick(row.normFloor); }}
                  >
                    {row.securityCount > 0 ? row.securityCount : ''}
                  </td>

                  <td style={{
                    color: row.rejectionCount > 0 ? '#FFCCCB' : '#aaa',
                    fontWeight: row.rejectionCount > 0 ? 'bold' : 'normal',
                    cursor: row.rejectionCount > 0 ? 'pointer' : 'default'
                  }}>
                    {row.rejectionCount > 0 ? (
                      <OverlayTrigger
                        placement="top"
                        overlay={<Tooltip id={`rej-tip-${(row.normFloor || '').replace(/\s+/g, '_')}`}>{renderRejectionTooltip(row.normFloor || row.floor)}</Tooltip>}
                      >
                        <span
                          onClick={() => handleRejectionCellClick(row.normFloor, row.floor)}
                          style={{ textDecoration: 'underline', display: 'inline-block' }}
                        >
                          {row.rejectionCount}
                        </span>
                      </OverlayTrigger>
                    ) : ''}
                  </td>
                </tr>
              ))}
            </tbody>
          </Table>
        </Card.Body>
      </Card>

      {/* Security modal */}
      <Modal show={showSecurityModal} onHide={() => setShowSecurityModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title>Security Occupants - {selectedFloorSecurity}</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Table striped bordered hover size="sm">
            <thead>
              <tr>
                <th>EmployeeID</th>
                <th>Name</th>
                <th>Swipe Time</th>
                <th>Door</th>
                <th>Type</th>
              </tr>
            </thead>
            <tbody>
              {selectedPeopleSecurity.map((p, idx) => (
                <tr key={idx}>
                  <td>{p.EmployeeID}</td>
                  <td>{p.ObjectName1 || "(Unknown)"}</td>
                  <td>{p.Swipe_Time || "—"}</td>
                  <td>{p.Door || "—"}</td>
                  <td>{p.PersonnelType || "—"}</td>
                </tr>
              ))}
            </tbody>
          </Table>
        </Modal.Body>
      </Modal>

      {/* All security modal */}
      <Modal show={showAllSecurityModal} onHide={() => setShowAllSecurityModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title style={{ textAlign: 'center' }}>All Security Occupants</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {(!securityFlat || securityFlat.length === 0) ? (
            <div>No security 