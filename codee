// canonical company fallback: prefer CompanyName, otherwise infer from PersonnelType
const canonicalCompany = (r) => {
  const raw = r.CompanyName && String(r.CompanyName).trim();
  if (raw) return raw;
  const pt = (r.PersonnelType && String(r.PersonnelType).toLowerCase()) || '';
  if (pt.includes('temp')) return 'Temp Badge';
  if (pt.includes('visitor')) return 'Visitor';
  return 'Unknown';
};





......


const detailRows = useMemo(() => {
  if (!data || !pickedDate) return [];
  const ds = format(pickedDate, 'yyyy-MM-dd');

  // a) all swipes that day for our partitions
  const all = data.details.filter(r =>
    filteredPartitionKeys.includes(r.PartitionName2) &&
    r.LocaleMessageTime && r.LocaleMessageTime.startsWith(ds)
  );

  // b) oldest â†’ newest
  all.sort((a, b) => new Date(a.LocaleMessageTime) - new Date(b.LocaleMessageTime));

  // c) keep last swipe per person
  const lastByPerson = {};
  all.forEach(r => { lastByPerson[r.PersonGUID] = r; });

  // d) values (final swipe entries) and only InDirection (still inside)
  let rows = Object.values(lastByPerson).filter(r => r.Direction === 'InDirection');

  // Attach computed company for display / filtering / export
  rows = rows.map(r => ({ ...r, CompanyNameComputed: canonicalCompany(r) }));

  // If a company row was clicked, do the strict triple match (Country||City||Company)
  if (selectedCompany) {
    const [selCountry, selCity, selCompanyRaw] = selectedCompany.split('||');
    const selCompanyNorm = String(selCompanyRaw || '').replace(/\s+/g, ' ').trim().toLowerCase();

    rows = rows.filter(r => {
      const rnCompany = String(r.CompanyNameComputed || 'Unknown').replace(/\s+/g,' ').trim().toLowerCase();
      const rowCity = partitionToDisplay[r.PartitionName2]?.city || r.PartitionName2 || '';
      const rowCountry = partitionToDisplay[r.PartitionName2]?.country || 'Unknown';
      return rnCompany === selCompanyNorm && rowCity === selCity && rowCountry === selCountry;
    });
  }

  return rows;
}, [data, pickedDate, filteredPartitionKeys, selectedCompany]);


......

filtered.forEach(r => {
  const city = partitionToDisplay[r.PartitionName2]?.city || (r.PartitionName2 || 'Unknown');
  const country = partitionToDisplay[r.PartitionName2]?.country || 'Unknown';

  // use canonicalCompany to handle blank CompanyName
  const company = canonicalCompany(r);

  const key = `${country}||${city}||${company}`;
  const existing = map.get(key);
  if (existing) {
    existing.total += 1;
  } else {
    map.set(key, { country, city, company, total: 1 });
  }
});

