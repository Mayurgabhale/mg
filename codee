curl 'http://localhost:5000/api/occupancy-at-time-denver?time=12:00:00'


// REPLACE the previous getDenverOccupancyAtTime with this version
exports.getDenverOccupancyAtTime = async (req, res) => {
  try {
    // ensure DB pool available (same style as SSE endpoint)
    try {
      await denver.poolPromise;
    } catch (err) {
      console.error('❌ Failed to initialize Denver pool in occupancy-at-time endpoint:', err);
      return res.status(500).json({ error: 'database unavailable' });
    }

    const timeParam = (req.query.time || '').trim();
    if (!timeParam) {
      return res.status(400).json({ error: 'missing required query parameter "time" (format HH:mm or HH:mm:ss)' });
    }

    // Try parse with seconds then without
    let parsed = DateTime.fromFormat(timeParam, 'HH:mm:ss', { zone: 'America/Denver' });
    if (!parsed.isValid) {
      parsed = DateTime.fromFormat(timeParam, 'HH:mm', { zone: 'America/Denver' });
    }
    if (!parsed.isValid) {
      return res.status(400).json({ error: 'time must be in format HH:mm or HH:mm:ss' });
    }

    // Build target DateTime for *today* in Denver
    const todayStart = DateTime.now().setZone('America/Denver').startOf('day');
    const target = todayStart
      .plus({ hours: parsed.hour, minutes: parsed.minute, seconds: parsed.second || 0 });

    const nowDenver = DateTime.now().setZone('America/Denver');
    if (!target.hasSame(nowDenver, 'day')) {
      return res.status(400).json({ error: 'only the current Denver day is supported' });
    }

    // Fetch all events from start of today
    const since = todayStart.toJSDate();
    let events;
    try {
      events = await fetchNewEvents(since); // may return rows where LocaleMessageTime is Date or string
    } catch (err) {
      console.error('❌ Error fetching events for occupancy-at-time:', err);
      return res.status(500).json({ error: 'failed to fetch events' });
    }
    if (!Array.isArray(events)) events = [];

    // Normalize LocaleMessageTime to a Date object and ensure sorting by time ascending
    events = events.map(evt => {
      const copy = Object.assign({}, evt);
      if (!copy.LocaleMessageTime) {
        // If missing, try to derive from Dateonly + Swipe_Time
        if (copy.Dateonly && copy.Swipe_Time) {
          // Dateonly is "YYYY-MM-DD", Swipe_Time "HH:MM:SS"
          copy.LocaleMessageTime = new Date(`${copy.Dateonly}T${copy.Swipe_Time}`);
        } else {
          copy.LocaleMessageTime = null;
        }
      } else {
        // If it's already a Date instance leave it; if it's a string, convert
        if (!(copy.LocaleMessageTime instanceof Date)) {
          // Some drivers return strings; ensure valid Date
          copy.LocaleMessageTime = new Date(copy.LocaleMessageTime);
          if (isNaN(copy.LocaleMessageTime.getTime())) {
            // fallback: try Dateonly + Swipe_Time
            if (copy.Dateonly && copy.Swipe_Time) {
              copy.LocaleMessageTime = new Date(`${copy.Dateonly}T${copy.Swipe_Time}`);
            } else {
              copy.LocaleMessageTime = null;
            }
          }
        }
      }
      return copy;
    }).filter(e => e && e.LocaleMessageTime); // drop events we couldn't parse

    events.sort((a, b) => a.LocaleMessageTime - b.LocaleMessageTime);

    // Filter events to those <= target
    const targetJs = target.toJSDate();
    const upToTarget = events.filter(evt => evt.LocaleMessageTime && evt.LocaleMessageTime <= targetJs);

    // Reuse buildOccupancyForToday to compute the snapshot.
    // pass the same filtered list as both allEvents & freshEvents (we only need occupancy & breakdowns)
    let payload;
    try {
      payload = buildOccupancyForToday(upToTarget, upToTarget);
      // override asOf to be the requested target time (so UI can show it)
      payload.asOf = target.toISO();
    } catch (err) {
      console.error('❌ Error building occupancy snapshot for time:', err);
      return res.status(500).json({ error: 'failed to compute snapshot' });
    }

    // Return JSON payload (same shape as SSE payload, so frontend can easily swap)
    return res.json(payload);

  } catch (err) {
    console.error('❌ Unexpected error in getDenverOccupancyAtTime():', err);
    return res.status(500).json({ error: 'internal server error' });
  }
};