// App.js (only the changed/added parts shown)
import React, { useEffect, useState } from 'react';
/* ... other imports ... */
import TimeLookupPanel from './components/TimeLookupPanel'; // new component

function App() {
  // existing liveData state...
  const [liveData, setLiveData] = useState({ /* same as before */ });

  // add a history buffer (timestamped snapshots)
  const [history, setHistory] = useState([]); // each item: { ts: ISOString, total: number, payload: ... }

  useEffect(() => {
    const es = new EventSource('http://localhost:5000/api/live-occupancy');
    es.onmessage = (e) => {
      try {
        const p = JSON.parse(e.data);

        // compute a sensible "current total" from the incoming payload
        const computeTotalFromPayload = (payload) => {
          // try to derive total from payload.summary (fallbacks included)
          if (Array.isArray(payload.summary) && payload.summary.length) {
            return payload.summary.reduce((s, it) => s + (typeof it.count === 'number' ? it.count : 0), 0);
          }
          if (typeof payload.currentTotal === 'number') return payload.currentTotal; // if backend provides
          // fallback: visitedToday.total is cumulative visits so NOT live count; return 0 if unknown
          return 0;
        };

        const currentTotal = computeTotalFromPayload(p);
        const nowIso = new Date().toISOString();

        // update combined liveData as before
        setLiveData({
          summary: Array.isArray(p.summary) ? p.summary : [],
          details: p.details || {},
          floorBreakdown: Array.isArray(p.floorBreakdown) ? p.floorBreakdown : [],
          zoneBreakdown: Array.isArray(p.zoneBreakdown) ? p.zoneBreakdown : [],
          personnelBreakdown: Array.isArray(p.personnelBreakdown) ? p.personnelBreakdown : [],
          totalVisitedToday: typeof p.totalVisitedToday === 'number' ? p.totalVisitedToday : 0,
          personnelSummary: p.personnelSummary || { employees: 0, contractors: 0 },
          visitedToday: p.visitedToday || { employees: 0, contractors: 0, total: 0 },
          ertStatus: p.ertStatus || {}
        });

        // append to history (keep capped size to avoid memory growth)
        setHistory(prev => {
          const entry = { ts: nowIso, total: currentTotal, payload: p };
          const MAX = 24 * 60 * 2; // example cap: 2 days of 1-minute-ish samples (adjust as needed)
          const next = [...prev, entry];
          if (next.length > MAX) next.splice(0, next.length - MAX);
          return next;
        });
      } catch {
        console.error('SSE parse error');
      }
    };

    es.onerror = (err) => {
      console.error('SSE error', err);
      es.close();
    };

    return () => es.close();
  }, []);

  return (
    <>
      {/* Navbar unchanged */}
      <Container fluid className="mt-2">
        <Routes>
          <Route
            path="/"
            element={
              <DashboardHome
                summaryData={liveData.summary}
                detailsData={liveData.details}
                floorData={liveData.floorBreakdown}
                zoneBreakdown={liveData.zoneBreakdown}
                personnelBreakdown={liveData.personnelBreakdown}
                totalVisitedToday={liveData.totalVisitedToday}
                personnelSummary={liveData.personnelSummary}
                visitedToday={liveData.visitedToday}
                ertStatus={liveData.ertStatus}
                history={history}            // <-- pass history to the page
                currentTotal={history.length ? history[history.length - 1].total : 0} // latest total
              />
            }
          />
          {/* other routes unchanged */}
        </Routes>
      </Container>
    </>
  );
}



......




// src/components/TimeLookupPanel.jsx
import React, { useState, useMemo } from 'react';

function findCountAt(history, targetDate) {
  if (!history || history.length === 0) return { count: null, foundAt: null, note: 'no data' };
  // binary search for latest entry with ts <= targetDate
  let lo = 0, hi = history.length - 1, idx = -1;
  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    const midDate = new Date(history[mid].ts);
    if (midDate <= targetDate) { idx = mid; lo = mid + 1; }
    else { hi = mid - 1; }
  }
  if (idx === -1) {
    // no earlier sample: return first sample as "earliest"
    return { count: null, foundAt: history[0].ts, note: 'no sample at-or-before requested time' };
  }
  return { count: history[idx].total, foundAt: history[idx].ts, note: 'found' };
}

export default function TimeLookupPanel({ history = [] }) {
  // datetime-local expects "yyyy-MM-ddTHH:mm" (no timezone). The browser will treat it as local time.
  const [datetimeLocal, setDatetimeLocal] = useState('');
  const [result, setResult] = useState(null);

  // quick helper to format ISO in Asia/Kolkata (user's zone). Adjust locale as needed.
  const fmt = (iso) => {
    if (!iso) return '';
    try {
      return new Date(iso).toLocaleString('en-IN', {
        timeZone: 'Asia/Kolkata',
        year: 'numeric', month: 'short', day: 'numeric',
        hour: 'numeric', minute: '2-digit', hour12: true
      });
    } catch {
      return iso;
    }
  };

  const onLookup = () => {
    if (!datetimeLocal) {
      setResult({ error: 'Pick a date & time' });
      return;
    }
    // create Date from the local datetime string — this is in the browser's local timezone
    const target = new Date(datetimeLocal);
    const r = findCountAt(history, target);
    setResult(r);
  };

  // convenience: show nearest sample / now
  const onNow = () => {
    const last = history.length ? history[history.length - 1] : null;
    if (!last) { setResult({ error: 'No data yet' }); return; }
    setResult({ count: last.total, foundAt: last.ts, note: 'now' });
  };

  return (
    <div className="card p-3 mb-3">
      <h5>Lookup headcount for a specific time</h5>

      <div className="d-flex align-items-center gap-2" style={{ gap: '0.5rem', flexWrap: 'wrap' }}>
        <input
          type="datetime-local"
          value={datetimeLocal}
          onChange={(e) => setDatetimeLocal(e.target.value)}
          style={{ padding: '0.4rem', minWidth: 220 }}
        />
        <button className="btn btn-primary" onClick={onLookup}>Find count</button>
        <button className="btn btn-outline-secondary" onClick={onNow}>Show current</button>
      </div>

      <div className="mt-3">
        {result && result.error && <div className="text-danger">{result.error}</div>}

        {result && !result.error && (
          <>
            <div>
              <strong>Count:</strong>{' '}
              {result.count === null ? <em>no sample found</em> : result.count}
            </div>
            <div>
              <strong>Sample time:</strong>{' '}
              {result.foundAt ? fmt(result.foundAt) + ` (ISO: ${result.foundAt})` : '—'}
            </div>
            <div className="text-muted small mt-1">
              Note: result returns the latest recorded sample **at or before** the requested time.
            </div>
          </>
        )}

        {!result && <div className="text-muted">Pick a date/time and click "Find count".</div>}
      </div>
    </div>
  );
}



