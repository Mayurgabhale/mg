function buildOccupancyForToday(allEvents, freshEvents = [], atDt = null) {
  const atMillis = atDt ? atDt.setZone('America/Denver').toMillis() : null;

  // 1) Build eventsForAtDt: same Denver date AND event instant <= atDt (if atDt)
  const eventsForAtDt = allEvents.filter(evt => {
    if (!isSameDenverDate(evt.Dateonly, atDt)) return false;
    const evtDt = parseLocaleMessageTime(evt);
    if (!evtDt || !evtDt.isValid) return false;
    if (atMillis && evtDt.toMillis() > atMillis) return false;
    return true;
  });

  // 2) Evict "Out of office" by looking at the LAST event for each person (within eventsForAtDt)
  const lastByPerson = new Map(); // key -> evt
  eventsForAtDt.forEach(evt => {
    const key = personKey(evt);
    if (!key) return;
    const prev = lastByPerson.get(key);
    const evtMs = parseLocaleMessageTime(evt).toMillis();
    if (!prev || evtMs > prev._ms) {
      // store _ms so we don't reparse multiple times
      evt._ms = evtMs;
      lastByPerson.set(key, evt);
    }
  });

  const evicted = new Set();
  lastByPerson.forEach(evt => {
    if (evt.Direction === 'OutDirection' && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office') {
      const key = personKey(evt);
      if (key) evicted.add(key);
    }
  });

  // 3) activeEvents = eventsForAtDt minus evicted persons
  const activeEvents = eventsForAtDt.filter(evt => {
    const key = personKey(evt);
    return key && !evicted.has(key);
  });

  // 4) Keep only InDirection for occupancy dedupe
  const todayIn = activeEvents.filter(e => e.Direction === 'InDirection');

  // Deduplicate by person using last (latest) InDirection (by actual instant)
  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const key = personKey(e);
    if (!key) return;
    const tcurMs = parseLocaleMessageTime(e).toMillis();
    const prev = latestByPerson.get(key);
    if (!prev || tcurMs > prev._ms) {
      e._ms = tcurMs;
      latestByPerson.set(key, e);
    }
  });

  const finalList = Array.from(latestByPerson.values());

  // 5) Floor breakdown & personnel counts (live)
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') employees++;
    else contractors++;
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
    let empCount = 0, contractorCount = 0, tempBadgeCount = 0, otherCount = 0;
    occ.forEach(ev => {
      switch (ev.PersonnelType) {
        case 'Employee':
        case 'Terminated Personnel': empCount++; break;
        case 'Contractor':
        case 'Terminated Contractor': contractorCount++; break;
        case 'Temp Badge': tempBadgeCount++; break;
        default: otherCount++;
      }
    });
    return {
      floor,
      total: occ.length,
      employees: empCount,
      contractors: contractorCount,
      tempBadge: tempBadgeCount,
      others: otherCount,
      occupants: occ
    };
  });

  // 6) Personnel breakdown
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // 7) Swipe stats (fresh only) - ensure freshEvents limited by <= atDt
  const freshFiltered = (freshEvents || []).filter(evt => {
    if (!isSameDenverDate(evt.Dateonly, atDt)) return false;
    const evtDt = parseLocaleMessageTime(evt);
    return evtDt && evtDt.isValid && (!atMillis || evtDt.toMillis() <= atMillis);
  });

  const totalInSwipes = freshFiltered.filter(e => e.Direction === 'InDirection').length;
  const totalOutSwipes = freshFiltered.filter(e => e.Direction === 'OutDirection').length;

  // 8) Floor In/Out summary (strict doors only) - use eventsForAtDt
  const validEvents = eventsForAtDt.filter(evt => {
    const doorNoTime = stripTimeSuffix(evt.Door.trim());
    const key = normalizeKey(doorNoTime, evt.Direction.trim());
    return normalizedMonitoredKeys.has(key);
  });

  // Dedupe per person+floor+direction (keep latest)
  const deduped = new Map();
  validEvents.forEach(evt => {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';
    const mapKey = `${personKey(evt)}___${floor}___${evt.Direction}`;
    const nowMs = parseLocaleMessageTime(evt).toMillis();
    const prev = deduped.get(mapKey);
    if (!prev || nowMs > prev._ms) {
      evt._ms = nowMs;
      deduped.set(mapKey, evt);
    }
  });

  const floorMapIO = {};
  for (const evt of deduped.values()) {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';
    if (!floorMapIO[floor]) floorMapIO[floor] = { inSwipes: 0, outSwipes: 0, inSet: new Set(), outSet: new Set() };
    const id = personKey(evt);
    if (evt.Direction === 'InDirection') { floorMapIO[floor].inSwipes++; floorMapIO[floor].inSet.add(id); }
    else { floorMapIO[floor].outSwipes++; floorMapIO[floor].outSet.add(id); }
  }

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return { floor, inSwipes: stats.inSwipes, outSwipes: stats.outSwipes, inOnlyCount: inOnly.length, inOnlyPersons: inOnly };
  });

  // 9) Visited today breakdown - use eventsForAtDt + reference atDt
  const visited = computeVisitedToday(eventsForAtDt, atDt);

  // Build final payload
  const asOfLocal = atDt ? atDt.setZone('America/Denver').toISO() : DateTime.now().setZone('America/Denver').toISO();
  const asOfUTC = atDt ? atDt.toUTC().toISO() : new Date().toISOString();

  return {
    asOfLocal,
    asOfUTC,
    currentCount: finalList.length,
    floorBreakdown,
    personnelSummary: { employees, contractors },
    personnelBreakdown,
    totalVisitedToday: visited.total,
    visitedToday: { employees: visited.employees, contractors: visited.contractors, total: visited.total },
    swipeStats: { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}
