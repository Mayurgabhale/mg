/**
 * Build “visited today” from the same in‐memory stream
 * (calculates event local date from LocaleMessageTime to avoid relying on SQL Dateonly)
 */
function buildVisitedToday(allEvents) {
  // “Today” in Asia/Kolkata, formatted as “yyyy-MM-dd”
  const today = DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  const todayIns = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection') return false;

    // LocaleMessageTime may be a Date or an ISO string — handle both
    const evTime = evt.LocaleMessageTime instanceof Date
      ? DateTime.fromJSDate(evt.LocaleMessageTime, { zone: 'utc' })
      : DateTime.fromISO(String(evt.LocaleMessageTime), { zone: 'utc' });

    const evLocalDate = evTime.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    return evLocalDate === today;
  });

  // Dedupe by the same multi-key used elsewhere (PersonGUID || EmployeeID || CardNumber || ObjectName1)
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || e.ObjectName1;
    const prev = dedup.get(key);

    const eTs = e.LocaleMessageTime instanceof Date ? e.LocaleMessageTime.getTime() : Date.parse(String(e.LocaleMessageTime));
    const prevTs = prev
      ? (prev.LocaleMessageTime instanceof Date ? prev.LocaleMessageTime.getTime() : Date.parse(String(prev.LocaleMessageTime)))
      : 0;

    if (!prev || eTs > prevTs) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  // Separate employees vs contractors (same classification as elsewhere)
  const employees = finalList.filter(e =>
    !['Contractor', 'Terminated Contractor', 'Temp Badge', 'Visitor', 'Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}

function buildVisitedForDate(allEvents, atDate) {
  const asOfLocalDate = DateTime.fromJSDate(atDate, { zone: 'utc' })
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  const todayIns = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection') return false;

    const evTime = evt.LocaleMessageTime instanceof Date
      ? DateTime.fromJSDate(evt.LocaleMessageTime, { zone: 'utc' })
      : DateTime.fromISO(String(evt.LocaleMessageTime), { zone: 'utc' });

    const evLocalDate = evTime.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    return evLocalDate === asOfLocalDate;
  });

  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || e.ObjectName1;
    const prev = dedup.get(key);

    const eTs = e.LocaleMessageTime instanceof Date ? e.LocaleMessageTime.getTime() : Date.parse(String(e.LocaleMessageTime));
    const prevTs = prev
      ? (prev.LocaleMessageTime instanceof Date ? prev.LocaleMessageTime.getTime() : Date.parse(String(prev.LocaleMessageTime)))
      : 0;

    if (!prev || eTs > prevTs) {
      dedup.set(key, e);
    }
  }
  const finalList = Array.from(dedup.values());
  const employees = finalList.filter(e =>
    !['Contractor', 'Terminated Contractor', 'Temp Badge', 'Visitor', 'Property Management'].includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;
  return { employees, contractors, total: finalList.length };
}
