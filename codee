{/* Expanded table */}
{expandedFloor && (
  <Box sx={{ px: 2, mt: 2 }}>
    <Typography variant="h6" sx={{ color: "#FFC107" }} gutterBottom>
      {expandedFloor} — All Entries
    </Typography>

    <DataTable
      // add a Sr No column only for the expanded table (keeps original `columns` unchanged)
      columns={[{ field: "SrNo", headerName: "Sr No" }, ...columns]}
      rows={(floorMap[expandedFloor] || []).map((r, i) => ({
        ...r,
        LocaleMessageTime: formatApiDateTime(r.LocaleMessageTime),
        SrNo: i + 1 // 1,2,3...
      }))}
    />
  </Box>
)}

..m.


// src/pages/PartitionDetailDetails.jsx

import React, { useEffect, useState, useMemo } from "react";
import {
  Container, Box, Typography, Button, TextField,
  Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody
} from "@mui/material";
import { useParams, useNavigate } from "react-router-dom";

import Header from "../components/Header";
import Footer from "../components/Footer";
import LoadingSpinner from "../components/LoadingSpinner";
import DataTable from "../components/DataTable";

import { fetchLiveSummary } from "../api/occupancy.service";
import { lookupFloor } from "../utils/floorLookup";

export default function PartitionDetailDetails() {
  const { partition } = useParams();
  const navigate = useNavigate();

  const [details, setDetails] = useState([]); // array of swipe/detail records
  const [liveCounts, setLiveCounts] = useState({}); // keyed by floor
  const [loading, setLoading] = useState(true);
  const [lastUpdate, setLastUpdate] = useState("");
  const [search, setSearchTerm] = useState("");
  const [expandedFloor, setExpandedFloor] = useState(null);

  // Helper: format API ISO (UTC) to "hh:mm:ss AM/PM"
  const formatApiDateTime = iso => {
    if (!iso) return "";
    const d = new Date(iso);
    if (isNaN(d)) return iso;

    const hours24 = d.getUTCHours();
    const minutes = String(d.getUTCMinutes()).padStart(2, "0");
    const seconds = String(d.getUTCSeconds()).padStart(2, "0");

    const ampm = hours24 >= 12 ? "PM" : "AM";
    let hour12 = hours24 % 12;
    if (hour12 === 0) hour12 = 12;
    const hourStr = String(hour12).padStart(2, "0");

    // Use backticks for template literal
    return `${hourStr}:${minutes}:${seconds} ${ampm}`;
  };

  // 1) Filter the raw details → keep only In/Out for this partition,
  //    map to include floor, then drop any that resolve to "Unmapped"
  const filterAndMap = json => {
    const arr = json?.details ?? []; // guard: if json or json.details missing -> use []
    if (!Array.isArray(arr)) return [];

    return arr
      .filter(r =>
        r?.PartitionName2 === partition &&
        (r?.Direction === "InDirection" || r?.Direction === "OutDirection")
      )
      .map(r => {
        const floor = lookupFloor(r.PartitionName2, r.Door, r.Direction);
        return { ...r, floor };
      })
      .filter(r => r.floor !== "Unmapped");
  };

  // initial load
  useEffect(() => {
    let active = true;
    (async () => {
      try {
        const json = await fetchLiveSummary();
        if (!active) return;
        setLiveCounts(json?.realtime?.[partition]?.floors || {});
        setDetails(filterAndMap(json));
        setLastUpdate(new Date().toLocaleTimeString());
      } catch (err) {
        console.error("fetchLiveSummary (initial) failed:", err);
        // keep loading false to avoid indefinite spinner, optionally show error UI
      } finally {
        if (active) setLoading(false);
      }
    })();
    return () => { active = false; };
  }, [partition]);

  // poll every second
  useEffect(() => {
    let active = true;
    const iv = setInterval(async () => {
      try {
        const json = await fetchLiveSummary();
        if (!active) return;
        setLiveCounts(json?.realtime?.[partition]?.floors || {});
        setDetails(filterAndMap(json));
        setLastUpdate(new Date().toLocaleTimeString());
      } catch (err) {
        console.error("fetchLiveSummary (poll) failed:", err);
      }
    }, 1000);
    return () => { active = false; clearInterval(iv); };
  }, [partition]);

  // group by floor name
  const floorMap = useMemo(() => {
    const m = {};
    // ensure keys exist for floors we know about (from liveCounts)
    Object.keys(liveCounts || {}).forEach(f => { m[f] = [] });
    // push details into the appropriate floor bucket
    (details || []).forEach(r => {
      if (!r?.floor) return; // defensive
      if (!m[r.floor]) m[r.floor] = [];
      m[r.floor].push(r);
    });
    return m;
  }, [details, liveCounts]);

  // apply search filter to each floor's list
  const displayed = useMemo(() => {
    const term = (search || "").toLowerCase();
    return Object.entries(floorMap || {})
      .map(([floor, emps]) => {
        const filtered = (emps || []).filter(e => {
          // defensive string conversions
          const floorMatch = (floor || "").toLowerCase().includes(term);
          const nameMatch = (e?.ObjectName1 || "").toLowerCase().includes(term);
          const empIdMatch = String(e?.EmployeeID ?? "").toLowerCase().includes(term);
          const cardMatch = String(e?.CardNumber ?? "").toLowerCase().includes(term);
          return floorMatch || nameMatch || empIdMatch || cardMatch;
        });
        return [floor, filtered];
      })
      .filter(([, emps]) => Array.isArray(emps) && emps.length > 0);
  }, [floorMap, search]);

  const columns = [
    { field: "EmployeeID", headerName: "Emp ID" },
    { field: "ObjectName1", headerName: "Name" },
    { field: "LocaleMessageTime", headerName: "Swipe Time" },
    { field: "PersonnelType", headerName: "Type" },
    { field: "CompanyName", headerName: "Company" },
    { field: "CardNumber", headerName: "Card" },
    { field: "Door", headerName: "Door" },
  ];

  if (loading) {
    return (
      <>
        <Header />
        <Box sx={{ px: 2, py: 8 }}><LoadingSpinner /></Box>
        <Footer />
      </>
    );
  }

  return (
    <>
      <Header />
      <Box sx={{ pt: 1, pb: 1, background: "rgba(0,0,0,0.6)" }}>
        <Container disableGutters maxWidth={false}>
          {/* Back button + title */}
          <Box display="flex" alignItems="center" mb={2} sx={{ px: 2 }}>
            <Button size="small" onClick={() => navigate(-1)} sx={{ color: "#FFC107" }}>
              ← Back to Overview
            </Button>
          </Box>

          {/* Search + timestamp */}
          <Box display="flex" alignItems="center" gap={2} mb={2} sx={{ px: 2 }}>
            <Typography variant="h6" sx={{ color: "#FFC107" }}>
              Floor Details
            </Typography>
            <Typography variant="body2" sx={{ color: "#FFC107" }}>
              Last updated: {lastUpdate}
            </Typography>
            <TextField
              size="small"
              placeholder="Search floor / emp…"
              value={search}
              onChange={e => setSearchTerm(e.target.value)}
              sx={{
                "& .MuiInputBase-input": { color: "#FFC107" },
                "& .MuiOutlinedInput-root fieldset": { borderColor: "#FFC107" }
              }}
            />
          </Box>

          {/* Floor cards */}
          <Box display="flex" flexWrap="wrap" width="100%" sx={{ px: 2 }}>
            {displayed.map(([floor, emps]) => (
              <Box key={floor} sx={{ width: "50%", p: 2 }}>
                <Paper sx={{
                  border: "2px solid #FFC107",
                  p: 2,
                  background: "rgba(0,0,0,0.4)"
                }}>
                  <Typography
                    variant="subtitle1"
                    fontWeight={600}
                    gutterBottom
                    sx={{ color: "#FFC107" }}
                  >
                    {floor} (Total {emps.length})
                  </Typography>

                  <TableContainer
                    component={Paper}
                    variant="outlined"
                    sx={{ mb: 1, background: "rgba(0,0,0,0.4)" }}
                  >
                    <Table size="small">
                      <TableHead>
                        <TableRow sx={{ bgcolor: "#000" }}>
                          {["Emp ID", "Name", "Swipe Time", "Type", "Company", "Card", "Door"].map(h => (
                            <TableCell
                              key={h}
                              sx={{
                                color: "#FFC107",
                                border: "1px solid #FFC107",
                                fontWeight: "bold"
                              }}
                            >
                              {h}
                            </TableCell>
                          ))}
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {emps.slice(0, 10).map((r, i) => (
                          <TableRow key={`${r?.EmployeeID ?? "idx"}-${i}`}>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r?.EmployeeID ?? ""}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r?.ObjectName1 ?? ""}
                            </TableCell>

                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {formatApiDateTime(r?.LocaleMessageTime)}
                            </TableCell>

                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r?.PersonnelType ?? ""}
                            </TableCell>

                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r?.CompanyName ?? ""}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r?.CardNumber ?? ""}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r?.Door ?? ""}
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>

                  <Button
                    size="small"
                    onClick={() => setExpandedFloor(f => f === floor ? null : floor)}
                    sx={{ color: "#FFC107" }}
                  >
                    {expandedFloor === floor ? "Hide" : "See more…"}
                  </Button>
                </Paper>
              </Box>
            ))}
          </Box>

          {/* Expanded table */}
          {expandedFloor && (
            <Box sx={{ px: 2, mt: 2 }}>
              <Typography variant="h6" sx={{ color: "#FFC107" }} gutterBottom>
                {expandedFloor} — All Entries
              </Typography>

              <DataTable
                // add a Sr No column only for the expanded table (keeps original `columns` unchanged)
                columns={[{ field: "SrNo", headerName: "Sr No" }, ...columns]}
                // **DEFENSIVE**: guard with empty array when floorMap[expandedFloor] is undefined
                rows={(floorMap[expandedFloor] || []).map((r, i) => ({
                  ...r,
                  LocaleMessageTime: formatApiDateTime(r?.LocaleMessageTime),
                  SrNo: i + 1 // 1,2,3...
                }))}
              />
            </Box>
          )}
        </Container>
      </Box>
      <Footer />
    </>
  );
}