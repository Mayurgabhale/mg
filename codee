function filterData() {
  // Read UI selections
  const rawTypeSel = (document.getElementById('device-type')?.value || '');
  const rt = rawTypeSel.toUpperCase();

  // Normalize displayed device-type values to the internal data-category values
  let typeSel;
  if (rt === 'DESKTOP') typeSel = 'PCDETAIL';
  else if (rt === 'DB SERVER' || rt === 'DBSERVER') typeSel = 'DBDETAIL';
  else typeSel = rt; // e.g., ALL, CONTROLLER, CAMERA, SERVER, ARCHIVER

  const remarkSel = (document.getElementById('remark-filter')?.value || '').toUpperCase();
  const cityFilterEl = document.getElementById('cityFilter');
  const prevCityVal = cityFilterEl?.value || 'ALL';
  const searchTxt = (document.getElementById('search-input')?.value || '').toUpperCase();

  // Collect rows
  const tbodyRows = Array.from(document.querySelectorAll('#device-table tbody tr'));

  // First: figure out which cities are possible given type+remark+search (preserve original casing)
  const possibleCitiesMap = new Map(); // key: UPPERCASE city -> value: original city text
  tbodyRows.forEach(r => {
    const ip = r.cells[1].textContent.toUpperCase();
    const name = r.cells[2].textContent.toUpperCase();

    const typeCell = r.cells[3];
    const typeVal = (typeCell && typeCell.getAttribute('data-category'))
      ? typeCell.getAttribute('data-category').toUpperCase()
      : typeCell.textContent.toUpperCase();

    const cityOriginal = (r.cells[4].textContent || '').trim();
    const cityUp = cityOriginal.toUpperCase();
    const remark = (r.cells[9]?.textContent || '').toUpperCase();

    const matchesType = (typeSel === 'ALL' || typeVal === typeSel);
    const matchesRemark = (remarkSel === 'ALL' || remark.includes(remarkSel));
    const matchesSearch = (ip.includes(searchTxt) || name.includes(searchTxt));

    if (matchesType && matchesRemark && matchesSearch && cityOriginal) {
      possibleCitiesMap.set(cityUp, cityOriginal);
    }
  });

  // Sort possible cities (preserve case)
  const possibleCities = Array.from(possibleCitiesMap.values()).sort((a, b) => a.localeCompare(b));

  // Rebuild the city dropdown so it contains only available cities + All Cities
  if (cityFilterEl) {
    const prev = prevCityVal;
    cityFilterEl.innerHTML = '';

    const allOpt = document.createElement('option');
    allOpt.value = 'ALL';
    allOpt.textContent = 'All Cities';
    cityFilterEl.appendChild(allOpt);

    possibleCities.forEach(cityName => {
      const opt = document.createElement('option');
      opt.value = cityName;
      opt.textContent = cityName;
      cityFilterEl.appendChild(opt);
    });

    // Restore previous selection if still valid; else choose ALL
    const restored = (prev && (prev.toUpperCase() === 'ALL' || possibleCitiesMap.has(prev.toUpperCase()))) ? prev : 'ALL';
    cityFilterEl.value = restored;
  }

  // Now apply visibility of rows using the (possibly updated) city selection
  const citySel = (document.getElementById('cityFilter')?.value || 'ALL').toUpperCase();

  tbodyRows.forEach(r => {
    const ip = r.cells[1].textContent.toUpperCase();
    const name = r.cells[2].textContent.toUpperCase();

    const typeCell = r.cells[3];
    const type = (typeCell && typeCell.getAttribute('data-category'))
      ? typeCell.getAttribute('data-category').toUpperCase()
      : typeCell.textContent.toUpperCase();

    const city = (r.cells[4].textContent || '').toUpperCase();
    const remark = (r.cells[9]?.textContent || '').toUpperCase();

    const matchesType   = (typeSel === 'ALL' || type === typeSel);
    const matchesRemark = (remarkSel === 'ALL' || remark.includes(remarkSel));
    const matchesCity   = (citySel === 'ALL' || city === citySel);
    const matchesSearch = (ip.includes(searchTxt) || name.includes(searchTxt));

    r.style.display = (matchesType && matchesRemark && matchesCity && matchesSearch) ? '' : 'none';
  });
}