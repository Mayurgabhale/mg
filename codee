// paste/replace in src/components/FloorInOutTable.jsx (inside the component)
useEffect(() => {
  let mounted = true;

  async function loadRejectionsTodayOnly() {
    setRejectionsLoading(true);
    try {
      const res = await fetch('/api/rejections');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const payload = await res.json();

      // ----- today in Denver (YYYY-MM-DD) -----
      const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });

      // results we'll populate
      let detailsToday = [];
      const summaryMap = {};     // { "Floor 12": 7, ... }

      // 1) If backend provided dateWise, prefer it (fast, aggregated)
      if (Array.isArray(payload.dateWise)) {
        const dayObj = payload.dateWise.find(d => d.date === todayDenver);
        if (dayObj && Array.isArray(dayObj.floors)) {
          dayObj.floors.forEach(f => {
            const key = normalizeFloorName(f.floor || f.floor);
            summaryMap[key] = Number(f.rejectionCount || 0);
          });
        }
        // Build detailsToday from payload.details (if available) so tooltip/modal has items
        if (Array.isArray(payload.details)) {
          detailsToday = payload.details.filter(d => {
            // try DateOnly (may be Date object or string) then LocaleMessageTime
            const raw = d.DateOnly || d.LocaleMessageTime || d.LocaleMessageTime;
            if (!raw) return false;
            try {
              const dt = new Date(raw);
              const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
              return dtStr === todayDenver;
            } catch (e) {
              return String(raw).slice(0, 10) === todayDenver;
            }
          });
        }
      } else {
        // 2) fallback: filter payload.details for today
        if (Array.isArray(payload.details)) {
          detailsToday = payload.details.filter(d => {
            const raw = d.LocaleMessageTime || d.DateOnly || d.LocaleMessageTime;
            if (!raw) return false;
            try {
              const dt = new Date(raw);
              const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
              return dtStr === todayDenver;
            } catch (e) {
              return String(raw).slice(0, 10) === todayDenver;
            }
          });

          // build summaryMap from filtered details
          detailsToday.forEach(d => {
            // prefer d.floor (if backend already added floor), else d.Location/door-derived floor
            const rawFloor = d.floor || d.Floor || d.Location || '';
            const key = normalizeFloorName(rawFloor) || 'Unknown';
            summaryMap[key] = (summaryMap[key] || 0) + 1;
          });
        }
      }

      // group detailsToday by normalized floor for tooltip/modal usage
      const detailsByFloor = {};
      detailsToday.forEach(d => {
        const rawFloor = d.floor || d.Floor || d.Location || '';
        const key = normalizeFloorName(rawFloor) || 'Unknown';
        detailsByFloor[key] = detailsByFloor[key] || [];
        detailsByFloor[key].push(d);
      });

      if (!mounted) return;
      setRejectionSummaryMap(summaryMap);
      setRejectionDetails(detailsByFloor);
    } catch (err) {
      console.error('Failed to load rejections:', err);
      if (mounted) {
        setRejectionSummaryMap({});
        setRejectionDetails({});
      }
    } finally {
      if (mounted) setRejectionsLoading(false);
    }
  }

  loadRejectionsTodayOnly();
  return () => { mounted = false; };
}, []);
