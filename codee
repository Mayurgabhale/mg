
// Autosize columns (no unnecessary padding for short values)
ws.columns.forEach((col, index) => {
  let maxLen = col.header ? String(col.header).length : 1;

  col.eachCell({ includeEmpty: true }, c => {
    const v = c.value === null || c.value === undefined ? '' : String(c.value);
    maxLen = Math.max(maxLen, v.trim().length);
  });

  // Remove extra padding, keep small cols tight
  if (index === 0) {
    // Sr column — force small width
    col.width = 4;
  } else {
    col.width = Math.min(Math.max(maxLen, 6), 30);
  }
});

// Fix alignment for small columns
ws.getColumn(1).alignment = { horizontal: 'center' }; // Sr
ws.getColumn(2).alignment = { horizontal: 'center' }; // Date
ws.getColumn(3).alignment = { horizontal: 'center' }; // Time



....
one issue in the space in column 
Sr	Date	Time	EmployeeID	CardNumber	Name	PersonnelType
this getting more space
for example 
sr 
1
2
3 
bu they gettin g
1.....................
2.....................

like space so it is now lookin better 
remove space 

// Excel export (more attractive) — uses ExcelJS (already imported)
const handleExport = async () => {
  if (!pickedDate || !detailRows || detailRows.length === 0) return;

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Details');

  // Columns to export (order + keys)
  const cols = [
    { header: 'Sr', key: 'sr', width: 2 },
    { header: 'Date', key: 'date', width: 5 },
    { header: 'Time', key: 'time', width: 5 },
    { header: 'EmployeeID', key: 'employee', width: 6 },
    { header: 'CardNumber', key: 'card', width: 6 },
    { header: 'Name', key: 'name', width: 32 },
    { header: 'PersonnelType', key: 'type', width: 10 },
    { header: 'CompanyName', key: 'company', width: 30 },
    { header: 'PrimaryLocation', key: 'location', width: 32 },
    { header: 'Door', key: 'door', width: 40 },
    { header: 'Partition', key: 'partition', width: 10 },
  ];

  ws.columns = cols;

  // Title row (merged)
  const lastColLetter = String.fromCharCode('A'.charCodeAt(0) + cols.length - 1);
  ws.mergeCells(`A1:${lastColLetter}1`);
  const titleCell = ws.getCell('A1');
  titleCell.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')} — Details`;
  titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
  titleCell.font = { name: 'Calibri', size: 14, bold: true, color: { argb: 'FF000000' } };
  titleCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF2F2F2' } };

  // Spacer row
  ws.addRow([]);

  // Header row
  const headerRow = ws.addRow(cols.map(c => c.header));
  headerRow.eachCell(cell => {
    cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle', wrapText: false };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } }; // amber
    cell.border = {
      top: { style: 'thin', color: { argb: 'FF000000' } },
      left: { style: 'thin', color: { argb: 'FF000000' } },
      bottom: { style: 'thin', color: { argb: 'FF000000' } },
      right: { style: 'thin', color: { argb: 'FF000000' } },
    };
  });

  // Data rows
  detailRows.forEach((r, i) => {
    const row = ws.addRow([
      i + 1,
      format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd'),
      formatApiTime12(r.LocaleMessageTime),
      r.EmployeeID ?? '',
      r.CardNumber ?? '',
      r.ObjectName1 ?? '',
      r.PersonnelType ?? '',
      (r.CompanyNameComputed || r.CompanyName) ?? '',
      r.PrimaryLocation ?? '',
      r.Door ?? '',
      partitionToDisplay[r.PartitionName2]?.city || r.PartitionName2 || ''
    ]);

    // Row styling: borders + alignment
    row.eachCell((cell, colNumber) => {
      cell.alignment = { vertical: 'middle', horizontal: (colNumber >= 4 && colNumber <= 5) ? 'right' : 'left', wrapText: false };
      cell.font = { name: 'Calibri', size: 11, color: { argb: 'FF000000' } };
      cell.border = {
        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
        right: { style: 'thin', color: { argb: 'FFCCCCCC' } },
      };
    });

    // Zebra stripe every other row
    if (i % 2 === 1) {
      row.eachCell(cell => {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
      });
    }
  });

  // Totals row (count)
  const totalCount = detailRows.length;
  const totalRow = ws.addRow(['', '', '', '', '', '', '', '', '', 'Total', totalCount]);
  totalRow.eachCell((cell, colNumber) => {
    cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
    cell.alignment = { horizontal: colNumber === 11 ? 'right' : 'center', vertical: 'middle' };
    cell.border = {
      top: { style: 'thin', color: { argb: 'FF000000' } },
      left: { style: 'thin', color: { argb: 'FF000000' } },
      bottom: { style: 'thin', color: { argb: 'FF000000' } },
      right: { style: 'thin', color: { argb: 'FF000000' } },
    };
    if (colNumber === 11) {
      cell.numFmt = '#,##0';
    }
  });

  // Autosize columns (reasonable limits)
  ws.columns.forEach(col => {
    let maxLen = col.header ? String(col.header).length : 10;
    col.eachCell({ includeEmpty: true }, c => {
      const v = c.value === null || c.value === undefined ? '' : String(c.value);
      maxLen = Math.max(maxLen, v.trim().length + 2);
    });
    col.width = Math.min(Math.max(maxLen, 2), 30);
  });

  // Freeze header area (title + spacer + header visible)
  ws.views = [{ state: 'frozen', ySplit: 3 }];

  // Outer thin border polish for the used area
  const lastRow = ws.rowCount;
  const lastCol = ws.columns.length;
  for (let r = 1; r <= lastRow; r++) {
    for (let c = 1; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      cell.border = {
        top: cell.border?.top || { style: 'thin', color: { argb: 'FFEEEEEE' } },
        left: cell.border?.left || { style: 'thin', color: { argb: 'FFEEEEEE' } },
        bottom: cell.border?.bottom || { style: 'thin', color: { argb: 'FFEEEEEE' } },
        right: cell.border?.right || { style: 'thin', color: { argb: 'FFEEEEEE' } },
      };
    }
  }

  // Save workbook
  const buf = await wb.xlsx.writeBuffer();
  saveAs(new Blob([buf]), `history_${format(pickedDate, 'yyyyMMdd')}.xlsx`);
};
