// --- fetch rejections and keep only today's (Denver) records ---
useEffect(() => {
  let mounted = true;

  async function loadRejectionsTodayOnly() {
    setRejectionsLoading(true);
    try {
      const res = await fetch('/api/rejections');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const payload = await res.json();

      // today in Denver (YYYY-MM-DD)
      const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });

      // helper to check if a detail is for today
      const isDetailToday = (d, todayDenver) => {
        if (!d) return false;

        if (d.DateOnly) {
          try {
            const dateOnlyStr = (typeof d.DateOnly === 'string')
              ? d.DateOnly.slice(0, 10)
              : new Date(d.DateOnly).toISOString().slice(0, 10);
            return dateOnlyStr === todayDenver;
          } catch {
            return String(d.DateOnly).slice(0, 10) === todayDenver;
          }
        }

        if (d.LocaleMessageTime) {
          try {
            const dt = new Date(d.LocaleMessageTime);
            const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
            return dtStr === todayDenver;
          } catch {
            return String(d.LocaleMessageTime).slice(0, 10) === todayDenver;
          }
        }

        return false;
      };

      // collect today's details (flat)
      let detailsToday = [];
      const summaryMap = {};

      // Prefer backend dateWise (aggregates) for counts if available
      if (Array.isArray(payload.dateWise)) {
        const dayObj = payload.dateWise.find(d => d.date === todayDenver);
        if (dayObj && Array.isArray(dayObj.floors)) {
          dayObj.floors.forEach(f => {
            const key = normalizeFloorName(f.floor || '');
            if (!key) return;
            summaryMap[key] = Number(f.rejectionCount || 0);
          });
        }
        // build detailsToday from payload.details so we can populate modal content
        if (Array.isArray(payload.details)) {
          detailsToday = payload.details.filter(d => isDetailToday(d, todayDenver));
        }
      } else {
        // fallback: filter details for today and aggregate counts
        if (Array.isArray(payload.details)) {
          detailsToday = payload.details.filter(d => isDetailToday(d, todayDenver));

          // derive floor per record and increment summary
          detailsToday.forEach(d => {
            const derived = deriveFloorFromRecord(d) || 'Unknown';
            const key = normalizeFloorName(derived);
            summaryMap[key] = (summaryMap[key] || 0) + 1;
          });
        }
      }

      // group detailsToday by normalized floor (derive floor if missing)
      const detailsByFloor = {};
      detailsToday.forEach(d => {
        const derived = deriveFloorFromRecord(d) || 'Unknown';
        const key = normalizeFloorName(derived) || 'Unknown';
        detailsByFloor[key] = detailsByFloor[key] || [];
        detailsByFloor[key].push(d);
      });

      if (!mounted) return;
      setRejectionSummaryMap(summaryMap);
      setRejectionDetails(detailsByFloor);
      setRejectionAllDetailsToday(detailsToday);
    } catch (err) {
      console.error('Failed to load rejections:', err);
      if (mounted) {
        setRejectionSummaryMap({});
        setRejectionDetails({});
        setRejectionAllDetailsToday([]);
      }
    } finally {
      if (mounted) setRejectionsLoading(false);
    }
  }

  loadRejectionsTodayOnly();
  return () => { mounted = false; };
}, []);