// Replace the previous companyRows useMemo with this
const companyRows = useMemo(() => {
  if (!data || !pickedDate) return [];

  const ds = format(pickedDate, 'yyyy-MM-dd');

  // base filtered details: same as before (date + optional top-level filterCode)
  const baseFiltered = data.details.filter(r =>
    ((r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10) === ds) ||
      (r.SwipeDate && r.SwipeDate.slice(0, 10) === ds)) &&
    (!filterCode || (r.PartitionName2 && r.PartitionName2.startsWith(filterCode + '.')))
  );

  // If a summary partition is selected, parse it into country/city for filtering
  let selCountry = null;
  let selCity = null;
  if (selectedSummaryPartition) {
    const parts = String(selectedSummaryPartition || '').split('||');
    selCountry = parts[0] || null;
    selCity = parts[1] || null;
  }

  // Determine personnel filter predicate (if any)
  const wantPersonnel = selectedPersonnel ? String(selectedPersonnel).toLowerCase() : null;
  const matchesPersonnel = (r) => {
    if (!wantPersonnel) return true; // no personnel filter -> accept all
    const pt = String(r.PersonnelType || '').toLowerCase();
    if (wantPersonnel === 'employee') return pt.includes('employee') || pt === 'emp' || pt === 'e';
    if (wantPersonnel === 'contractor') return pt.includes('contractor') || pt === 'contract' || pt === 'c';
    return true;
  };

  // Build map only from rows that pass (summary partition filter if set) AND personnel filter if set.
  const map = new Map();

  baseFiltered.forEach(r => {
    // derive partition country & city (same code you already use elsewhere)
    const [code, cityRaw] = String(r.PartitionName2 || '').split('.');
    const city = (cityRaw || r.PartitionName2 || 'Unknown').replace('Partition', '').trim();
    const country = codeToCountry[code] || code || 'Unknown';

    // if a summary partition is selected, skip rows outside it
    if (selCountry && selCity) {
      if (country !== selCountry || city !== selCity) return;
    }

    // if personnel filter is active, skip rows that are not that personnel type
    if (!matchesPersonnel(r)) return;

    // canonicalize company (keeps your existing logic)
    const company = getCanonicalCompany(r);

    const key = `${country}||${city}||${company}`;
    const existing = map.get(key);
    if (existing) {
      existing.total += 1;
    } else {
      map.set(key, { country, city, company, total: 1 });
    }
  });

  return Array.from(map.values()).sort((a, b) => {
    if (a.country !== b.country) return a.country.localeCompare(b.country);
    if (a.city !== b.city) return a.city.localeCompare(b.city);
    return a.company.localeCompare(b.company);
  });
}, [data, pickedDate, filterCode, selectedPersonnel, selectedSummaryPartition]);