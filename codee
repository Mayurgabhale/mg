this month getting correct absent and presetn
http://localhost:5000/api/monthly-summary?month=2025-09
{
      "employeeId": "0",
      "name": "India, TEMP_PUN_006",
      "personnelType": "Temp Badge",
      "2025-09-01": "P",
      "2025-09-02": "P",
      "2025-09-03": "P",
      "2025-09-04": "P",
      "2025-09-05": "P",
      "2025-09-06": "P",
      "2025-09-07": "A",
      "2025-09-08": "P",
      "2025-09-09": "P",
      "2025-09-10": "P",
      "2025-09-11": "P",
      "2025-09-12": "P",
      "2025-09-13": "P",
      "2025-09-14": "A",
      "2025-09-15": "A",
      "2025-09-16": "P",
      "2025-09-17": "P",
      "2025-09-18": "P",
      "2025-09-19": "P",
      "2025-09-20": null,
      "2025-09-21": null,
      "2025-09-22": null,
      "2025-09-23": null,
      "2025-09-24": null,
      "2025-09-25": null,
      "2025-09-26": null,
      "2025-09-27": null,
      "2025-09-28": null,
      "2025-09-29": null,
      "2025-09-30": null,
      "daysPresent": 16,
      "daysAbsent": 3,
      "attendancePercent": "84.2%"
    },
    {

+++++
But this month privius monthe not correct attendenuns
++

http://localhost:5000/api/monthly-summary?month=2025-08

  {
      "employeeId": "0",
      "name": "India, TEMP_PUN_006",
      "personnelType": "Temp Badge",
      "2025-08-01": "A",
      "2025-08-02": "A",
      "2025-08-03": "A",
      "2025-08-04": "A",
      "2025-08-05": "A",
      "2025-08-06": "A",
      "2025-08-07": "A",
      "2025-08-08": "A",
      "2025-08-09": "A",
      "2025-08-10": "A",
      "2025-08-11": "A",
      "2025-08-12": "A",
      "2025-08-13": "A",
      "2025-08-14": "A",
      "2025-08-15": "A",
      "2025-08-16": "A",
      "2025-08-17": "A",
      "2025-08-18": "A",
      "2025-08-19": "A",
      "2025-08-20": "P",
      "2025-08-21": "P",
      "2025-08-22": "P",
      "2025-08-23": "P",
      "2025-08-24": "A",
      "2025-08-25": "P",
      "2025-08-26": "P",
      "2025-08-27": "A",
      "2025-08-28": "P",
      "2025-08-29": "P",
      "2025-08-30": "P",
      "2025-08-31": "A",
      "daysPresent": 9,
      "daysAbsent": 22,
      "attendancePercent": "29.0%"
    },

somthing wrong
write correcy code:

// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    // Month start/end in Pune local zone
    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    // Today in Pune (string yyyy-LL-dd)
    const todayKolkataStr = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

    // All month dates as strings
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // If requested month is current month, only consider days up to today for attendance math.
    const isRequestedMonthCurrent =
      start.toFormat('yyyy-LL') === DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL');
    const consideredDates = isRequestedMonthCurrent
      ? allDates.filter(d => d <= todayKolkataStr)
      : allDates.slice();

    // SQL boundaries (UTC)
    const startUtc = start.setZone('utc').toJSDate();
    const endUtc = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    // Grab Card/CHUID value (CardNumber) as well to improve dedupe
    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door,
          sc.value AS CardNumber
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC BETWEEN @start AND @end
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    // Convert to Pune local time & normalize events
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Group events by day
    const byDay = new Map();
    for (const evt of events) {
      if (!byDay.has(evt.Dateonly)) byDay.set(evt.Dateonly, []);
      byDay.get(evt.Dateonly).push(evt);
    }

    // Aggregates
    const dailySummaries = [];        // {date, total}
    const peakOccupancy = [];         // {date, peak}
    const visitCounter = new Map();   // key -> {count, employeeId, name, personnelType}
    const presenceByPerson = new Map(); // key -> {employeeId, name, personnelType, days: Set}

    // Stable dedupe key (deterministic)
    const dedupeKey = (e) => {
      const guid = (e.PersonGUID || '').toString().trim();
      const emp = (e.EmployeeID || '').toString().trim();
      const card = (e.CardNumber || '').toString().trim();
      const name = (e.ObjectName1 || '').toString().trim();
      // Prefer GUID, then EmployeeID, then CardNumber, then Name
      if (guid) return `g:${guid}`;
      if (emp) return `e:${emp}`;
      if (card) return `c:${card}`;
      if (name) return `n:${name.toLowerCase()}`;
      return `unknown`; // stable fallback
    };

    // Process each day that has any events
    for (const [date, dayEvents] of byDay.entries()) {
      // Unique daily headcount: dedupe per-person for that day
      const uniquePeople = new Set();
      for (const e of dayEvents) uniquePeople.add(dedupeKey(e));
      dailySummaries.push({ date, total: uniquePeople.size });

      // Peak occupancy simulation (+1 on InDirection, -1 on OutDirection)
      let currentCount = 0;
      let maxCount = 0;
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') currentCount++;
        else if (e.Direction === 'OutDirection') currentCount = Math.max(0, currentCount - 1);
        // If Direction is null/undefined, do not change counter (can't assume in/out)
        if (currentCount > maxCount) maxCount = currentCount;
      }
      peakOccupancy.push({ date, peak: maxCount });

      // Track visits and presence:
      // Presence = any event for the person on that date that is NOT explicitly OutDirection.
      // This counts InDirection OR events where Direction is null/unknown.
      const daySeen = new Set(); // to avoid incrementing presence multiple times per day for same person
      for (const e of dayEvents) {
        const key = dedupeKey(e);

        // visits: count raw IN swipes only (Direction === 'InDirection')
        if (e.Direction === 'InDirection') {
          if (!visitCounter.has(key)) {
            visitCounter.set(key, {
              count: 0,
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType
            });
          }
          visitCounter.get(key).count++;
        }

        // presence: count the person present on this day if we see any non-OutDirection row
        const isPresenceEvent = (e.Direction !== 'OutDirection'); // includes 'InDirection' and null
        if (isPresenceEvent && !daySeen.has(key)) {
          daySeen.add(key);
          if (!presenceByPerson.has(key)) {
            presenceByPerson.set(key, {
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType,
              days: new Set()
            });
          }
          presenceByPerson.get(key).days.add(date);
        }
      }
    }

    // Average daily headcount: average over consideredDates (days up to today for current month)
    const dailyTotalsByDate = Object.fromEntries(dailySummaries.map(d => [d.date, d.total]));
    const consideredTotals = consideredDates.map(d => dailyTotalsByDate[d] || 0);
    const avgDailyHeadcount = consideredTotals.length
      ? Math.round(consideredTotals.reduce((s, v) => s + v, 0) / consideredTotals.length)
      : 0;

    // Top 10 visitors by swipe count
    const top10Visitors = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({
        employeeId: v.employeeId,
        name: v.name,
        personnelType: v.personnelType,
        visits: v.count
      }));

    // Attendance sheet:
    // For each person who appeared at least once in the month, produce a row with all month columns.
    // Future dates (if current month) are null and are NOT counted in daysAbsent/attendance%.
    const attendanceSheet = Array.from(presenceByPerson.entries()).map(([key, p]) => {
      const row = {
        employeeId: p.employeeId,
        name: p.name,
        personnelType: p.personnelType
      };

      let presentCount = 0;

      for (const d of allDates) {
        const isFuture = (isRequestedMonthCurrent && d > todayKolkataStr);
        if (isFuture) {
          row[d] = null;
          continue;
        }

        if (p.days.has(d)) {
          row[d] = "P";
          presentCount++;
        } else {
          row[d] = "A";
        }
      }

      const workingDaysToDate = consideredDates.length; // number of days we consider for attendance
      const daysAbsent = workingDaysToDate - presentCount;
      const attendancePercent = workingDaysToDate > 0
        ? ((presentCount / workingDaysToDate) * 100).toFixed(1) + '%'
        : '0.0%';

      row.daysPresent = presentCount;
      row.daysAbsent = daysAbsent;
      row.attendancePercent = attendancePercent;
      return row;
    });

    return res.json({
      month,
      today: todayKolkataStr,
      workingDaysConsidered: consideredDates.length,
      avgDailyHeadcount,
      peakOccupancy,
      top10Visitors,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
