// controllers/denverLiveOccupancyController.js
// (Replace your current file with this version)

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey       = require('../data/normalizeKey');

const warnedKeys = new Set();
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(([door, dir]) => normalizeKey(door, dir))
);

// ... keep your helper functions (mapDoorToFloor, stripTimeSuffix, isSameDenverDate, etc.)
/* (copy the helper functions you already have: mapDoorToFloor, stripTimeSuffix,
   isSameDenverDate, computeVisitedToday, buildOccupancyForToday, fetchEventsWindowUntil, fetchNewEvents) */

async function fetchNewEvents_safe(since) {
  // wrapper that logs and returns []
  try {
    const recs = await fetchNewEvents(since);
    console.log(`[DENVER] fetchNewEvents returned ${Array.isArray(recs) ? recs.length : '???' } rows (since=${since})`);
    return Array.isArray(recs) ? recs : [];
  } catch (err) {
    console.error('[DENVER] fetchNewEvents ERROR:', err);
    return [];
  }
}

// Live SSE endpoint with heartbeat + non-overlap + logging
exports.getDenverLiveOccupancy = async (req, res) => {
  try {
    // ensure poolPromise at least initialised (does not throw)
    const poolMaybe = await denver.poolPromise;
    if (!poolMaybe) {
      console.warn('⚠️ Denver poolPromise resolved to null — DB likely unavailable');
    }
  } catch (err) {
    console.error('❌ Failed to initialize Denver pool in SSE endpoint:', err);
    // still continue but logs will show missing DB
  }

  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.write('\n');

  // heartbeat comment every 15s so clients do not time out
  const heartbeat = setInterval(() => {
    try {
      // SSE comment keeps connection alive but is ignored by EventSource data parser
      res.write(': heartbeat\n\n');
      if (typeof res.flush === 'function') res.flush();
    } catch (err) {
      console.warn('⚠️ Failed to send heartbeat (connection likely closed):', err);
    }
  }, 15_000);

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];
  let pushRunning = false;
  let consecutiveDbErrors = 0;

  const push = async () => {
    if (pushRunning) {
      console.debug('[DENVER] push already running — skipping this tick');
      return;
    }
    pushRunning = true;
    try {
      const fresh = await fetchNewEvents_safe(lastSeen);

      if (fresh.length) {
        // update lastSeen to the latest event's LocaleMessageTime (string or Date)
        const lastEvt = fresh[fresh.length - 1];
        if (lastEvt && lastEvt.LocaleMessageTime) {
          lastSeen = new Date(lastEvt.LocaleMessageTime);
        } else {
          lastSeen = new Date();
        }
        events.push(...fresh);
        console.log(`[DENVER] pushed ${fresh.length} new events — events buffer now ${events.length}`);
      }

      // prune events not on today's Denver date (keep memory small)
      const todayDenver = DateTime.now().setZone('America/Denver').toISODate();
      for (let i = events.length - 1; i >= 0; i--) {
        const ts = events[i].Dateonly || (events[i].LocaleMessageTime ? DateTime.fromISO(events[i].LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver').toISODate() : null);
        if (!ts || ts !== todayDenver) events.splice(i, 1);
      }

      // build payload
      let payload;
      try {
        payload = buildOccupancyForToday(events, fresh, null); // live mode (null => uses now)
      } catch (err) {
        console.error('[DENVER] Error building payload:', err);
        payload = {
          asOfLocal: DateTime.now().setZone('America/Denver').toISO(),
          asOfUTC: new Date().toISOString(),
          currentCount: 0,
          floorBreakdown: [],
          personnelSummary: { employees: 0, contractors: 0 },
          personnelBreakdown: [],
          totalVisitedToday: 0,
          visitedToday: { employees: 0, contractors: 0, total: 0 },
          swipeStats: { totalInSwipes: 0, totalOutSwipes: 0 },
          floorInOutSummary: []
        };
      }

      // write SSE event
      const sid = Date.now();
      try {
        res.write(`id: ${sid}\n`);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
        if (typeof res.flush === 'function') res.flush();
        console.debug(`[DENVER] wrote payload id=${sid}`);
      } catch (err) {
        console.warn('[DENVER] Failed to write SSE payload (connection likely closed):', err);
      }

      consecutiveDbErrors = 0;
    } catch (err) {
      consecutiveDbErrors++;
      console.error('[DENVER] push top-level error:', err);
      // back off a bit if DB failing repeatedly
      if (consecutiveDbErrors > 3) {
        console.warn(`[DENVER] ${consecutiveDbErrors} consecutive DB errors — sleeping 5s before next try`);
        await new Promise(r => setTimeout(r, 5000));
      }
    } finally {
      pushRunning = false;
    }
  };

  // run initial push, then interval
  await push();
  const timer = setInterval(push, 2000); // 2s interval and non-overlap guarded

  req.on('close', () => {
    clearInterval(timer);
    clearInterval(heartbeat);
    console.log('[DENVER] SSE client disconnected, cleared timers');
  });
};