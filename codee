// Excel export (no extra spacing in any column)
const handleExport = async () => {
  if (!pickedDate || !detailRows || detailRows.length === 0) return;

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Details');

  // Columns to export (order + keys)
  const cols = [
    { header: 'Sr', key: 'sr' },
    { header: 'Date', key: 'date' },
    { header: 'Time', key: 'time' },
    { header: 'EmployeeID', key: 'employee' },
    { header: 'CardNumber', key: 'card' },
    { header: 'Name', key: 'name' },
    { header: 'PersonnelType', key: 'type' },
    { header: 'CompanyName', key: 'company' },
    { header: 'PrimaryLocation', key: 'location' },
    { header: 'Door', key: 'door' },
    { header: 'Partition', key: 'partition' },
  ];

  ws.columns = cols;

  // Title row (merged)
  const lastColLetter = String.fromCharCode('A'.charCodeAt(0) + cols.length - 1);
  ws.mergeCells(`A1:${lastColLetter}1`);
  const titleCell = ws.getCell('A1');
  titleCell.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')} â€” Details`;
  titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
  titleCell.font = { name: 'Calibri', size: 14, bold: true, color: { argb: 'FF000000' } };
  titleCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF2F2F2' } };

  // Spacer row
  ws.addRow([]);

  // Header row
  const headerRow = ws.addRow(cols.map(c => c.header));
  headerRow.eachCell(cell => {
    cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle', wrapText: false };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } }; // amber
    cell.border = {
      top: { style: 'thin', color: { argb: 'FF000000' } },
      left: { style: 'thin', color: { argb: 'FF000000' } },
      bottom: { style: 'thin', color: { argb: 'FF000000' } },
      right: { style: 'thin', color: { argb: 'FF000000' } },
    };
  });

  // Data rows
  detailRows.forEach((r, i) => {
    const row = ws.addRow([
      i + 1,
      format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd'),
      formatApiTime12(r.LocaleMessageTime),
      r.EmployeeID ?? '',
      r.CardNumber ?? '',
      r.ObjectName1 ?? '',
      r.PersonnelType ?? '',
      (r.CompanyNameComputed || r.CompanyName) ?? '',
      r.PrimaryLocation ?? '',
      r.Door ?? '',
      partitionToDisplay[r.PartitionName2]?.city || r.PartitionName2 || ''
    ]);

    row.eachCell((cell) => {
      cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: false };
      cell.font = { name: 'Calibri', size: 11, color: { argb: 'FF000000' } };
      cell.border = {
        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
        right: { style: 'thin', color: { argb: 'FFCCCCCC' } },
      };
    });

    // Zebra stripe every other row
    if (i % 2 === 1) {
      row.eachCell(cell => {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
      });
    }
  });

  // Totals row (count)
  const totalCount = detailRows.length;
  const totalRow = ws.addRow(['', '', '', '', '', '', '', '', '', 'Total', totalCount]);
  totalRow.eachCell((cell, colNumber) => {
    cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = {
      top: { style: 'thin', color: { argb: 'FF000000' } },
      left: { style: 'thin', color: { argb: 'FF000000' } },
      bottom: { style: 'thin', color: { argb: 'FF000000' } },
      right: { style: 'thin', color: { argb: 'FF000000' } },
    };
    if (colNumber === 11) {
      cell.numFmt = '#,##0';
    }
  });

  // Autosize columns exactly to content (no padding)
  ws.columns.forEach(col => {
    let maxLen = col.header ? String(col.header).length : 1;
    col.eachCell({ includeEmpty: true }, c => {
      const v = c.value == null ? '' : String(c.value);
      maxLen = Math.max(maxLen, v.trim().length);
    });
    col.width = Math.min(Math.max(maxLen, 4), 40); // no +2 padding
  });

  // Freeze header area (title + spacer + header visible)
  ws.views = [{ state: 'frozen', ySplit: 3 }];

  // Save workbook
  const buf = await wb.xlsx.writeBuffer();
  saveAs(new Blob([buf]), `history_${format(pickedDate, 'yyyyMMdd')}.xlsx`);
};