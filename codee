// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    // Month start/end in Pune local zone
    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    // Today in Pune (string yyyy-LL-dd)
    const todayKolkataStr = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

    // All month dates as strings
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // If requested month is current month, only consider days up to today for attendance math.
    const isRequestedMonthCurrent =
      start.toFormat('yyyy-LL') === DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL');
    const consideredDates = isRequestedMonthCurrent
      ? allDates.filter(d => d <= todayKolkataStr)
      : allDates.slice(); // full month for past months

    // SQL boundaries (UTC)
    const startUtc = start.setZone('utc').toJSDate();
    const endUtc = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    // Fetch events and also pull Card/CHUID (CardNumber) to improve dedupe
    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door,
          sc.value AS CardNumber
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC BETWEEN @start AND @end
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    // Normalize to Pune local date
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Group events by local date
    const byDay = new Map();
    for (const evt of events) {
      if (!byDay.has(evt.Dateonly)) byDay.set(evt.Dateonly, []);
      byDay.get(evt.Dateonly).push(evt);
    }

    // Aggregates containers
    const dailySummaries = [];        // {date, total}
    const peakOccupancy = [];         // {date, peak}
    const visitCounter = new Map();   // key -> {count, employeeId, name, personnelType}
    const presenceByPerson = new Map(); // key -> {employeeId, name, personnelType, days: Set}

    // Stable dedupe key function (deterministic)
    const dedupeKey = (e) => {
      const guid = (e.PersonGUID || '').toString().trim();
      const emp  = (e.EmployeeID || '').toString().trim();
      const card = (e.CardNumber || '').toString().trim();
      const name = (e.ObjectName1 || '').toString().trim();
      if (guid) return `g:${guid}`;
      if (emp)  return `e:${emp}`;
      if (card) return `c:${card}`;
      if (name) return `n:${name.toLowerCase()}`;
      return `unknown`; // stable fallback
    };

    // Process each day (days that actually have events)
    for (const [date, dayEvents] of byDay.entries()) {
      // Unique daily headcount: dedupe per-person for that day using stable key
      const uniquePeople = new Set();
      for (const e of dayEvents) uniquePeople.add(dedupeKey(e));
      dailySummaries.push({ date, total: uniquePeople.size });

      // Peak occupancy simulation (+1 on InDirection, -1 on OutDirection). Null/unknown Direction ignored for counter.
      let currentCount = 0;
      let maxCount = 0;
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') currentCount++;
        else if (e.Direction === 'OutDirection') currentCount = Math.max(0, currentCount - 1);
        if (currentCount > maxCount) maxCount = currentCount;
      }
      peakOccupancy.push({ date, peak: maxCount });

      // Track visits & presence:
      // - visits: count only explicit InDirection swipes
      // - presence: ANY event for the person on that date counts as present (this fixes missed presences)
      const daySeen = new Set();
      for (const e of dayEvents) {
        const key = dedupeKey(e);

        // visits (raw InDirection)
        if (e.Direction === 'InDirection') {
          if (!visitCounter.has(key)) {
            visitCounter.set(key, {
              count: 0,
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType
            });
          }
          visitCounter.get(key).count++;
        }

        // presence: any event => mark present (avoid double counting via daySeen)
        if (!daySeen.has(key)) {
          daySeen.add(key);
          if (!presenceByPerson.has(key)) {
            presenceByPerson.set(key, {
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType,
              days: new Set()
            });
          }
          presenceByPerson.get(key).days.add(date);
        }
      }
    }

    // Compute avg daily headcount over consideredDates (up to today for current month, else entire month)
    const dailyTotalsByDate = Object.fromEntries(dailySummaries.map(d => [d.date, d.total]));
    const consideredTotals = consideredDates.map(d => dailyTotalsByDate[d] || 0);
    const avgDailyHeadcount = consideredTotals.length
      ? Math.round(consideredTotals.reduce((s, v) => s + v, 0) / consideredTotals.length)
      : 0;

    // Top 10 visitors by InDirection counts
    const top10Visitors = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({
        employeeId: v.employeeId,
        name: v.name,
        personnelType: v.personnelType,
        visits: v.count
      }));

    // Attendance sheet: for each person seen in month, produce a row across all days
    const attendanceSheet = Array.from(presenceByPerson.entries()).map(([key, p]) => {
      const row = {
        employeeId: p.employeeId,
        name: p.name,
        personnelType: p.personnelType
      };

      let presentCount = 0;

      for (const d of allDates) {
        const isFuture = (isRequestedMonthCurrent && d > todayKolkataStr);
        if (isFuture) {
          row[d] = null; // not applicable yet
          continue;
        }

        if (p.days.has(d)) {
          row[d] = 'P';
          presentCount++;
        } else {
          row[d] = 'A';
        }
      }

      const workingDaysToDate = consideredDates.length;
      const daysAbsent = Math.max(0, workingDaysToDate - presentCount);
      const attendancePercent = workingDaysToDate > 0
        ? ((presentCount / workingDaysToDate) * 100).toFixed(1) + '%'
        : '0.0%';

      row.daysPresent = presentCount;
      row.daysAbsent = daysAbsent;
      row.attendancePercent = attendancePercent;
      return row;
    });

    return res.json({
      month,
      today: todayKolkataStr,
      workingDaysConsidered: consideredDates.length,
      avgDailyHeadcount,
      peakOccupancy,
      top10Visitors,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
