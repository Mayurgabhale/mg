// Add after `partitionRows` useMemo
const companyRows = useMemo(() => {
  if (!data || !pickedDate) return [];
  const ds = format(pickedDate, 'yyyy-MM-dd');

  // filter details for the date and partition (reuse same filter logic)
  const filtered = (data.details || []).filter(r =>
    r.LocaleMessageTime?.slice(0, 10) === ds &&
    (
      !backendFilterKey ||
      r.PartitionNameFriendly === backendFilterKey ||
      apacForwardKey[r.PartitionNameFriendly] === backendFilterKey
    )
  );

  // group by country|city|company
  const map = {};
  filtered.forEach(r => {
    // find display mapping for partition (same approach as partitionRows)
    const fe = Object.entries(apacForwardKey).find(([, be]) =>
      be === r.PartitionNameFriendly || `${be} City` === r.PartitionNameFriendly
    )?.[0];
    const disp = fe
      ? apacPartitionDisplay[fe]
      : Object.values(apacPartitionDisplay).find(d => d.city === (r.PartitionNameFriendly || '').replace(' City','')) || {};

    const country = disp?.country || 'Unknown';
    const city = disp?.city || (r.PartitionNameFriendly || '').replace(' City','');
    const company = (r.CompanyName || 'Unknown').trim();

    const key = `${country}||${city}||${company}`;
    map[key] = (map[key] || 0) + 1;
  });

  return Object.entries(map).map(([k, count]) => {
    const [country, city, company] = k.split('||');
    return { country, city, company, count };
  }).sort((a, b) => b.count - a.count);
}, [data, pickedDate, backendFilterKey]);