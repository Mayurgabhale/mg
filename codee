// controllers/denversecurityrejection.js
const sql = require('mssql');
const { denver } = require('../config/siteConfig');

// SECURITY_OFFICERS — now includes W0022449 per your request
const SECURITY_OFFICERS = [
  'W0003901','W0019956','W0023386','W0025278','W0025490',
  'W0025492','W0025493','W0025639','W0026149','W0026151',
  'W0026208','W0026455','W0022449'
];

function normalizePartsArray(partsRaw) {
  if (!partsRaw || typeof partsRaw !== 'string') return [];
  return partsRaw
    .split(',')
    .map(p => p.trim())
    .filter(p => p.length > 0);
}

function getDefaultParts() {
  if (process.env.DEFAULT_PARTS && process.env.DEFAULT_PARTS.trim()) {
    return process.env.DEFAULT_PARTS.trim().split(',').map(s => s.trim()).filter(Boolean);
  }
  return ['US.CO.OBS.15','US.CO.OBS.14','US.CO.OBS.12','US.CO.OBS.06','US.CO.OBS.13','US.CO.OBS.01'];
}

exports.getDenverSecurityRejection = async (req, res) => {
  try {
    // parse parts param (or fall back)
    let partsArr = normalizePartsArray(req.query.parts);
    if (partsArr.length === 0) {
      partsArr = getDefaultParts();
      console.warn(`[denverSecurityRejection] parts not provided — using default: ${partsArr.join(',')}`);
    }
    if (partsArr.length === 0) {
      return res.status(400).json({ error: "Missing or invalid 'parts' query param. Example: ?parts=US.CO.OBS.15,US.CO.OBS.14" });
    }

    // get pool + request and bind part parameters
    const pool = await denver.poolPromise;
    const request = pool.request();
    const partPlaceholders = partsArr.map((p, i) => {
      const name = `part${i}`;
      request.input(name, sql.NVarChar, p);
      return `@${name}`;
    }).join(', ');

    // static security list (safe inline)
    const secValues = SECURITY_OFFICERS.map(id => `('${id.replace("'", "''")}')`).join(',\n');

    // SQL: CombinedQuery for last 7 days, SecurityLatest for latest per security card,
    // SecurityByFloor (STUFF FOR XML PATH for older SQL Server), and Rejections per floor.
    const sqlQuery = `
/* CombinedQuery: last 7 days for partitions provided */
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1 AS ObjectName1,
    t1.ObjectName2 AS Door,
    t1.PartitionName2 AS PartitionName2,
    COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
      sc.value
    ) AS CardNumber,
    t3.Name AS PersonnelType,
    t5_rej.value AS RejectionType,
    t1.MessageType
  FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
  LEFT JOIN [ACVSCore].[Access].[Personnel] t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, value
    FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
    WHERE Name IN ('Card','CHUID')
  ) AS sc ON t1.XmlGUID = sc.GUID
  LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAccepted','CardRejected')
    AND t1.PartitionName2 IN (${partPlaceholders})
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) >= DATEADD(DAY, -7, CONVERT(DATE, GETDATE()))
),

EventsWithCard AS (
  SELECT *, LTRIM(RTRIM(CardNumber)) AS CardNumTrim
  FROM CombinedQuery
  WHERE COALESCE(LTRIM(RTRIM(CardNumber)), '') <> ''
),

LatestPerCard AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY CardNumTrim ORDER BY LocaleMessageTime DESC) AS rn
  FROM EventsWithCard
),

SecurityList AS (
  SELECT s.ID AS CardNumber FROM (VALUES
    ${secValues}
  ) AS s(ID)
),

SecurityLatest AS (
  SELECT
    lp.CardNumTrim AS CardNumber,
    lp.PartitionName2,
    lp.LocaleMessageTime,
    'Floor ' + PARSENAME(lp.PartitionName2, 1) AS FloorLabel
  FROM LatestPerCard lp
  INNER JOIN SecurityList sec ON lp.CardNumTrim = sec.CardNumber
  WHERE lp.rn = 1 AND lp.PartitionName2 IS NOT NULL
),

/* aggregate security officers per floor — compatible with older SQL Server */
SecurityByFloor AS (
  SELECT
    ISNULL('Floor ' + PARSENAME(sl.PartitionName2,1), sl.PartitionName2) AS Floor,
    COUNT(DISTINCT sl.CardNumber) AS SecurityCount,
    STUFF((
      SELECT DISTINCT ',' + s2.CardNumber
      FROM SecurityLatest s2
      WHERE s2.PartitionName2 = sl.PartitionName2
      FOR XML PATH(''), TYPE
    ).value('.', 'NVARCHAR(MAX)'), 1, 1, '') AS SecurityIDs
  FROM SecurityLatest sl
  GROUP BY sl.PartitionName2
),

/* rejection counts per floor (last 7 days) */
Rejections AS (
  SELECT
    ISNULL('Floor ' + PARSENAME(c.PartitionName2,1), c.PartitionName2) AS Floor,
    COUNT(*) AS RejectionCount,
    STUFF((
      SELECT DISTINCT ',' + COALESCE(c2.CardNumber,'?')
      FROM CombinedQuery c2
      WHERE c2.PartitionName2 = c.PartitionName2
        AND c2.MessageType = 'CardRejected'
        AND COALESCE(LTRIM(RTRIM(c2.CardNumber)),'') <> ''
      FOR XML PATH(''), TYPE
    ).value('.', 'NVARCHAR(MAX)'), 1, 1, '') AS Cards
  FROM CombinedQuery c
  WHERE c.MessageType = 'CardRejected' AND COALESCE(LTRIM(RTRIM(c.CardNumber)),'') <> ''
  GROUP BY c.PartitionName2
)

SELECT
  (SELECT Floor, SecurityCount, SecurityIDs FROM SecurityByFloor FOR JSON PATH) AS securityJson,
  (SELECT Floor, RejectionCount, Cards FROM Rejections FOR JSON PATH) AS rejectionsJson;
`;

    console.log('[denverSecurityRejection] partitions:', partsArr.join(','));

    const result = await request.query(sqlQuery);

    const row = result.recordset && result.recordset[0];
    const securityByFloor = row && row.securityJson ? JSON.parse(row.securityJson) : [];
    const rejectionsByFloor = row && row.rejectionsJson ? JSON.parse(row.rejectionsJson) : [];

    // Build a keyed map for quick frontend merge
    const securityMap = {};
    securityByFloor.forEach(it => {
      const floorKey = it.Floor || it.floor || it.FloorLabel || 'Unknown Floor';
      securityMap[floorKey] = {
        count: it.SecurityCount || 0,
        ids: it.SecurityIDs ? String(it.SecurityIDs).split(',').filter(Boolean) : [],
        SecurityIDs: it.SecurityIDs,
        SecurityCount: it.SecurityCount,
        Floor: floorKey
      };
    });
    rejectionsByFloor.forEach(it => {
      const floorKey = it.Floor || it.floor || 'Unknown Floor';
      if (!securityMap[floorKey]) securityMap[floorKey] = {};
      securityMap[floorKey].RejectionCount = it.RejectionCount || 0;
      securityMap[floorKey].Cards = it.Cards ? String(it.Cards).split(',').filter(Boolean) : [];
    });

    return res.json({
      securityByFloor,
      rejectionsByFloor,
      securityMap,
      meta: {
        partsRequested: partsArr,
        securityOfficersCount: SECURITY_OFFICERS.length
      }
    });

  } catch (err) {
    console.error('denverSecurityRejection error:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
};
