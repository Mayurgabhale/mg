// --- helper: robust row -> Luxon DateTime (UTC) ---
function toRowDateTime(r) {
  if (!r || r.LocaleMessageTime == null) return null;
  const v = r.LocaleMessageTime;
  if (v instanceof Date) return DateTime.fromJSDate(v, { zone: 'utc' });
  if (typeof v === 'number') return DateTime.fromMillis(v, { zone: 'utc' });
  // try ISO / SQL fallback
  let dt = DateTime.fromISO(String(v), { zone: 'utc' });
  if (!dt.isValid) dt = DateTime.fromSQL(String(v), { zone: 'utc' });
  return dt.isValid ? dt : null;
}

// --- buildVisitedForDate: historical snapshot version (used by /occupancy-at?at=...) ---
function buildVisitedForDate(allEvents, atDate) {
  // requested IST calendar day & instant
  const requestedIstDay = DateTime.fromJSDate(atDate, { zone: 'utc' })
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');
  const atInstantUtc = DateTime.fromJSDate(atDate, { zone: 'utc' });

  // 1) keep only InDirection rows that are on the requested IST day AND <= requested instant
  const filtered = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection') return false;
    const rowDt = toRowDateTime(evt);
    if (!rowDt) return false;
    const rowIstDay = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    return rowIstDay === requestedIstDay && rowDt <= atInstantUtc;
  });

  // 2) dedupe using the same dedup key as buildOccupancy
  const dedup = new Map();
  for (const e of filtered) {
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || e.ObjectName1;
    const prev = dedup.get(key);
    // keep the latest swipe (compare instants robustly)
    if (!prev) {
      dedup.set(key, e);
    } else {
      const prevDt = toRowDateTime(prev);
      const curDt  = toRowDateTime(e);
      if (!prevDt || !curDt) {
        // fallback: replace if current has LocaleMessageTime and prev doesn't
        if (curDt && !prevDt) dedup.set(key, e);
      } else if (curDt > prevDt) {
        dedup.set(key, e);
      }
    }
  }

  const finalList = Array.from(dedup.values());

  // 3) classify employees vs contractors (same rule as elsewhere)
  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}

// --- buildVisitedToday: live SSE helper (uses same logic but compares to "now" in IST) ---
function buildVisitedToday(allEvents) {
  // "today" in Asia/Kolkata
  const todayIst = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
  const nowUtc = DateTime.now().toUTC();

  // Filter InDirection rows that are on today's IST calendar day and <= now
  const filtered = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection') return false;
    const rowDt = toRowDateTime(evt);
    if (!rowDt) return false;
    const rowIstDay = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    return rowIstDay === todayIst && rowDt <= nowUtc;
  });

  // Deduplicate same as above
  const dedup = new Map();
  for (const e of filtered) {
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || e.ObjectName1;
    const prev = dedup.get(key);
    if (!prev) {
      dedup.set(key, e);
    } else {
      const prevDt = toRowDateTime(prev);
      const curDt  = toRowDateTime(e);
      if (!prevDt || !curDt) {
        if (curDt && !prevDt) dedup.set(key, e);
      } else if (curDt > prevDt) {
        dedup.set(key, e);
      }
    }
  }

  const finalList = Array.from(dedup.values());

  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management'].includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}