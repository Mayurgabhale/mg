// wherever you register routes
const live = require('./controllers/liveOccupancyController');
app.get('/api/occupancy-at', live.getOccupancyAtTime);


// near top (you already import DateTime)
const { DateTime } = require('luxon');
const { sql, getPool } = require('../config/db');
// reuse map helpers, buildOccupancy, etc (assumed present)

// Fetch *all* events for a given yyyy-LL-dd (Asia/Kolkata) date.
// Returns same shape recordset as fetchNewEvents (includes LocaleMessageTime).
async function fetchEventsForDate(dateString) {
  const pool = await getPool();
  const req  = pool.request();
  req.input('dateOnly', sql.VarChar(10), dateString);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND CONVERT(VARCHAR(10), DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC), 23) = @dateOnly
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}




.....
....



// GET /api/occupancy-at?ts=<ISO timestamp>
// Example ts value: 2025-09-12T07:43:00+05:30  OR browser datetime-local converted to ISO
exports.getOccupancyAtTime = async (req, res) => {
  try {
    const ts = req.query.ts;
    if (!ts) {
      return res.status(400).json({ error: "Missing `ts` query param. Provide ISO timestamp (e.g. 2025-09-12T07:43:00+05:30) or send browser datetime converted to ISO." });
    }

    // Parse requested instant, represent it in Asia/Kolkata
    const requested = DateTime.fromISO(ts, { setZone: true });
    if (!requested.isValid) {
      return res.status(400).json({ error: "Invalid ISO timestamp in `ts`." });
    }
    // requestedLocal is same instant in Asia/Kolkata wall clock
    const requestedLocal = requested.setZone('Asia/Kolkata');

    // date string for DB lookup (yyyy-MM-dd)
    const dateOnly = requestedLocal.toFormat('yyyy-LL-dd');

    // fetch all events for that day, then filter by time <= requestedLocal
    const allEvents = await fetchEventsForDate(dateOnly);

    // filter events whose LocaleMessageTime (which was produced by DATEADD(...) in SQL)
    // is <= requestedLocal; convert each LocaleMessageTime (JS Date) to Asia/Kolkata for safe comparison
    const filtered = allEvents.filter(evt => {
      // evt.LocaleMessageTime is a JS Date (driver returns Date). Treat as UTC instant then view in Asia/Kolkata
      const evtLocal = DateTime.fromJSDate(evt.LocaleMessageTime, { zone: 'utc' }).setZone('Asia/Kolkata');
      return evtLocal <= requestedLocal;
    });

    // Now compute occupancy from filtered events (your existing function)
    const snapshot = await buildOccupancy(filtered);

    // include the requested time back to client for clarity
    return res.json({
      requestedAt: requestedLocal.toISO(),
      dateOnly,
      snapshot
    });

  } catch (err) {
    console.error('Error in occupancy-at:', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
};