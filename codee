/** ---------- helper: filter server payload to only include items whose UTC date matches requested date ---------- */

/**
 * Return YYYY-MM-DD for a Date (UTC).
 */
function toUTCDateString(dateObj) {
  const y = dateObj.getUTCFullYear();
  const m = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
  const d = String(dateObj.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

/**
 * Try to parse a value as a Date and return its UTC YYYY-MM-DD, or null if cannot parse.
 * Accepts typical ISO strings or timestamps.
 */
function parseValueToUTCDateString(v) {
  if (!v) return null;
  // Only process primitives
  if (typeof v === 'string' || typeof v === 'number') {
    const n = typeof v === 'number' ? v : Date.parse(v);
    if (!Number.isNaN(n)) {
      try {
        return toUTCDateString(new Date(n));
      } catch (e) { /* fallthrough */ }
    }
  }
  return null;
}

/**
 * Recursively check an object/array for any string/number value that parses to targetDate (UTC YYYY-MM-DD).
 * Returns true if any property matches the targetDate.
 */
function objectContainsUTCDate(obj, targetDate) {
  if (obj == null) return false;
  if (Array.isArray(obj)) {
    for (const it of obj) {
      if (objectContainsUTCDate(it, targetDate)) return true;
    }
    return false;
  }
  if (typeof obj === 'object') {
    for (const key of Object.keys(obj)) {
      const val = obj[key];
      // quick common-case checks
      if (val == null) continue;
      if (typeof val === 'string' || typeof val === 'number') {
        const ds = parseValueToUTCDateString(val);
        if (ds === targetDate) return true;
      }
      // recurse
      if (typeof val === 'object' && objectContainsUTCDate(val, targetDate)) return true;
    }
    return false;
  }
  // primitives already handled; no match otherwise
  return false;
}

/**
 * Filter an array of items (likely objects) keeping only those that contain a date matching targetDate.
 * If the array items are primitive strings that parse to dates, those are checked too.
 */
function filterArrayByUTCDate(arr, targetDate) {
  if (!Array.isArray(arr)) return arr;
  return arr.filter(item => {
    // if primitive that parse as date
    if (typeof item === 'string' || typeof item === 'number') {
      const ds = parseValueToUTCDateString(item);
      return ds === targetDate;
    }
    // object -> recursively search for any date-like field that matches
    return objectContainsUTCDate(item, targetDate);
  });
}

/**
 * Given the server payload `p` and an ISO timestamp string `isoRequested` (like "2025-09-11T00:00:00.000Z"),
 * produce a filtered copy of `p` where:
 *  - p.summary (if array) is filtered to items containing the requested UTC date
 *  - p.details (if object mapping -> arrays) has each array filtered by date
 *  - totalVisitedToday and visitedToday.total are recomputed from filtered details (sum of lengths)
 *
 * NOTE: We do NOT change other server-provided fields (floorBreakdown, zoneBreakdown, personnelBreakdown, ertStatus)
 * except where explicitly recomputed above (totalVisitedToday / visitedToday.total), to keep logic consistent.
 */
function filterPayloadByDate(p, isoRequested) {
  if (!p || !isoRequested) return p;
  // Extract target YYYY-MM-DD (UTC) from requested ISO
  const targetDate = isoRequested.slice(0, 10); // "YYYY-MM-DD"

  const newP = { ...p };

  // Filter summary if array
  if (Array.isArray(p.summary)) {
    newP.summary = filterArrayByUTCDate(p.summary, targetDate);
  }

  // Filter details: object with zone -> array
  if (p.details && typeof p.details === 'object' && !Array.isArray(p.details)) {
    const newDetails = {};
    for (const key of Object.keys(p.details)) {
      const arr = p.details[key];
      if (Array.isArray(arr)) {
        newDetails[key] = filterArrayByUTCDate(arr, targetDate);
      } else {
        // preserve if unexpected shape
        newDetails[key] = arr;
      }
    }
    newP.details = newDetails;
  }

  // recompute totalVisitedToday as sum of lengths in details (fallback: use filtered summary length)
  let recomputedTotal = 0;
  if (newP.details && typeof newP.details === 'object') {
    for (const k of Object.keys(newP.details)) {
      const arr = newP.details[k];
      if (Array.isArray(arr)) recomputedTotal += arr.length;
    }
  }
  if (recomputedTotal === 0 && Array.isArray(newP.summary)) {
    recomputedTotal = newP.summary.length;
  }

  newP.totalVisitedToday = recomputedTotal;
  newP.visitedToday = { ...(p.visitedToday || {}), total: recomputedTotal };

  return newP;
}




....



// Fetch a historical snapshot
  async function fetchSnapshot(isoTimestamp) {
    setTimeTravelLoading(true);
    const url = `${API_ORIGIN}/api/occupancy-at?at=${encodeURIComponent(isoTimestamp)}`;
    console.debug('[TimeTravel] fetching', url);
    try {
      const resp = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
      if (!resp.ok) {
        // give a better message for 404 vs other errors and include body if present
        const body = await resp.text().catch(() => '');
        console.error(`[TimeTravel] error ${resp.status} from ${url}`, body);
        if (resp.status === 404) {
          window.alert(`Snapshot not found for ${isoTimestamp} (404). Check server logs or the 'at' parameter.`);
        } else {
          window.alert(`Failed to load snapshot: server returned ${resp.status}. See console for details.`);
        }
        throw new Error(`Server returned ${resp.status}`);
      }

      const p = await resp.json();

      // --- NEW: filter payload so only items whose UTC date matches the requested date are kept ---
      // The UI's datetime-local input is treated literally as UTC (your existing behavior).
      // If the user selected "2025-09-11T00:00" we want only items from 2025-09-11 (UTC).
      const filtered = filterPayloadByDate(p, isoTimestamp);

      // Apply filtered payload
      setPayload(filtered);
      setTimeTravelMode(true);
      // prefer server-provided timestamp (p.asOf) if backend returns it; fallback to requested isoTimestamp
      setTimeTravelTimestamp(p?.asOf || isoTimestamp);

    } catch (err) {
      console.error('Failed to fetch snapshot', err);
      // (UI already alerted above for non-2xx)
      if (!err.message.includes('Server returned')) {
        window.alert('Failed to load snapshot. See console for details.');
      }
    } finally {
      setTimeTravelLoading(false);
    }
  }