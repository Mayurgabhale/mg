/**
 * GET /occupancy-at?date=YYYY-MM-DD&time=HH:mm:ss
 *
 * Example:
 *   /occupancy-at?date=2025-09-16&time=03:00:00
 *
 * Optional:
 *   &hours=N   (how many hours of history to fetch before target, default 168)
 */
exports.getOccupancyAt = async (req, res) => {
  try {
    await getPool(); // ensure DB pool ready

    const { date, time, hours } = req.query;
    if (!date || !time) {
      return res.status(400).json({
        error: 'Please provide both `date` (YYYY-MM-DD) and `time` (HH:mm:ss)',
      });
    }

    // Parse target datetime in Asia/Kolkata
    let targetDT = DateTime.fromFormat(
      `${date} ${time}`,
      'yyyy-LL-dd HH:mm:ss',
      { zone: 'Asia/Kolkata' }
    );

    // fallback if only HH:mm was given
    if (!targetDT.isValid) {
      targetDT = DateTime.fromFormat(
        `${date} ${time}`,
        'yyyy-LL-dd HH:mm',
        { zone: 'Asia/Kolkata' }
      );
    }

    if (!targetDT.isValid) {
      return res.status(400).json({
        error: 'Invalid date or time format. Example: date=2025-09-16&time=03:00:00',
      });
    }

    // ✅ Block future queries (compare in Asia/Kolkata)
    const nowLocal = DateTime.now().setZone('Asia/Kolkata');
    if (targetDT > nowLocal) {
      return res.status(400).json({
        error: 'Please select a relevant time — cannot be in the future',
      });
    }

    const lookbackHours = Number.isFinite(Number(hours))
      ? Math.max(1, parseInt(hours, 10))
      : 168; // default 7 days

    const sinceDT = targetDT.minus({ hours: lookbackHours }).toUTC();
    const sinceJS = sinceDT.toJSDate();

    // fetch events newer than sinceJS
    const rawEvents = await fetchNewEvents(sinceJS);

    const targetUTCjs = targetDT.toUTC().toJSDate();

    // ✅ Filter: same date (Asia/Kolkata) AND time <= target
    const eventsUpToTarget = rawEvents.filter(evt => {
      // evt.LocaleMessageTime is DB Date in UTC; convert to Asia/Kolkata for date comparison
      const evtLocal = DateTime.fromJSDate(evt.LocaleMessageTime, { zone: 'Asia/Kolkata' });
      return (
        evtLocal.toFormat('yyyy-LL-dd') === date &&   // only same local date
        evt.LocaleMessageTime <= targetUTCjs           // not after requested time
      );
    });

    // build occupancy as of that time (reuses your existing builder)
    const occupancy = await buildOccupancy(eventsUpToTarget);

    // Use local IST in output so it matches input (no UTC confusion)
    occupancy.asOf = targetDT.toISO(); // local ISO with +05:30
    occupancy.requestedAsOfLocal = targetDT.toISO();
    occupancy.requestedAsOfHuman = targetDT.toFormat('yyyy-LL-dd HH:mm:ss');
    occupancy._meta = {
      historyHoursUsed: lookbackHours,
      eventsConsidered: eventsUpToTarget.length,
    };

    return res.json(occupancy);
  } catch (err) {
    console.error('Error in getOccupancyAt:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};
