// --- company name normalizer ---
// keep it deterministic and conservative (only maps the families you listed)
const normalizeCompany = (raw) => {
  if (!raw) return 'Unknown';
  // trim and collapse whitespace
  const orig = String(raw).trim();
  const s = orig
    .toLowerCase()
    // remove punctuation commonly causing variants
    .replace(/[.,()\/\-]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  // Poona / Poona Security family
  if (/\bpoona\b/.test(s) || /\bpoona security\b/.test(s) || /\bpoona security india\b/.test(s)) {
    return 'Poona Security India Pvt Ltd';
  }

  // Western Union family (map many variants to single canonical)
  if (
    /\bwestern union\b/.test(s) ||
    /\bwesternunion\b/.test(s) ||
    /\bwu\b/.test(s) ||           // WU standalone
    /\bwufs\b/.test(s) ||         // WUFS variants
    /\bwu technology\b/.test(s) ||
    /\bwu srvcs\b/.test(s) ||
    /\bwestern union svs\b/.test(s) ||
    /\bwestern union processing\b/.test(s) ||
    /\bwestern union japan\b/.test(s) ||
    /\bwestern union, llc\b/.test(s)
  ) {
    return 'Western Union';
  }

  // Vedant family
  if (/\bvedant\b/.test(s)) {
    return 'Vedant Enterprises Pvt. Ltd';
  }

  // Osource family
  if (/\bosource\b/.test(s)) {
    return 'Osource India Pvt Ltd';
  }

  // CBRE family
  if (/\bcbre\b/.test(s)) {
    return 'CBRE';
  }

  // explicit Unknown canonical
  if (s === 'unknown' || s === '') return 'Unknown';

  // otherwise return the original trimmed string (preserve casing)
  return orig;
};






....







// companyRows: aggregated by normalized CompanyName for pickedDate (respects backendFilterKey)
const companyRows = useMemo(() => {
  if (!data || !pickedDate) return [];

  const ds = format(pickedDate, 'yyyy-MM-dd');

  // filter details for the date + optional partition filter
  const filtered = data.details.filter(r =>
    r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10) === ds &&
    (
      !backendFilterKey ||
      r.PartitionNameFriendly === backendFilterKey ||
      apacForwardKey[r.PartitionNameFriendly] === backendFilterKey
    )
  );

  // aggregate into map: key = country||city||normalizedCompany
  const map = new Map();

  filtered.forEach(r => {
    const city = formatPartition(r.PartitionNameFriendly || '');
    const disp = Object.values(apacPartitionDisplay).find(d => d.city === city);
    const country = disp?.country || 'Unknown';

    const rawCompany = r.CompanyName || 'Unknown';
    const company = normalizeCompany(rawCompany);

    const key = `${country}||${city}||${company}`;
    const existing = map.get(key);
    if (existing) {
      existing.total += 1; // counting rows as "total" (same behaviour as before)
    } else {
      map.set(key, { country, city, company, total: 1 });
    }
  });

  // return sorted list (optional: by country, city, company)
  return Array.from(map.values()).sort((a, b) => {
    if (a.country !== b.country) return a.country.localeCompare(b.country);
    if (a.city !== b.city) return a.city.localeCompare(b.city);
    return a.company.localeCompare(b.company);
  });
}, [data, pickedDate, backendFilterKey]);