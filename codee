exports.getSnapshotAt = async (req, res) => {
  try {
    const atRaw = req.query.at;
    if (!atRaw) return res.status(400).json({ error: 'missing "at" query parameter (ISO timestamp required)' });

    // optional: clients can pass ?tz=Asia/Kolkata (default)
    const tz = req.query.tz || 'Asia/Kolkata';

    // detect if incoming string includes an explicit offset (Z or +HH or -HH:mm)
    const hasExplicitOffset = /(?:Z|[+\-]\d{2}(:\d{2})?)$/.test(atRaw);

    let dt;
    if (hasExplicitOffset) {
      // parse absolute instant (uses provided offset) then convert to requested tz
      dt = DateTime.fromISO(atRaw, { setZone: true }).setZone(tz);
    } else {
      // parse naive wall-clock time as if it's in the requested tz
      dt = DateTime.fromISO(atRaw, { zone: tz, setZone: true });
    }

    if (!dt.isValid) {
      return res.status(400).json({ error: 'invalid "at" timestamp' });
    }

    // Convert to a JS Date representing the exact UTC instant to give to SQL
    const atDateUtc = dt.toUTC().toJSDate();

    console.log(
      '[getSnapshotAt] atRaw:',
      atRaw,
      'parsedZone:',
      tz,
      'local (tz) ISO:',
      dt.toISO(),
      'atDate (UTC ISO for SQL):',
      atDateUtc.toISOString()
    );

    // fetch events in the 24h window ending at atDateUtc
    const events = await fetchEventsWindow(atDateUtc);

    const occupancy = await buildOccupancy(events);
    const visitedStats = buildVisitedForDate(events, atDateUtc);

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = {
      employees: visitedStats.employees,
      contractors: visitedStats.contractors,
      total: visitedStats.total
    };

    // Provide both UTC instant AND the local tz representation so it's unambiguous
    occupancy.asOfUtc   = atDateUtc.toISOString();                 // exact instant used for SQL
    occupancy.asOfLocal = dt.toISO();                              // local wall-clock in requested tz

    return res.json(occupancy);
  } catch (err) {
    console.error('getSnapshotAt error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};




...

..



...
function buildVisitedForDate(allEvents, atDate) {
  // asOfLocalDate is the local calendar date in Asia/Kolkata for the provided instant
  const asOfLocalDate = DateTime.fromJSDate(atDate, { zone: 'utc' })
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  // Keep only IN swipes for that local date,
  // but allow ANY time from 00:00 until atDate (inclusive).
  const todayIns = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection') return false;
    if (evt.Dateonly !== asOfLocalDate) return false;

    // Ensure LocaleMessageTime is compared as a Date object
    const evtTs = evt.LocaleMessageTime ? new Date(evt.LocaleMessageTime) : null;
    if (!evtTs || Number.isNaN(evtTs.getTime())) return false;

    // atDate is the UTC JS Date we passed in (absolute instant)
    return evtTs.getTime() <= atDate.getTime();
  });

  // Dedupe by composite key â†’ latest swipe wins (same key used elsewhere)
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || e.ObjectName1;
    if (!key) continue;
    const evtTs = e.LocaleMessageTime ? new Date(e.LocaleMessageTime).getTime() : 0;
    const prev = dedup.get(key);
    if (!prev || evtTs > new Date(prev.LocaleMessageTime).getTime()) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}