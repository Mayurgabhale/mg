

// src/components/FloorOccupancyChart.jsx
import React, { useMemo } from 'react';
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  Cell,
  LabelList,
  Legend,
  Customized
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaUsers } from 'react-icons/fa';
import './FloorOccupancyChart.css';
import floorCapacities from '../constants/floorCapacities';

/* Design palettes */
const CYLINDER_PALETTES = [
  ['#CFEFFF', '#4DB8FF'],
  ['#DDEBFF', '#2F80ED'],
  ['#FFDEE1', '#E74C7C'],
  ['#FFF1D6', '#FF9A3D'],
  ['#E6FCD7', '#46C853']
];

export default function FloorOccupancyChart({ data = [] }) {
  // ---- call hooks unconditionally ----
  // enriched will be an empty array when there's no data
  const enriched = useMemo(() => {
    if (!data || !data.length) return [];
    return data.map(item => {
      const floor = item.floor;
      const liveCount = Number(item.total || item.liveCount || 0);
      const capacity = Number(floorCapacities[floor] ?? 0);
      const usedPct = capacity > 0 ? Number(((liveCount / capacity) * 100).toFixed(1)) : 0;
      return {
        ...item,
        floor,
        liveCount,
        capacity,
        usedPct,
        label: `${liveCount}/${capacity}`
      };
    });
  }, [data]);

  // early return (after hook calls) if no enriched data
  if (!enriched.length) {
    return (
      <Card body className="bg-dark text-white no-data-card">
        No floor data available
      </Card>
    );
  }

  // compute totals and sorted data
  const totalLive = enriched.reduce((s, f) => s + f.liveCount, 0);
  const totalCap = enriched.reduce((s, f) => s + f.capacity, 0);
  const totalPct = totalCap > 0 ? Number(((totalLive / totalCap) * 100).toFixed(1)) : 0;

  const sorted = [...enriched].sort((a, b) => b.liveCount - a.liveCount);
  const chartData = [{ floor: 'Pune Office Total', liveCount: totalLive, capacity: totalCap, usedPct: totalPct, label: `${totalLive}/${totalCap}` }, ...sorted];

  // axis max — scale using max live count for nicer visuals
  const maxLive = Math.max(...chartData.map(d => d.liveCount), ...chartData.map(d => d.capacity)) || 10;
  const yMax = Math.ceil(maxLive * 1.15 / 25) * 10;

  // Tooltip content
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload?.length) return null;
    const d = payload[0].payload;
    const entries = Object.entries(d)
      .filter(([k]) => !['floor', 'liveCount', 'capacity', 'usedPct', 'label'].includes(k));
    return (
      <div className="fo-tooltip">
        <div className="fo-tooltip-title">{d.floor}</div>
        <div className="fo-tooltip-main">{d.liveCount} / {d.capacity} &nbsp; <span className="fo-tooltip-pct">({d.usedPct}%)</span></div>
        <div className="fo-tooltip-breakdown">
          {entries.map(([k, v]) => (
            <div key={k} className="fo-row">
              <span className="fo-key">{k.charAt(0).toUpperCase() + k.slice(1)}</span>
              <span className="fo-val">{v}</span>
            </div>
          ))}
        </div>
      </div>
    );
  };

  /*
    Cylinder shape: tall rectangle with top ellipse (3D feel), a subtle gloss,
    a little capacity label centered inside, and a small percent badge above.
  */
  const CylinderShape = (props) => {
    const { x, y, width, height, payload } = props;
    const idx = chartData.findIndex(c => c.floor === payload.floor);
    const [c1, c2] = CYLINDER_PALETTES[idx % CYLINDER_PALETTES.length];

    const cx = x + width / 2;
    const topRy = Math.max(6, width * 0.12);
    const bottomRy = Math.max(10, width * 0.14);
    const bottomY = y + height;

    const gradId = `cgrad-${idx}`;

    return (
      <g>
        {/* defs placed here for unique gradient per cylinder */}
        <defs>
          <linearGradient id={gradId} x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stopColor={c1} stopOpacity="1" />
            <stop offset="100%" stopColor={c2} stopOpacity="1" />
          </linearGradient>
          <linearGradient id={`gloss-${idx}`} x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stopColor="rgba(255,255,255,0.45)" />
            <stop offset="35%" stopColor="rgba(255,255,255,0.08)" />
            <stop offset="100%" stopColor="rgba(255,255,255,0.02)" />
          </linearGradient>
        </defs>

        {/* soft shadow under cylinder */}
        <ellipse cx={cx} cy={bottomY + bottomRy * 0.9} rx={width * 0.6} ry={bottomRy * 0.45} fill="rgba(0,0,0,0.22)" />

        {/* main body */}
        <rect x={x} y={y} width={width} height={height} rx={12} ry={12} fill={`url(#${gradId})`} stroke="rgba(255,255,255,0.06)" strokeWidth={1} />

        {/* top oval (gives roundness) */}
        <ellipse cx={cx} cy={y + topRy * 0.24} rx={width / 2} ry={topRy * 0.9} fill={`url(#${gradId})`} opacity={0.92} />

        {/* gloss overlay */}
        <rect x={x} y={y} width={width} height={height * 0.45} rx={12} ry={12} fill={`url(#gloss-${idx})`} opacity={0.65} />

        {/* bottom ellipse */}
        <ellipse cx={cx} cy={bottomY} rx={width / 2} ry={bottomRy} fill="rgba(255,255,255,0.03)" />

        {/* centered label (live/cap) */}
        <text x={cx} y={y + height / 2 + 6} textAnchor="middle" fontSize={Math.max(12, Math.round(width * 0.16))} fontWeight="700" fill="#0c1220">
          {payload.label}
        </text>

        {/* percent badge above the cylinder */}
        <g transform={`translate(${cx}, ${y - 12})`}>
          <rect x={-28} y={-18} width={56} height={26} rx={14} fill="#111827" opacity={0.9} stroke="rgba(255,255,255,0.06)" />
          <text x="0" y={-2} textAnchor="middle" fontSize={11} fontWeight="700" fill="#FFD100">
            {payload.usedPct}% used
          </text>
        </g>
        
      </g>
    );
  };

  // Curve overlay: draws smooth path through top-centers using provided scales (recharts Customized props)
  const CurveOverlay = (props) => {
    const { xAxisMap, yAxisMap } = props;
    if (!xAxisMap || !yAxisMap) return null;
    const xKey = Object.keys(xAxisMap)[0];
    const yKey = Object.keys(yAxisMap)[0];
    const xScale = xAxisMap[xKey].scale;
    const yScale = yAxisMap[yKey].scale;
    if (!xScale || !yScale) return null;

    const points = chartData.map(d => {
      // center of the bar's category
      const x = xScale(d.floor) + (xScale.bandwidth ? xScale.bandwidth() / 2 : 0);
      const y = yScale(d.liveCount);
      return { x, y };
    });
    if (points.length < 2) return null;

    // create smooth cubic path (simple approach)
    let path = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const p0 = points[i - 1];
      const p1 = points[i];
      const midX = (p0.x + p1.x) / 2;
      path += ` Q ${p0.x} ${p0.y} ${midX} ${(p0.y + p1.y) / 2}`;
    }
    const last = points[points.length - 1];
    path += ` T ${last.x} ${last.y}`;

    return (
      <g>
        <path d={path} fill="none" stroke="rgba(255,255,255,0.14)" strokeWidth={4} strokeDasharray="8 8" />
        <path d={path} fill="none" stroke="#FFD100" strokeWidth={3} strokeLinecap="round" strokeOpacity={0.9} />
      </g>
    );
  };

  return (
    <Card className="fo-card">
      <Card.Header className="fo-header">
        <div className="fo-title">
          <FaUsers /> &nbsp; Western Union — Pune Headcount vs Occupancy
        </div>

        <div className="fo-kpis">
          <div className="kpi">
            <div className="kpi-label">Total Live</div>
            <div className="kpi-value">{totalLive.toLocaleString()}</div>
            <div className="kpi-sub">of {totalCap.toLocaleString()} capacity</div>
          </div>
          <div className="kpi">
            <div className="kpi-label">Utilization</div>
            <div className="kpi-value">{totalPct}%</div>
            <div className="kpi-sub">office average</div>
          </div>
        </div>
      </Card.Header>

      <Card.Body className="fo-body" >
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            margin={{ top: 1, right: 24, left: 24, bottom: 0 }}
            barCategoryGap="18%"
          >
            <XAxis dataKey="floor" tick={{ fill: '#E6E6E6', fontSize: 12 }} tickLine={false} axisLine={false} interval={0} height={50} />
            <YAxis tick={{ fill: '#E6E6E6', fontSize: 12 }} axisLine={false} tickLine={false} domain={[0, yMax]} />
            <Tooltip content={renderTooltip} />
            <Legend verticalAlign="top" align="right" wrapperStyle={{ color: '#fff', paddingRight: 12 }} payload={[{ value: 'Live Headcount', type: 'square', color: CYLINDER_PALETTES[0][1] }]} />

            <Bar dataKey="liveCount" barSize={120} animationDuration={900} shape={<CylinderShape />}>
              {chartData.map((entry, idx) => (
                <Cell key={`cell-${idx}`} fill={`url(#cgrad-${idx})`} />
              ))}
              <LabelList dataKey="liveCount" position="top" formatter={(v) => v} style={{ fill: '#fff', fontWeight: 800 }} />
            </Bar>

            <Customized component={(props) => <CurveOverlay {...props} />} />
          </BarChart>
        </ResponsiveContainer>
      </Card.Body>
    </Card>
  );
}
