http://localhost:5000/api/rejections
Server Error
Server running at http://localhost:5000
✅ MSSQL pool connected
✅ Denver MSSQL pool connected
Error fetching rejection data: ReferenceError: parts is not defined
    at getRejections (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js:41:42)
Error fetching rejection data: ReferenceError: parts is not defined
    at getRejections (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js:41:42)
Error fetching rejection data: ReferenceError: parts is not defined
    at getRejections (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js:41:42)


C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\config\siteConfig.js





// config/siteConfig.js
const { sql, getPool } = require('./db');

// Pune uses the shared getPool():
const punePoolPromise = getPool();

// Denver pool configuration
const denverConfig = {
  user:     'GSOC_Test',
  password: 'Westernccure@2025',
  server:   'SRVWUDEN0891V',
  database: 'ACVSUJournal_00010028',
  options: {
    encrypt:               true,
    trustServerCertificate: true
  },
  pool: {
    max:                  5,
    min:                  0,

    // Make these extremely large so that Tarn will never time us out
    idleTimeoutMillis:    2147483647,
    acquireTimeoutMillis: 2147483647
  },
  connectionTimeout: 30000,  // 30 seconds to establish
  requestTimeout:    0       // no timeout on individual queries
};

let denverPoolPromise = null;

async function getDenverPool(attempts = 3) {
  // If a pool promise is already in-flight (or resolved), return it.
  if (denverPoolPromise) {
    return denverPoolPromise;
  }

  denverPoolPromise = (async () => {
    const pool = new sql.ConnectionPool(denverConfig);

    // If this pool ever errors, reset the promise so that
    // next time we can try to re-connect.
    pool.on('error', err => {
      console.error('❌ Denver MSSQL pool error:', err);
      denverPoolPromise = null;
    });

    try {
      await pool.connect();
      console.log('✅ Denver MSSQL pool connected');
      return pool;
    } catch (err) {
      console.error('❌ Denver pool connection failed:', err);
      denverPoolPromise = null;

      if (attempts > 0) {
        console.log(`⏳ Retrying Denver pool connect (${attempts} left)…`);
        await new Promise(res => setTimeout(res, 3000));
        return getDenverPool(attempts - 1);
      }

      // If all retries fail, re­throw so that calling code can catch it.
      throw err;
    }
  })().catch(err => {
    // Catch any unhandled rejection here so it never propagates
    // out of the immediate getDenverPool() call.
    console.error('❌ Denver pool promise ultimately failed:', err);
    denverPoolPromise = null;
    return null;
  });

  return denverPoolPromise;
}

// Every 5 minutes, ping Denver so it never goes idle.
// If ping fails, reset the poolPromise (so next request will re-connect).
setInterval(async () => {
  try {
    const pool = await getDenverPool();
    if (pool) {
      await pool.request().query('SELECT 1');
      // console.log('🔄 Denver keep-alive succeeded');
    }
  } catch (err) {
    console.error('⚠️ Denver keep-alive failed, resetting poolPromise:', err);
    denverPoolPromise = null;
  }
}, 5 * 60 * 1000);

module.exports = {
  pune: {
    name:        'Pune',
    poolPromise: punePoolPromise,
    sql
  },
  denver: {
    name:        'Denver',
    poolPromise: getDenverPool(),
    sql
  }
};



// controllers/denverRejection.js
const sql = require("mssql");
const dbConfig = require("../config/siteConfig"); // ✅ fixed path
// employee-ai-insights\config\siteConfig.js
async function getRejections(req, res) {
  try {
    let pool = await sql.connect(dbConfig);

    const query = `
      WITH CombinedQuery AS (
        SELECT
          DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
          t1.ObjectName1      AS ObjectName1,
          t1.ObjectName2      AS Door,
          t1.PartitionName2   AS PartitionName2,
          COALESCE(
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
            sc.value
          )                    AS CardNumber,
          t3.Name              AS PersonnelType,
          t5_rej.value         AS RejectionType
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
        LEFT JOIN [ACVSCore].[Access].[Personnel] AS t2
          ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
          ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] AS t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) AS sc
          ON t1.XmlGUID = sc.GUID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] AS t5_rej
          ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
        WHERE
          t1.MessageType = 'CardRejected'
          -- Optional filter by floors/partitions:
          -- AND t1.PartitionName2 IN (${parts})
          AND CONVERT(DATE,
               DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)
              ) >= DATEADD(DAY, -7, CONVERT(DATE, GETDATE()))
      )
      SELECT
        PartitionName2 AS floor,
        COUNT(*) AS rejectionCount
      FROM CombinedQuery
      GROUP BY PartitionName2
      ORDER BY floor;
    `;

    const result = await pool.request().query(query);
    res.json(result.recordset);

  } catch (err) {
    console.error("Error fetching rejection data:", err);
    res.status(500).send("Server Error");
  }
}

module.exports = { getRejections };


// routes/occupancyDenverRoutes.js
const express = require('express');
const router = express.Router();

const { getDenverLiveOccupancy, getDenverSnapshotAtDateTime } = require('../controllers/denverLiveOccupancyController');
const { getDenverInOutInconsistency } = require('../controllers/denverInOutInconsistencyController');

const { getRejections } = require("../controllers/denverRejection");

// Denver live occupancy
router.get('/live-occupancy-denver', getDenverLiveOccupancy);

// Denver in/out inconsistency trends
router.get('/inout-inconsistency-denver', getDenverInOutInconsistency);

// Denver snapshot endpoint
router.get('/occupancy-at-time-denver', getDenverSnapshotAtDateTime);


router.get("/rejections", getRejections);


module.exports = router;






// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\server.js
// server.js
const express = require('express');
const cors    = require('cors');
const path    = require('path');


const employeeRoutes        = require('./routes/employeeRoutes');
const liveOccupancyRoutes   = require('./routes/liveOccupancyRoutes');
const occupancyDenverRoutes = require('./routes/occupancyDenverRoutes');

const app = express();
app.use(cors());
app.use(express.json());


// --- middleware to disable proxy buffering for SSE endpoints ---
const noBuffering = (req, res, next) => {
  // Nginx or other proxies honor this header to stream chunks immediately
  res.set('X-Accel-Buffering', 'no');
  next();
};


// simple sanity-check
app.get('/ping', (req, res) => res.send('pong'));




app.use('/api', employeeRoutes);

// Pune SSE (live occupancy)
app.use(
  '/api',
  noBuffering,
  liveOccupancyRoutes
);

// Denver SSE (live occupancy)

app.use(
  '/api',
  noBuffering,
  occupancyDenverRoutes
);



// debug: list registered endpoints
if (app._router && Array.isArray(app._router.stack)) {
  console.log('\n📋 Registered endpoints:');
  app._router.stack.forEach(layer => {
    if (layer.route && layer.route.path) {
      const methods = Object
        // .keys(layer.route.methods)
        // .map(m => m.toUpperCase())
        // .join(',');

        .keys(layer.route.methods)
        .map(m => m.toUpperCase())
        .join(',');

      console.log(`  ${methods}\t${layer.route.path}`);
    }
  });
}

// serve React build (if any)
const buildPath = path.join(__dirname, '..', 'client', 'build');
app.use(express.static(buildPath));

// health check
app.get('/health', (req, res) => res.send('OK'));

const PORT = process.env.PORT || 5001;
app.listen(PORT, () => console.log(`Server running at http://localhost:${PORT}`));





Server running at http://localhost:5000
✅ MSSQL pool connected
✅ Denver MSSQL pool connected
Error fetching rejection data: ReferenceError: parts is not defined
    at getRejections (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js:41:42)
Error fetching rejection data: ReferenceError: parts is not defined
    at getRejections (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js:41:42)
Error fetching rejection data: ReferenceError: parts is not defined
    at getRejections (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js:41:42)
