// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    // Month start/end in Pune local zone
    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    // Today in Pune (string yyyy-LL-dd)
    const todayKolkataStr = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

    // Build all dates in month
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // If requested month is current month, only consider days up to today for attendance math.
    const isRequestedMonthCurrent =
      start.toFormat('yyyy-LL') === DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL');

    const consideredDates = isRequestedMonthCurrent
      ? allDates.filter(d => d <= todayKolkataStr)
      : allDates.slice();

    // SQL boundaries (UTC)
    const startUtc = start.setZone('utc').toJSDate();
    const endUtc = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    // Fetch swipe events
    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door,
          sc.value AS CardNumber
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC BETWEEN @start AND @end
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    // Normalize to Pune local time and enrich
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Build canonical key function (stable)
    function canonicalKey(e) {
      const guid = (e.PersonGUID || '').toString().trim();
      const card = (e.CardNumber || '').toString().trim();
      const emp  = (e.EmployeeID || '').toString().trim();
      const name = (e.ObjectName1 || '').toString().trim().toLowerCase();
      if (guid) return `g:${guid}`;
      if (card) return `c:${card}`;
      if (emp && emp !== '0') return `e:${emp}`;
      if (name) return `n:${name}`;
      return `unknown`;
    }

    // Containers
    const visitCounter = new Map();     // key -> {count, employeeId, name, personnelType}
    const presenceByPerson = new Map(); // key -> { employeeId, name, personnelType, days:Set }

    // Scan all events once and populate presence & visits
    for (const e of events) {
      const date = e.Dateonly;
      const key = canonicalKey(e);

      if (!presenceByPerson.has(key)) {
        presenceByPerson.set(key, {
          employeeId: e.EmployeeID,
          name: e.ObjectName1,
          personnelType: e.PersonnelType,
          days: new Set()
        });
      }

      // Mark presence for this date
      presenceByPerson.get(key).days.add(date);

      // Count visits
      if (e.Direction === 'InDirection') {
        if (!visitCounter.has(key)) {
          visitCounter.set(key, {
            count: 0,
            employeeId: e.EmployeeID,
            name: e.ObjectName1,
            personnelType: e.PersonnelType
          });
        }
        visitCounter.get(key).count++;
      }
    }

    // Group events by date for summaries
    const byDateMap = new Map();
    for (const ev of events) {
      if (!byDateMap.has(ev.Dateonly)) byDateMap.set(ev.Dateonly, []);
      byDateMap.get(ev.Dateonly).push(ev);
    }

    const dailySummaries = [];
    const peakOccupancy = [];
    for (const d of allDates) {
      const dayEvents = byDateMap.get(d) || [];
      const uniqueSet = new Set(dayEvents.map(e => canonicalKey(e)));
      dailySummaries.push({ date: d, total: uniqueSet.size });

      let current = 0, maxCount = 0;
      for (const ev of dayEvents) {
        if (ev.Direction === 'InDirection') current++;
        else if (ev.Direction === 'OutDirection') current = Math.max(0, current - 1);
        if (current > maxCount) maxCount = current;
      }
      peakOccupancy.push({ date: d, peak: maxCount });
    }

    // Compute avg daily headcount
    const totalsByDate = Object.fromEntries(dailySummaries.map(d => [d.date, d.total]));
    const consideredTotals = consideredDates.map(d => totalsByDate[d] || 0);
    const avgDailyHeadcount = consideredTotals.length
      ? Math.round(consideredTotals.reduce((s, v) => s + v, 0) / consideredTotals.length)
      : 0;

    // Top10 visitors
    const top10Visitors = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({ employeeId: v.employeeId, name: v.name, personnelType: v.personnelType, visits: v.count }));

    // Build attendance sheet
    const attendanceSheet = Array.from(presenceByPerson.values()).map(p => {
      const row = { employeeId: p.employeeId, name: p.name, personnelType: p.personnelType };
      let presentCount = 0;

      for (const d of allDates) {
        const isFuture = (isRequestedMonthCurrent && d > todayKolkataStr);
        if (isFuture) { row[d] = null; continue; }

        if (p.days.has(d)) { row[d] = 'P'; presentCount++; }
        else { row[d] = 'A'; }
      }

      const workingDaysToDate = consideredDates.length;
      const daysAbsent = Math.max(0, workingDaysToDate - presentCount);
      const attendancePercent = workingDaysToDate > 0
        ? ((presentCount / workingDaysToDate) * 100).toFixed(1) + '%'
        : '0.0%';

      row.daysPresent = presentCount;
      row.daysAbsent = daysAbsent;
      row.attendancePercent = attendancePercent;
      return row;
    });

    return res.json({
      month,
      today: todayKolkataStr,
      workingDaysConsidered: consideredDates.length,
      avgDailyHeadcount,
      peakOccupancy,
      top10Visitors,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
