// Add near other modal/loading state
const [rejectionModalLoading, setRejectionModalLoading] = useState(false);

......





const handleRejectionCellClick = async (normFloor, displayFloor) => {
  setRejectionModalLoading(true);
  let list = rejectionDetails[normFloor] || [];

  // 1) If grouped list empty, try matching by derived floor from flat details
  if ((!list || list.length === 0) && Array.isArray(rejectionAllDetailsToday) && rejectionAllDetailsToday.length > 0) {
    list = rejectionAllDetailsToday.filter(d => {
      const derived = normalizeFloorName(deriveFloorFromRecord(d) || '');
      return derived === normFloor;
    });
  }

  // 2) If still empty but summary says there's a count, try on-demand fetch for that floor (best-effort)
  if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0) {
    try {
      const floorNumMatch = normFloor && normFloor.match(/\d+/) ? normFloor.match(/\d+/)[0] : null;
      if (floorNumMatch) {
        const dateParam = encodeURIComponent(new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' }));
        const q = `/api/rejections?date=${dateParam}&floor=${encodeURIComponent(floorNumMatch)}`;
        console.info('[rejections] fetching per-floor details:', q);

        const r = await fetch(q);
        if (r.ok) {
          const payload = await r.json();
          const fetchedDetails = Array.isArray(payload.details) ? payload.details : (Array.isArray(payload) ? payload : []);
          if (fetchedDetails.length > 0) {
            const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
            // extractIsoDate helper should exist (see earlier suggestions); fallback to slice if missing
            const fd = fetchedDetails.filter(d => {
              const raw = d.LocaleMessageTime || d.DateOnly || d.MessageTime || '';
              const recDate = typeof extractIsoDate === 'function' ? extractIsoDate(raw) : (String(raw).slice(0,10));
              return recDate === todayDenver;
            });
            if (fd.length > 0) list = fd;
          }
        } else {
          console.warn('[rejections] per-floor fetch returned', r.status);
        }
      }
    } catch (e) {
      console.warn('on-demand fetch for floor details failed', e);
    }
  }

  // 3) Final fallback: try to match by numeric floor in Door/Location (less robust, but useful if data contains floor in Door string)
  if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0 && Array.isArray(rejectionAllDetailsToday) && rejectionAllDetailsToday.length > 0) {
    const numMatch = (normFloor && normFloor.match(/\d+/)) ? normFloor.match(/\d+/)[0] : null;
    if (numMatch) {
      const regex = new RegExp(`\\b${numMatch}\\b`);
      list = rejectionAllDetailsToday.filter(d => {
        const door = String(d.Door || d.door || d.Location || '');
        return regex.test(door);
      });
    }
  }

  // 4) If still empty but summary count exists, create UX placeholders so modal doesn't show "No rejections..."
  if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0) {
    const count = rejectionSummaryMap[normFloor] || 1;
    const doorLabel = displayFloor || normFloor;
    list = new Array(count).fill(0).map((_, i) => ({
      DateOnly: new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' }),
      LocaleMessageTime: `${new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' })}T00:00:00Z`,
      ObjectName1: '(details missing)',
      EmployeeID: '',
      CardNumber: '',
      PersonnelType: '',
      Door: doorLabel,
      RejectionType: 'Aggregate (details not returned)'
    }));
  }

  setSelectedRejectionFloor(displayFloor || normFloor);
  setSelectedRejectionList(list || []);
  setShowRejectionModal(true);
  setRejectionModalLoading(false);
};
