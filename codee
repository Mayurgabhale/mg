// normalize & cheap-match helper
const normalizeZone = (s = '') =>
  s.toString().toLowerCase().replace(/[–—-]/g, '-').replace(/\s+/g, ' ').trim();

const zoneMatches = (value = '', filterZone = '') => {
  if (!value || !filterZone) return false;
  // compare only the floor/area text, not zone color suffixes
  const v = normalizeZone(value);
  const f = normalizeZone(filterZone);
  // make 'podium floor - red zone' match 'podium floor'
  return v.includes(f);
};




....


const members = filterZone
  ? membersRaw.filter(m => {
      // only include present members per your existing rule
      if (!m.present) return false;

      // member-level locations (support different property names)
      const memberLoc = m.zone || m['Base Location'] || m.Floor || m.baseLocation || '';
      // 1) match if member has a live/member location that matches
      if (zoneMatches(memberLoc, filterZone)) return true;

      // 2) only if member has NO location info at all, fall back to role-level base
      const hasMemberLocation = !!(m.zone || m['Base Location'] || m.Floor || m.baseLocation);
      if (!hasMemberLocation && baseLocationByRole[role] && zoneMatches(baseLocationByRole[role], filterZone)) {
        return true;
      }

      return false;
    })
  : membersRaw;




...


const filtered = filterZone
  ? members.filter(m => {
      if (!m.present) return false;
      const memberLoc = m.liveLocation || m.baseLocation || '';
      if (zoneMatches(memberLoc, filterZone)) return true;
      // only use role-level fallback if member has no location properties
      const hasMemberLocation = !!(m.liveLocation || m.baseLocation);
      if (!hasMemberLocation && baseLocationByRole['ERT Team Members'] && zoneMatches(baseLocationByRole['ERT Team Members'], filterZone)) {
        return true;
      }
      return false;
    })
  : members;


const floorCounts = useMemo(() => {
  const counts = { 'Podium Floor': 0, '2nd Floor': 0, 'Tower B': 0 };
  allMembers.forEach(m => {
    if (!m.present) return;
    // prefer member live/location properties, then base location fallback
    const loc = (m.zone || m['Base Location'] || m.Floor || m.baseLocation || '').toString().toLowerCase();
    if (loc.includes('2nd')) counts['2nd Floor']++;
    else if (loc.includes('tower b')) counts['Tower B']++;
    else if (loc.includes('podium')) counts['Podium Floor']++;
    else {
      // optional: if nothing matches, categorize by role-level fallback
      const roleBase = baseLocationByRole[m.role] || '';
      const r = roleBase.toLowerCase();
      if (r.includes('tower b')) counts['Tower B']++;
      else if (r.includes('2nd')) counts['2nd Floor']++;
      else counts['Podium Floor']++;
    }
  });
  return counts;
}, [allMembers]);
