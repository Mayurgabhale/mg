// ----------------- Diagnostic & robust snapshot handler -----------------
/**
 * GET /api/occupancy-at?at=<ISO-8601>
 * Snapshot at the provided UTC timestamp.
 *
 * This handler runs the primary 'robust local-day' calculation plus two fallbacks:
 *  - count_by_dateonly(): uses SQL's Dateonly column
 *  - count_by_utcday(): uses UTC day derived from LocaleMessageTime (no tz)
 *
 * It returns a small `debug` object to help identify why counts might be zero.
 */
function count_by_dateonly(allEvents, atDate) {
  // use SQL Dateonly string compared to local date derived from atDate
  const asOfLocalDate = DateTime.fromJSDate(atDate, { zone: 'utc' }).setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
  const dedup = new Map();
  for (const e of allEvents) {
    if (e.Direction !== 'InDirection') continue;
    // if SQL's Dateonly matches
    if (String(e.Dateonly) !== asOfLocalDate) continue;
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || (e.ObjectName1 ? String(e.ObjectName1).trim() : null);
    if (!key) continue;
    const evtTs = parseEventTimestamp(e);
    if (!evtTs) continue;
    const prev = dedup.get(key);
    if (!prev || (evtTs && new Date(prev.LocaleMessageTime).getTime() < evtTs.getTime())) {
      dedup.set(key, e);
    }
  }
  const list = Array.from(dedup.values());
  const employees = list.filter(x => !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management'].includes(x.PersonnelType)).length;
  return { employees, contractors: list.length - employees, total: list.length };
}

function count_by_utcday(allEvents, atDate) {
  // count InDirection where event's UTC date === snapshot's UTC date AND evt <= atDate
  const asOfUtcDay = DateTime.fromJSDate(atDate, { zone: 'utc' }).toFormat('yyyy-LL-dd');
  const dedup = new Map();
  for (const e of allEvents) {
    if (e.Direction !== 'InDirection') continue;
    const evtTs = parseEventTimestamp(e);
    if (!evtTs) continue;
    const evtUtcDay = DateTime.fromJSDate(evtTs, { zone: 'utc' }).toFormat('yyyy-LL-dd');
    if (evtUtcDay !== asOfUtcDay) continue;
    if (evtTs.getTime() > atDate.getTime()) continue;
    const key = e.PersonGUID || e.EmployeeID || e.CardNumber || (e.ObjectName1 ? String(e.ObjectName1).trim() : null);
    if (!key) continue;
    const prev = dedup.get(key);
    if (!prev || (evtTs && new Date(prev.LocaleMessageTime).getTime() < evtTs.getTime())) {
      dedup.set(key, e);
    }
  }
  const list = Array.from(dedup.values());
  const employees = list.filter(x => !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management'].includes(x.PersonnelType)).length;
  return { employees, contractors: list.length - employees, total: list.length };
}

exports.getSnapshotAt = async (req, res) => {
  try {
    const atRaw = req.query.at;
    if (!atRaw) return res.status(400).json({ error: 'missing "at" query parameter (ISO timestamp required)' });

    const atDate = DateTime.fromISO(atRaw, { zone: 'utc' }).toJSDate();
    if (!atDate || Number.isNaN(atDate.getTime())) {
      return res.status(400).json({ error: 'invalid "at" timestamp' });
    }

    // fetch events in the 24h window ending at atDate
    const events = await fetchEventsWindow(atDate);

    // normalize timestamps to ISO strings for stable comparisons & attach parsedDate for speed
    for (const e of events) {
      const parsed = parseEventTimestamp(e);
      if (parsed) {
        e._parsedTs = parsed;            // Date object
        e.LocaleMessageTime = parsed.toISOString(); // normalized ISO string
      } else {
        e._parsedTs = null;
      }
    }

    // Primary robust calculation (local-day using event timestamp)
    const visitedRobust = buildVisitedForDate(events, atDate);

    // Fallback: use SQL Dateonly column (maybe DB already did localization)
    const visitedDateonly = count_by_dateonly(events, atDate);

    // Fallback: use UTC day comparison
    const visitedUtcday = count_by_utcday(events, atDate);

    const occupancy = await buildOccupancy(events);

    // Fill visited stats using the robust method (but include debug)
    occupancy.totalVisitedToday = visitedRobust.total;
    occupancy.visitedToday = {
      employees: visitedRobust.employees,
      contractors: visitedRobust.contractors,
      total: visitedRobust.total
    };
    occupancy.asOf = atDate.toISOString();

    // Diagnostic info to include in response (remove once fixed)
    const debug = {
      eventsReturned: events.length,
      inDirectionCount: events.filter(e => e.Direction === 'InDirection').length,
      firstEvent: events.length ? events[0].LocaleMessageTime : null,
      lastEvent: events.length ? events[events.length - 1].LocaleMessageTime : null,
      visitedRobust,
      visitedDateonly,
      visitedUtcday,
      sampleEvents: events.slice(0, 8).map(e => ({
        LocaleMessageTime: e.LocaleMessageTime,
        Direction: e.Direction,
        PersonnelType: e.PersonnelType,
        PersonGUID: e.PersonGUID,
        EmployeeID: e.EmployeeID,
        CardNumber: e.CardNumber,
        Dateonly: e.Dateonly
      }))
    };

    // Attach debug under `__debug` so it doesn't break existing clients (you can remove later)
    occupancy.__debug = debug;

    return res.json(occupancy);
  } catch (err) {
    console.error('getSnapshotAt error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};