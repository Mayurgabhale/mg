hi,
know your work.
we want to create in this time wise counte get.
for example i select any date or time. that particular time and date. i want to disply all page details or headcount,
alos change all. 
one particular time. how much headcount. ok
i hope you understand better, what we want to create. 
so read all code carefuuly, and create this future. ok
and listion dont change my privisue code logic. jsut add this new future. ok 
carefully. 

// C:\Users\W0024618\Desktop\swipeData\client\src\App.js

import React, { useEffect, useState } from 'react';
import { Container, Navbar, Nav } from 'react-bootstrap';
import { BrowserRouter, Routes, Route, Link, useLocation } from 'react-router-dom';
import { FaSun } from 'react-icons/fa';
import ZoneDetailsTable from './components/ZoneDetailsTable';
import DashboardHome    from './pages/DashboardHome';
import ErtPage          from './pages/ErtPage';
import './App.css';

function ZoneDetailsPage({ detailsData }) {
  const [searchTerm, setSearchTerm] = useState('');

  return (
    <>
      <div
        className="d-flex justify-content-between align-items-center mb-2"
        style={{ flexWrap: 'wrap', gap: '0.5rem' }}
      >
        <Link to="/" className="btn btn-secondary">‚Üê Back to Dashboard</Link>
        <input
          type="text"
          placeholder="Search employee..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          style={{ flexGrow: 1, maxWidth: 300, padding: '0.4rem 0.8rem', fontSize: '1rem', borderRadius: 4, border: '1px solid #ccc' }}
        />
      </div>
      <ZoneDetailsTable data={detailsData} searchTerm={searchTerm} />
    </>
  );
}

function App() {
  const location = useLocation();
  const headerText = location.pathname === '/ert'
    ? 'Emergency Response Team ‚Äî Western Union Pune'
    : 'Live Occupancy ‚Äî Western Union Pune';

  // Single state object for the entire payload
  const [liveData, setLiveData] = useState({
    summary: [],
    details: {},
    floorBreakdown: [],
    zoneBreakdown: [],
    personnelBreakdown: [],
    totalVisitedToday: 0,
    personnelSummary: { employees: 0, contractors: 0 },
    visitedToday: { employees: 0, contractors: 0, total: 0 },
    ertStatus: {}
  });

  useEffect(() => {
    const es = new EventSource('http://localhost:5000/api/live-occupancy');
    es.onmessage = (e) => {
      try {
        const p = JSON.parse(e.data);
        // Batch-update entire payload in one setState
        setLiveData({
          summary: Array.isArray(p.summary) ? p.summary : [],
          details: p.details || {},
          floorBreakdown: Array.isArray(p.floorBreakdown) ? p.floorBreakdown : [],
          zoneBreakdown: Array.isArray(p.zoneBreakdown) ? p.zoneBreakdown : [],
          personnelBreakdown: Array.isArray(p.personnelBreakdown) ? p.personnelBreakdown : [],
          totalVisitedToday: typeof p.totalVisitedToday === 'number' ? p.totalVisitedToday : 0,
          personnelSummary: p.personnelSummary || { employees: 0, contractors: 0 },
          visitedToday: p.visitedToday || { employees: 0, contractors: 0, total: 0 },
          ertStatus: p.ertStatus || {}
        });
      } catch {
        console.error('SSE parse error');
      }
    };

    es.onerror = (err) => {
      console.error('SSE error', err);
      es.close();
    };

    return () => es.close();
  }, []);

  return (
    <>
      <Navbar bg="dark" variant="dark" expand="lg" className="px-4">
        <Navbar.Brand as={Link} to="/" className="wu-brand">{headerText}</Navbar.Brand>
        <Nav className="ms-auto align-items-center">
          <Nav.Link as={Link} to="/" className="nav-item-infographic"><i class="bi bi-house"></i></Nav.Link>
          <Nav.Link href="http://10.199.22.57:3000/partition/Pune/history"  className="nav-item-infographic"><i class="bi bi-clock-history"></i></Nav.Link>
          <Nav.Link as={Link} to="/details" className="nav-item-infographic"><i class="fa-solid fa-calendar-day"></i></Nav.Link>
          <Nav.Link as={Link} to="/ert" className="nav-item-infographic">ERT Overview</Nav.Link>
          <Nav.Link className="theme-toggle-icon" title="Dark mode only"><FaSun/></Nav.Link>
        </Nav>
      </Navbar>

      <Container fluid className="mt-2">
        <Routes>
          <Route
            path="/"
            element={
              <DashboardHome
                summaryData={liveData.summary}
                detailsData={liveData.details}
                floorData={liveData.floorBreakdown}
                zoneBreakdown={liveData.zoneBreakdown}
                personnelBreakdown={liveData.personnelBreakdown}
                totalVisitedToday={liveData.totalVisitedToday}
                personnelSummary={liveData.personnelSummary}
                visitedToday={liveData.visitedToday}
                ertStatus={liveData.ertStatus}
              />
            }
          />
          <Route path="/details" element={<ZoneDetailsPage detailsData={liveData.details} />} />
          <Route path="/ert"     element={<ErtPage ertStatus={liveData.ertStatus} />} />
        </Routes>
      </Container>
    </>
  );
}
export default function WrappedApp() {
  return (
    <BrowserRouter>
      <div className="dark-theme">
        <App />
      </div>
    </BrowserRouter>
  );
}
............
// C:\Users\W0024618\Desktop\swipeData\client\src\pages\DashboardHome.jsx

import React, { useMemo } from 'react';
import { Container, Row, Col } from 'react-bootstrap';

import SummaryCards        from '../components/SummaryCards';
import FloorOccupancyChart from '../components/FloorOccupancyChart';
import SummaryChart        from '../components/SummaryChart';
import PersonnelDonutChart from '../components/PersonnelDonutChart';

function DashboardHome({
  summaryData,
  detailsData,
  floorData,
  zoneBreakdown,
  personnelBreakdown,
  totalVisitedToday,
  personnelSummary,
  visitedToday,
  ertStatus
}) {
  const employees      = personnelSummary?.employees   ?? 0;
  const contractors    = personnelSummary?.contractors ?? 0;
  const totalOccupancy = employees + contractors;

  // Memoize donut-chart data so it only recalculates when personnelBreakdown changes
  const chartData = useMemo(() =>
    (personnelBreakdown || []).map(({ personnelType, count }) => ({ personnelType, count })),
    [personnelBreakdown]
  );

  return (
    <Container fluid className="py-4">
      <SummaryCards
        totalOccupancy={totalOccupancy}
        employeeCount={employees}
        contractorCount={contractors}
        totalVisitedToday={totalVisitedToday}
        employeesVisitedToday={visitedToday?.employees   ?? 0}
        contractorsVisitedToday={visitedToday?.contractors ?? 0}
      />

      <Row className="g-4">
        <Col md={4}>
          <FloorOccupancyChart data={floorData} />
        </Col>

        <Col md={4}>
          <SummaryChart summary={summaryData} />
        </Col>

        <Col md={4}>
          <PersonnelDonutChart data={chartData} />
        </Col>
      </Row>

      <footer style={{
        backgroundColor: '#000',
        color: '#FFC72C',
        padding: '1.5rem 0',
        textAlign: 'center',
        marginTop: '0rem',
        borderTop: '2px solid #FFC72C',
        fontSize: '0.95rem',
        lineHeight: '1.6'
      }}>
        <div><strong>Global Security Operations Center</strong><br/>
          Live HeadCount against Occupancy dashboard for Western Union Pune ‚Äî Real-time occupancy, floor activity, and personnel insights.
        </div>
        <div style={{ marginTop: '0.75rem' }}>
          Contact us:&nbsp;
          <a href="mailto:GSOC-GlobalSecurityOperationCenter.SharedMailbox@westernunion.com"
             style={{ color: '#FFC72C', textDecoration: 'underline' }}>
            GSOC Mail
          </a>&nbsp;|&nbsp;
          Landline:&nbsp;<span style={{ color: '#FFC72C' }}>+91-020-67632394</span>
        </div>
      </footer>
    </Container>
  );
}

// Memoize whole page so it only re-renders when its props actually change
export default React.memo(DashboardHome);
..

// C:\Users\W0024618\Desktop\swipeData\client\src\components\SummaryCards.jsx
import React, { useEffect, useMemo, useState } from "react";
import { Card, Row, Col } from "react-bootstrap";
import { FaUsers, FaUserTie, FaHardHat } from "react-icons/fa";
import "./SummaryCards.css";

export default function SummaryCards({
  totalVisitedToday,
  employeesVisitedToday,
  contractorsVisitedToday,
  totalOccupancy,
  employeeCount,
  contractorCount,
}) {
  const ICONS = [
    { key: "totalVisitedToday", title: "Today's Total", value: totalVisitedToday, icon: <FaUsers /> },
    { key: "employeesVisitedToday", title: "Today's Employees", value: employeesVisitedToday, icon: <FaUserTie /> },
    { key: "contractorsVisitedToday", title: "Today's Contractors", value: contractorsVisitedToday, icon: <FaHardHat /> },
    { key: "totalOccupancy", title: "Realtime Total", value: totalOccupancy, icon: <FaUsers /> },
    { key: "employeeCount", title: "Realtime Employees", value: employeeCount, icon: <FaUserTie /> },
    { key: "contractorCount", title: "Realtime Contractors", value: contractorCount, icon: <FaHardHat /> },
  ];

  // Convert to numbers safely
  const sanitized = useMemo(
    () => ICONS.map((c) => ({ ...c, value: Number(c.value) || 0 })),
    [totalVisitedToday, employeesVisitedToday, contractorsVisitedToday, totalOccupancy, employeeCount, contractorCount]
  );
  const maxVal = Math.max(...sanitized.map((s) => s.value), 1);

  // Animate numbers
  const [animated, setAnimated] = useState(() =>
    sanitized.reduce((acc, c) => {
      acc[c.key] = 0;
      return acc;
    }, {})
  );

  useEffect(() => {
    let rafId;
    const duration = 1000;
    const start = performance.now();
    const from = sanitized.reduce((acc, c) => {
      acc[c.key] = animated[c.key] || 0;
      return acc;
    }, {});
    const to = sanitized.reduce((acc, c) => {
      acc[c.key] = c.value;
      return acc;
    }, {});

    function step(now) {
      const t = Math.min(1, (now - start) / duration);
      const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      const next = {};
      for (const k of Object.keys(to)) {
        next[k] = Math.round(from[k] + (to[k] - from[k]) * ease);
      }
      setAnimated(next);
      if (t < 1) rafId = requestAnimationFrame(step);
    }
    rafId = requestAnimationFrame(step);
    return () => cancelAnimationFrame(rafId);
  }, [sanitized]);

  return (
    <Row className="summary-cards-new">
      {sanitized.map((c, i) => {
        const percent = Math.round((c.value / maxVal) * 100);

        return (
          <Col key={c.key} xs={12} sm={6} md={4} lg={2} className="mb-4">
            <Card className="summary-card-new">
              <Card.Body className="d-flex flex-column align-items-center">
                {/* Circular progress */}

                {/* Circular progress (now always full) */}
                <div
                  className="progress-circle"
                  style={{
                    background: `var(--accent-${i})`
                  }}
                >
                  <div className="circle-inner">
                    <div className="icon-wrap" style={{ color: `var(--accent-${i})` }}>
                      {c.icon}
                    </div>
                  </div>
                </div>


                {/* Title */}
                <div className="title-text">{c.title}</div>

                {/* Number */}
                <div className="count-text">{animated[c.key].toLocaleString()}</div>
              </Card.Body>
            </Card>
          </Col>
        );
      })}
    </Row>
  );
}

....

// src/components/FloorOccupancyChart.jsx
import React from 'react';
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  Cell,
  LabelList,
  Legend,
  Customized
} from 'recharts';
import { Card } from 'react-bootstrap';
import {
  FaSearch,
  FaStar,
  FaEnvelope,
  FaChartBar,
  FaUsers
} from 'react-icons/fa';
import floorCapacities from '../constants/floorCapacities';

/*
  COLOR PALETTE: distinct gradient pairs for each cylinder (repeats if more floors)
*/
const CYLINDER_COLORS = [
  ['#BEE9FF', '#4DB8FF'], // light -> mid blue
  ['#0B4F8C', '#2F80ED'], // dark -> lighter blue
  ['#F27FA6', '#B93F72'], // pink shades
  ['#FFB84D', '#F26B00'], // orange shades
  ['#C6F28B', '#4DB646']  // green shades
];

/*
  ICONS: map icons per cylinder (repeats if more floors)
*/
const CYLINDER_ICONS = [FaUsers, FaStar, FaEnvelope, FaChartBar, FaSearch];

export default function FloorOccupancyChart({ data = [] }) {
  if (!data.length) {
    return (
      <Card body className="bg-dark text-white">
        No floor data available
      </Card>
    );
  }

  // -------------------------------
  // YOUR LOGIC: enrichment, totals,
  // sorting ‚Äî left exactly as you had it
  // -------------------------------
  const enriched = data.map((floorObj) => {
    const { floor, total: liveCount } = floorObj;
    const capacity = floorCapacities[floor] ?? 0;
    const usedPct = capacity > 0
      ? ((liveCount / capacity) * 100).toFixed(1)
      : '0.0';
    return {
      ...floorObj,           // includes breakdown fields: employees, contractors, etc.
      capacity,
      liveCount,
      usedPct: Number(usedPct),
      label: `${liveCount}/${capacity}`
    };
  });

  // 2) Compute ‚ÄúPune Office Total‚Äù across all floors
  const totalLive = enriched.reduce((sum, f) => sum + f.liveCount, 0);
  const totalCap = enriched.reduce((sum, f) => sum + f.capacity, 0);
  const totalUsedPct = totalCap > 0
    ? ((totalLive / totalCap) * 100).toFixed(1)
    : '0.0';

  const totalEntry = {
    floor: 'Pune Office Total',
    liveCount: totalLive,
    capacity: totalCap,
    usedPct: Number(totalUsedPct),
    label: `${totalLive}/${totalCap}`
  };

  // 3) Sort floors by liveCount descending, then prepend ‚ÄúPune Office Total‚Äù
  const sortedFloors = [...enriched].sort((a, b) => b.liveCount - a.liveCount);
  const chartData = [totalEntry, ...sortedFloors];

  // 4) Determine the maximum capacity to set Y-axis domain
  const maxCapacity = Math.max(...chartData.map(f => f.capacity)) || 0;
  // NEW: determine maximum live count (used to scale the Y axis so bars appear taller)
  const maxLive = Math.max(...chartData.map(f => f.liveCount)) || 0;
  // compute a display max slightly above maxLive for breathing room and round to nearest 10
  const yDomainMax = Math.ceil((maxLive * 1.15 || maxCapacity) / 10) * 10;

  // 5) Custom tooltip to show raw counts, percentages, and breakdown (left intact)
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload?.length) return null;
    const floorObj = payload[0].payload;
    const { liveCount, capacity, usedPct } = floorObj;

    const breakdownEntries = Object.entries(floorObj).filter(
      ([key]) =>
        !['floor', 'liveCount', 'capacity', 'usedPct', 'label'].includes(key)
    );

    return (
      <div
        style={{
          backgroundColor: '#1a1a1a',
          color: '#FFD100',
          border: '1px solid var(--wu-yellow)',
          borderRadius: 4,
          padding: '0.75rem',
          minWidth: 200
        }}
      >
        <div style={{ marginBottom: 4, fontSize: '1rem' }}>
          <strong>Floor: {floorObj.floor}</strong>
        </div>
        <div style={{ marginBottom: 6, fontWeight: 'bold', fontSize: '0.9rem' }}>
          Live: {liveCount} / {capacity} ({usedPct}%)
        </div>
        {breakdownEntries.map(([type, value]) => (
          <div
            key={type}
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              marginTop: 2,
              color: '#fff',
              fontSize: '0.85rem'
            }}
          >
            <span style={{ opacity: 0.8 }}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </span>
            <span style={{ fontWeight: 'bold' }}>{value}</span>
          </div>
        ))}
      </div>
    );
  };

  // -------------------------------
  // Cylinder shape (single cylinder per floor)
  // Recharts calls this with props: x, y, width, height, payload, etc.
  // We derive the index by matching payload.floor in chartData.
  // -------------------------------
// REPLACE CylinderShape with this
const CylinderShape = (props) => {
  const { x, y, width, height, payload } = props;
  const floorName = payload && payload.floor;
  const idx = chartData.findIndex(d => d.floor === floorName);
  const fill = `url(#cyl-grad-${idx})`;

  const cx = x + width / 2;
  const topRy = Math.max(8, width * 0.12);
  const bottomRy = Math.max(10, width * 0.14);
  const bottomY = y + height;

  // centered label (live/cap) ‚Äî large and bold
  const centerLabel = payload && payload.label ? payload.label : '';

  return (
    <g>
      {/* shadow under the cylinder */}
      <ellipse
        cx={cx}
        cy={bottomY + bottomRy * 0.9}
        rx={width * 0.62}
        ry={bottomRy * 0.45}
        fill="rgba(0,0,0,0.25)"
      />

      {/* cylinder body */}
      <rect
        x={x}
        y={y}
        width={width}
        height={height}
        rx={12}
        ry={12}
        fill={fill}
        stroke="rgba(255,255,255,0.06)"
        strokeWidth={1}
      />

      {/* top ellipse */}
      {/* <ellipse
        cx={cx}
        cy={y}
        rx={width / 2}
        ry={topRy}
        fill={fill}
        stroke="rgba(255,255,255,0.12)"
        strokeWidth={1}
      /> */}

      {/* bottom ellipse for 3D look */}
      <ellipse
        cx={cx}
        cy={bottomY}
        rx={width / 2}
        ry={bottomRy}
        fill="rgba(255,255,255,0.03)"
      />

      {/* big centered count (live/cap) */}
      {centerLabel && (
        <text
          x={cx}
          // vertically center: use middle of cylinder body
          y={y + height / 2 + 8} 
          textAnchor="middle"
          fontSize={Math.max(12, Math.round(width * 0.18))}
          fontWeight="600"
          fill="#ffffff"
        >
          {centerLabel}
        </text>
      )}
    </g>
  );
};
  // -------------------------------
  // Curve overlay that passes exactly through the top centers of the bars
  // Customized component receives xAxisMap and yAxisMap we can use for exact pixel coords
  // -------------------------------
 // REPLACE your existing CurveOverlay/InfographicCurve with this simplified version
const CurveOverlay = ({ width, height, xAxisMap, yAxisMap }) => {
  const xKey = Object.keys(xAxisMap || {})[0];
  const yKey = Object.keys(yAxisMap || {})[0];

  if (!xKey || !yKey) return null;

  const xScale = xAxisMap[xKey].scale;
  const yScale = yAxisMap[yKey].scale;

  const points = chartData.map((d) => {
    const x = xScale(d.floor) + (xScale.bandwidth ? xScale.bandwidth() / 2 : 0);
    const y = yScale(d.liveCount);
    return { x, y };
  });

  if (points.length < 2) return null;

  // build smooth path
  let path = `M ${points[0].x} ${points[0].y}`;
  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1];
    const cur = points[i];
    const midX = (prev.x + cur.x) / 2;
    const midY = (prev.y + cur.y) / 2;
    path += ` Q ${prev.x} ${prev.y} ${midX} ${midY}`;
  }
  const last = points[points.length - 1];
  path += ` T ${last.x} ${last.y}`;

  return (
    <g>
      {/* faint grey helper line */}
      <path d={path} fill="none" stroke="#cccccc" strokeWidth={2} strokeOpacity={0.6} />
      {/* bright accent line on top */}
      <path d={path} fill="none" stroke="#FFD100" strokeWidth={3} strokeOpacity={0.9} strokeLinecap="round" />
    </g>
  );
};
  return (
    <Card className="mb- shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center fw-bold" style={{ borderBottom: '2px solid var(--wu-yellow)', fontSize: '1.2rem' }}>
        Western Union-Pune Headcount against Occupancy
      </Card.Header>

      {/* NEW: increase chart container height so cylinders can be taller */}
      <Card.Body style={{ height: '50vh', padding: 0, backgroundColor: 'var(--wu-gray-dark)' }}>
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            // NEW: more top margin so the curve + markers have space
            margin={{ top: 10, right: 24, left: 20, bottom: 40 }}
            // keep category gap but you can tweak to control cylinder spacing
            barCategoryGap="18%"
          >
            {/* define per-cylinder gradients */}
            <defs>
              {chartData.map((_, idx) => {
                const [c1, c2] = CYLINDER_COLORS[idx % CYLINDER_COLORS.length];
                return (
                  <linearGradient id={`cyl-grad-${idx}`} key={`cyl-grad-${idx}`} x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stopColor={c1} stopOpacity={1} />
                    <stop offset="100%" stopColor={c2} stopOpacity={1} />
                  </linearGradient>
                );
              })}
            </defs>

            {/* <CartesianGrid stroke="#444" strokeDasharray="3 3" /> */}
            <XAxis
              dataKey="floor"
              tick={{ fontSize: 12, fill: '#fff' }}
              interval={0}
              height={80}
            />
            {/* NEW: use yDomainMax (derived from maxLive) to make bars visually larger */}
            <YAxis
              tick={{ fontSize: 13, fill: '#fff' }}
              domain={[0, yDomainMax]}
            />
            <Tooltip content={renderTooltip} />
            <Legend
              verticalAlign="top"
              align="center"
              wrapperStyle={{ color: '#fff', paddingBottom: 8 }}
              payload={[
                { value: 'Live HeadCount', type: 'square', color: '#4DB8FF' }
              ]}
            />

            <Bar dataKey="liveCount" barSize={140} shape={<CylinderShape />}>
              {chartData.map((d, idx) => (
                <Cell key={`cyl-cell-${idx}`} fill={`url(#cyl-grad-${idx})`} />
              ))}
              <LabelList
                dataKey="liveCount"
                position="top"
                formatter={(val) => val}
                style={{ fill: '#fff', fontSize: 15, fontWeight: '800' }}
              />
            </Bar>
            {/* overlay: curve passing through top-centers */}
            <Customized component={(props) => <CurveOverlay {...props} />} />
          </BarChart>
        </ResponsiveContainer>
      </Card.Body>
    </Card>
  );
}


// C:\Users\W0024618\Desktop\swipeData\client\src\components\SummaryChart.jsx
import React from "react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  Cell,
  LabelList,
} from "recharts";
import { Card } from "react-bootstrap";
// Gradients/solid colors for known zones
const ZONE_GRADIENTS = {
  "Red Zone": ["#FF0000", "#D22B2B"],
  "Red Zone - Outer Area": ["#FF0000", "#D22B2B"],
  "Yellow Zone": ["#FFDE21", "#FFBF00"],
  "Yellow Zone - Outer Area": ["#FFDE21", "#FFBF00"],
  "Orange Zone": ["#E3963E", "#FFC966"],
  "Orange Zone - Outer Area": ["#E3963E", "#FFC966"],
  "Green Zone": ["#009E60", "#50C878"],
  "Reception Area": ["#E0CCFF", "#F4E6FF"],
  "Assembly Area": ["#FE6F5E", "#A366FF"],
  "Tower B": ["#E68FAC", "#99BBFF"],
  "2nd Floor, Pune": ["#FF6F61", "#FFA28F"],
};

const SOLID_COLORS = [
  "#FFD100",
  "#009E60",
  "#FF6F61",
  "#58595B",
  "#FFB800",
  "#C75D00",
];

// üîπ Helper: shorten long zone names
const shortenName = (name) => {
  if (name.length > 18) {
    return name.split(" ").slice(0, 2).join(" ") + "..."; // take first 2 words
  }
  return name;
};

export default function SummaryChart({ summary = [] }) {
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // üîπ Sort zones by headcount (descending)
  const sortedData = [...summary].sort((a, b) => b.count - a.count);
  // Custom tooltip
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { zone, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: "#000",
          border: "1px solid var(--wu-yellow)",
          borderRadius: 4,
          padding: "8px",
          color: "#FFD100",
          fontSize: "0.9rem",
        }}
      >
        <div>
          <strong>{zone}</strong>
        </div>
        <div>Headcount: {count}</div>
      </div>
    );
  };

  return (
    <Card
      className="mb-4 shadow-sm border"
      style={{ borderColor: "var(--wu-yellow)" }}
    >
      <Card.Header
        className="bg-dark text-warning text-center fw-bold"
        style={{
          fontSize: "1.2rem",
          borderBottom: "2px solid var(--wu-yellow)",
        }}
      >
        Western Union - Pune Area-wise Headcount
      </Card.Header>

      <Card.Body style={{ height: "50vh", backgroundColor: "#1a1a1a" }}>
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            layout="vertical"
            data={sortedData.map((z) => ({
              ...z,
              shortZone: shortenName(z.zone),
            }))}
            margin={{ top: 20, right: 40, left: 60, bottom: 20 }}
          >
            <XAxis type="number" tick={{ fill: "#FFD100" }} />
            <YAxis
              dataKey="shortZone"
              type="category"
              tick={{ fill: "#FFD100", fontWeight: "bold" }}
              width={150}
            />
            <Tooltip content={renderTooltip} />

            <Bar dataKey="count" radius={[8, 8, 8, 8]} minPointSize={24}>
              {sortedData.map((entry, idx) => {
                const grad = ZONE_GRADIENTS[entry.zone];
                const color = grad
                  ? `url(#grad-${entry.zone.replace(/\s+/g, "-")})`
                  : SOLID_COLORS[idx % SOLID_COLORS.length];
                return <Cell key={`cell-${idx}`} fill={color} />;
              })}

              <LabelList
                dataKey="count"
                position="inside"
                style={{
                  fill: "#fff",
                  fontWeight: "bold",
                  fontSize: "0.9rem",
                }}
              />
            </Bar>

            <defs>
              {sortedData.map((entry) => {
                const grad = ZONE_GRADIENTS[entry.zone];
                if (!grad) return null;
                return (
                  <linearGradient
                    id={`grad-${entry.zone.replace(/\s+/g, "-")}`}
                    key={entry.zone}
                    x1="0"
                    y1="0"
                    x2="1"
                    y2="0"
                  >
                    <stop offset="0%" stopColor={grad[0]} />
                    <stop offset="100%" stopColor={grad[1]} />
                  </linearGradient>
                );
              })}
            </defs>
          </BarChart>
        </ResponsiveContainer>
      </Card.Body>
    </Card>
  );
}
