http://localhost:5000/api/occupancy-at?date=2025-09-18&time=10:00:00

{
  "asOf": "2025-09-18T04:30:00.000Z", see this time this show different time and i search different what i considert which time data is came: 
  "summary": [
    {
      "zone": "Reception Area",
      "count": 8
    },
    {
      "zone": "Red Zone - Outer Area",
      "count": 1
    },
    {
      "zone": "Yellow Zone",
      "count": 4
    },
    {
      "zone": "2nd Floor, Pune",
      "count": 2
    },
    {
      "zone": "Green Zone",
      "count": 1
    },
    {
      "zone": "Tower B",
      "count": 2
    },
    {
      "zone": "Red Zone",
      "count": 1
    }
  ],
  "zoneBreakdown": [
    {


/**
 * GET /occupancy-at?date=YYYY-MM-DD&time=HH:mm:ss
 *
 * Example:
 *   /occupancy-at?date=2025-09-16&time=03:00:00
 *
 * Optional:
 *   &hours=N   (how many hours of history to fetch before target, default 168)
 */
exports.getOccupancyAt = async (req, res) => {
  try {
    await getPool(); // ensure DB pool ready

    const { date, time, hours } = req.query;
    if (!date || !time) {
      return res.status(400).json({
        error: 'Please provide both `date` (YYYY-MM-DD) and `time` (HH:mm:ss)',
      });
    }

    // Parse target datetime in Asia/Kolkata
    let targetDT = DateTime.fromFormat(
      `${date} ${time}`,
      'yyyy-LL-dd HH:mm:ss',
      { zone: 'Asia/Kolkata' }
    );

    // fallback if only HH:mm was given
    if (!targetDT.isValid) {
      targetDT = DateTime.fromFormat(
        `${date} ${time}`,
        'yyyy-LL-dd HH:mm',
        { zone: 'Asia/Kolkata' }
      );
    }

    if (!targetDT.isValid) {
      return res.status(400).json({
        error: 'Invalid date or time format. Example: date=2025-09-16&time=03:00:00',
      });
    }

    // ✅ Block future queries
    const nowLocal = DateTime.now().setZone('Asia/Kolkata');
    if (targetDT > nowLocal) {
      return res.status(400).json({
        error: 'Please select a relevant time — cannot be in the future',
      });
    }

    const lookbackHours = Number.isFinite(Number(hours))
      ? Math.max(1, parseInt(hours, 10))
      : 168; // default 7 days

    const sinceDT = targetDT.minus({ hours: lookbackHours }).toUTC();
    const sinceJS = sinceDT.toJSDate();

    // fetch events newer than sinceJS
    const rawEvents = await fetchNewEvents(sinceJS);

    const targetUTCjs = targetDT.toUTC().toJSDate();

    // ✅ Filter: same date (Asia/Kolkata) and time <= target
    const eventsUpToTarget = rawEvents.filter(evt => {
      const evtLocal = DateTime.fromJSDate(evt.LocaleMessageTime, { zone: 'Asia/Kolkata' });
      return (
        evtLocal.toFormat('yyyy-LL-dd') === date &&  // only same day
        evt.LocaleMessageTime <= targetUTCjs        // not after target time
      );
    });

    // build occupancy as of that time
    const occupancy = await buildOccupancy(eventsUpToTarget);

    occupancy.asOf = targetDT.toUTC().toISO();
    occupancy.requestedAsOfLocal = targetDT.toISO();
    occupancy.requestedAsOfHuman = targetDT.toFormat('yyyy-LL-dd HH:mm:ss');
    occupancy._meta = {
      historyHoursUsed: lookbackHours,
      eventsConsidered: eventsUpToTarget.length,
    };

    return res.json(occupancy);
  } catch (err) {
    console.error('Error in getOccupancyAt:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};
