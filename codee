const handleRejectionCellClick = async (normFloor, displayFloor) => {
  let list = rejectionDetails[normFloor] || [];

  // if grouped list empty but we have flat details, try to match by derived floor
  if ((!list || list.length === 0) && Array.isArray(rejectionAllDetailsToday) && rejectionAllDetailsToday.length > 0) {
    list = rejectionAllDetailsToday.filter(d => {
      const derived = normalizeFloorName(deriveFloorFromRecord(d) || '');
      return derived === normFloor;
    });
  }

  // If still empty but summary says there's a count, try on-demand fetch for that floor (best-effort)
  if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0) {
    try {
      // optional: attempt to hit backend for floor-specific details (if backend supports)
      // you can change query param name to whatever backend expects (floor, floorName, floorNum)
      const floorNumMatch = normFloor && normFloor.match(/\d+/) ? normFloor.match(/\d+/)[0] : null;
      if (floorNumMatch) {
        const q = `/api/rejections?date=${encodeURIComponent(new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' }))}&floor=${encodeURIComponent(floorNumMatch)}`;
        console.info('[rejections] fetching per-floor details:', q);
        const r = await fetch(q);
        if (r.ok) {
          const payload = await r.json();
          // payload.details or payload
          const fetchedDetails = Array.isArray(payload.details) ? payload.details : (Array.isArray(payload) ? payload : []);
          if (fetchedDetails.length > 0) {
            // filter for today just in case
            const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
            const fd = fetchedDetails.filter(d => extractIsoDate(d.LocaleMessageTime || d.DateOnly || '') === todayDenver);
            list = fd;
          }
        }
      }
    } catch (e) {
      console.warn('on-demand fetch for floor details failed', e);
    }
  }

  // final fallback: if list still empty but summary count exists, try to use placeholders from rejectionAllDetailsToday
  if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0 && Array.isArray(rejectionAllDetailsToday) && rejectionAllDetailsToday.length > 0) {
    const numMatch = (normFloor && normFloor.match(/\d+/)) ? normFloor.match(/\d+/)[0] : null;
    if (numMatch) {
      const regex = new RegExp(`\\b${numMatch}\\b`);
      list = rejectionAllDetailsToday.filter(d => {
        const door = String(d.Door || d.door || d.Location || '');
        return regex.test(door);
      });
    }
  }

  // if still empty, but summaryMap has count, create simple placeholders so the modal isn't empty (UX fallback)
  if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0) {
    const count = rejectionSummaryMap[normFloor] || 1;
    list = new Array(count).fill(0).map((_, i) => ({
      DateOnly: new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' }),
      LocaleMessageTime: `${new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' })}T00:00:00Z`,
      ObjectName1: '(details missing)',
      EmployeeID: '',
      CardNumber: '',
      PersonnelType: '',
      Door: normFloor,
      RejectionType: 'Aggregate (details not returned)'
    }));
  }

  setSelectedRejectionFloor(displayFloor || normFloor);
  setSelectedRejectionList(list || []);
  setShowRejectionModal(true);
};