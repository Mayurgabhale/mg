// Build occupancy for "today" where "today" can be the real today OR the date represented by atDt (Denver)
function buildOccupancyForToday(allEvents, freshEvents = [], atDt = null) {
  // reference DateTime in Denver (null => live now)
  const refDt = atDt ? atDt.setZone('America/Denver') : null;

  // canonical person key
  const personKey = (evt) => evt.PersonGUID || evt.EmployeeID || evt.CardNumber;

  // derive a Luxon DateTime in America/Denver for the event.
  // Prefer Dateonly + Swipe_Time (these are the DB's local values). Fallback to parsing LocaleMessageTime.
  const eventDtFor = (evt) => {
    if (evt && evt.Dateonly && evt.Swipe_Time) {
      const iso = `${evt.Dateonly}T${evt.Swipe_Time}`; // e.g. "2025-09-17T00:26:55"
      const dt = DateTime.fromISO(iso, { zone: 'America/Denver' });
      if (dt.isValid) return dt;
    }
    if (evt && evt.LocaleMessageTime) {
      // Last resort: parse LocaleMessageTime as ISO and convert to Denver.
      // NOTE: this is fallback only — avoid relying on it for correctness.
      const dt = DateTime.fromISO(evt.LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver');
      if (dt.isValid) return dt;
    }
    return null;
  };

  // ---------- PREFILTER: only keep events on same Denver date and (if refDt) that occurred <= refDt
  const relevantEvents = allEvents.filter(evt => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;
    const eDt = eventDtFor(evt);
    if (!eDt) return false; // cannot compare -> discard
    return eDt <= refDt;
  });

  // ---------- A) Evict “Out of office” using the last event per person (by eventDt)
  const lastByPerson = new Map(); // personKey -> evt
  const lastDtByPerson = new Map(); // personKey -> DateTime

  relevantEvents.forEach(evt => {
    const key = personKey(evt);
    const eDt = eventDtFor(evt);
    if (!eDt) return; // skip malformed
    const prevDt = lastDtByPerson.get(key);
    if (!prevDt || eDt > prevDt) {
      lastDtByPerson.set(key, eDt);
      lastByPerson.set(key, evt);
    }
  });

  const evicted = new Set();
  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection'
      && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(personKey(evt));
    }
  });

  // active events are relevantEvents minus evicted persons
  const activeEvents = relevantEvents.filter(evt => !evicted.has(personKey(evt)));

  // ---------- 1) Live occupancy dedupe by last InDirection (use eventDt ordering)
  const todayIn = activeEvents.filter(e => e.Direction === 'InDirection');

  const latestByPerson = new Map();
  const latestDtByPerson = new Map();
  todayIn.forEach(e => {
    const key = personKey(e);
    const eDt = eventDtFor(e);
    if (!eDt) return;
    const prev = latestDtByPerson.get(key);
    if (!prev || eDt > prev) {
      latestDtByPerson.set(key, eDt);
      latestByPerson.set(key, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // ---------- 2) Floor breakdown & personnel counts (live)
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') employees++;
    else if (e.PersonnelType) contractors++;
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
    let empCount = 0, contractorCount = 0, tempBadgeCount = 0, otherCount = 0;
    occ.forEach(e => {
      switch (e.PersonnelType) {
        case 'Employee':
        case 'Terminated Personnel':
          empCount++; break;
        case 'Contractor':
        case 'Terminated Contractor':
          contractorCount++; break;
        case 'Temp Badge':
          tempBadgeCount++; break;
        default:
          otherCount++;
      }
    });
    return {
      floor,
      total: occ.length,
      employees: empCount,
      contractors: contractorCount,
      tempBadge: tempBadgeCount,
      others: otherCount,
      occupants: occ
    };
  });

  // ---------- 3) Personnel breakdown
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // ---------- 4) Swipe stats (fresh only) — count only up to refDt
  const countUpToRef = (evt) => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;
    const eDt = eventDtFor(evt);
    if (!eDt) return false;
    return eDt <= refDt;
  };
  const totalInSwipes = (freshEvents || []).filter(e => e.Direction === 'InDirection' && countUpToRef(e)).length;
  const totalOutSwipes = (freshEvents || []).filter(e => e.Direction === 'OutDirection' && countUpToRef(e)).length;

  // ---------- 5) Floor In/Out summary (strict doors only)
  const validEvents = relevantEvents.filter(evt => {
    const doorNoTime = stripTimeSuffix(evt.Door.trim());
    const key = normalizeKey(doorNoTime, (evt.Direction || '').trim());
    return normalizedMonitoredKeys.has(key);
  });

  // Dedupe per person+floor+direction using eventDt ordering
  const deduped = new Map(); // mapKey -> evt
  validEvents.forEach(evt => {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    const mapKey = `${personKey(evt)}___${floor}___${evt.Direction}`;
    const prev = deduped.get(mapKey);
    const nowDt = eventDtFor(evt);
    if (!nowDt) return;
    if (!prev) {
      deduped.set(mapKey, evt);
    } else {
      const prevDt = eventDtFor(prev);
      if (!prevDt || nowDt > prevDt) deduped.set(mapKey, evt);
    }
  });

  // Aggregate in/out per floor
  const floorMapIO = {};
  for (const evt of deduped.values()) {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    if (!floorMapIO[floor]) floorMapIO[floor] = { inSwipes: 0, outSwipes: 0, inSet: new Set(), outSet: new Set() };
    const id = personKey(evt);
    if (evt.Direction === 'InDirection') {
      floorMapIO[floor].inSwipes++;
      floorMapIO[floor].inSet.add(id);
    } else {
      floorMapIO[floor].outSwipes++;
      floorMapIO[floor].outSet.add(id);
    }
  }

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes: stats.inSwipes,
      outSwipes: stats.outSwipes,
      inOnlyCount: inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ---------- 6) Visited today breakdown (reuse computeVisitedToday; it already supports referenceDt)
  const visited = computeVisitedToday(allEvents, refDt);

  // Build final payload
  const asOfLocal = refDt ? refDt.toISO() : DateTime.now().setZone('America/Denver').toISO();
  const asOfUTC = refDt ? refDt.toUTC().toISO() : new Date().toISOString();

  return {
    asOfLocal,
    asOfUTC,
    currentCount: finalList.length,
    floorBreakdown,
    personnelSummary: { employees, contractors },
    personnelBreakdown,
    totalVisitedToday: visited.total,
    visitedToday: {
      employees: visited.employees,
      contractors: visited.contractors,
      total: visited.total
    },
    swipeStats: { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}
