// --- fetch rejections and keep only today's (Denver) records ---
useEffect(() => {
  let mounted = true;

  async function loadRejectionsTodayOnly() {
    setRejectionsLoading(true);
    try {
      const res = await fetch('/api/rejections');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const payload = await res.json();

      // today in Denver (YYYY-MM-DD)
      const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });

      // collect today's details (flat)
      let detailsToday = [];
      const summaryMap = {};

      // Prefer backend dateWise (aggregates) for counts if available
      if (Array.isArray(payload.dateWise)) {
        const dayObj = payload.dateWise.find(d => d.date === todayDenver);
        if (dayObj && Array.isArray(dayObj.floors)) {
          // Build summary map and try to attach any matching details from payload.details
          (dayObj.floors || []).forEach(f => {
            const key = normalizeFloorName(f.floor || '');
            if (!key) return;
            const count = Number(f.rejectionCount || 0);
            summaryMap[key] = count;

            // Try strict match: find detail records whose derived floor equals this key and whose Denver date is today
            if (Array.isArray(payload.details) && count > 0) {
              const strictMatches = payload.details.filter(d => {
                // compute denver date for the record
                let dtStr = '';
                try {
                  const dt = new Date(d.LocaleMessageTime || d.DateOnly || '');
                  dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                } catch (e) {
                  dtStr = String(d.DateOnly || '').slice(0, 10);
                }
                const derived = normalizeFloorName(deriveFloorFromRecord(d));
                return dtStr === todayDenver && derived === key;
              });
              if (strictMatches.length) detailsToday = detailsToday.concat(strictMatches);
            }
          });
        }

        // If we have aggregates but no strict-matched details yet, attempt a looser match:
        // look for any payload.details whose derived floor is in summaryMap and whose Denver date is today.
        if (Array.isArray(payload.details) && Object.keys(summaryMap).length > 0 && detailsToday.length === 0) {
          const summaryKeys = new Set(Object.keys(summaryMap));
          const looseMatches = payload.details.filter(d => {
            let dtStr = '';
            try {
              const dt = new Date(d.LocaleMessageTime || d.DateOnly || '');
              dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
            } catch (e) {
              dtStr = String(d.DateOnly || '').slice(0, 10);
            }
            if (dtStr !== todayDenver) return false;
            const derived = normalizeFloorName(deriveFloorFromRecord(d));
            if (summaryKeys.has(derived)) return true;

            // final fallback: try to match numeric floor found in any summary key with door/location text
            const numericKeys = Array.from(summaryKeys).map(k => {
              const m = k.match(/\d+/);
              return m ? m[0] : null;
            }).filter(Boolean);
            const door = String(d.Door || d.door || d.Location || '');
            return numericKeys.some(n => new RegExp(`\\b${n}\\b`).test(door));
          });

          if (looseMatches.length) detailsToday = detailsToday.concat(looseMatches);
        }

        // If payload.details was present and we still have zero details but a non-zero summary count for some floors,
        // as a final safety net add any details for TODAY that mention the floor numbers (ignoring derived floor)
        if (Array.isArray(payload.details) && detailsToday.length === 0) {
          // gather all floor numbers referenced in summaryMap
          const floorNumbers = Object.keys(summaryMap).map(k => (k.match(/\d+/) || [null])[0]).filter(Boolean);
          if (floorNumbers.length) {
            detailsToday = payload.details.filter(d => {
              let dtStr = '';
              try {
                const dt = new Date(d.LocaleMessageTime || d.DateOnly || '');
                dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
              } catch (e) {
                dtStr = String(d.DateOnly || '').slice(0, 10);
              }
              if (dtStr !== todayDenver) return false;
              const door = String(d.Door || d.door || d.Location || '');
              return floorNumbers.some(n => new RegExp(`\\b${n}\\b`).test(door));
            });
          }
        }

      } else {
        // fallback: filter details for today and aggregate counts
        if (Array.isArray(payload.details)) {
          detailsToday = payload.details.filter(d => {
            const raw = d.LocaleMessageTime || d.DateOnly || d.LocaleMessageTime;
            if (!raw) return false;
            try {
              const dt = new Date(raw);
              const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
              return dtStr === todayDenver;
            } catch (e) {
              return String(raw).slice(0, 10) === todayDenver;
            }
          });

          // derive floor per record and increment summary
          detailsToday.forEach(d => {
            const derived = deriveFloorFromRecord(d) || 'Unknown';
            const key = normalizeFloorName(derived);
            summaryMap[key] = (summaryMap[key] || 0) + 1;
          });
        }
      }

      // group detailsToday by normalized floor (derive floor if missing)
      const detailsByFloor = {};
      detailsToday.forEach(d => {
        const derived = deriveFloorFromRecord(d) || 'Unknown';
        const key = normalizeFloorName(derived) || 'Unknown';
        detailsByFloor[key] = detailsByFloor[key] || [];
        detailsByFloor[key].push(d);
      });

      if (!mounted) return;
      setRejectionSummaryMap(summaryMap);
      setRejectionDetails(detailsByFloor);
      setRejectionAllDetailsToday(detailsToday);
    } catch (err) {
      console.error('Failed to load rejections:', err);
      if (mounted) {
        setRejectionSummaryMap({});
        setRejectionDetails({});
        setRejectionAllDetailsToday([]);
      }
    } finally {
      if (mounted) setRejectionsLoading(false);
    }
  }

  loadRejectionsTodayOnly();
  return () => { mounted = false; };
}, []);