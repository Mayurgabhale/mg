

know we got wrong count 
http://localhost:5000/api/occupancy-at?at=2025-09-10T01:00:00.000Z 
night not that much count, count is big, this is wrong count, 
read all code carefuuly and find out issue, why show that musch count 
know count is wrong 
http://localhost:5000/api/occupancy-at?at=2025-09-10T01:00:00.000Z
  "personnelBreakdown": [
    {
      "personnelType": "Property Management",
      "count": 5
    },
    {
      "personnelType": "Employee",
      "count": 4
    },
    {
      "personnelType": "Contractor",
      "count": 3
    },
    {
      "personnelType": "Visitor",
      "count": 11
    }
  ],
  "totalVisitedToday": 226,
  "visitedToday": {
    "employees": 174,
    "contractors": 52,
    "total": 226
  }
}
 ],
  "details": {
    "Red Zone - Outer Area": [
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "00:24:59",
        "EmployeeID": "0",
        "ObjectName1": "Patil, Shivanand (Teapoint)",
        "CardNumber": "413971",
        "PersonnelType": "Property Management",
        "zone": "Red Zone - Outer Area",
        "door": "APAC_IN_PUN_PODIUM_ST 1-DOOR 1 (RED)",
        "Direction": "OutDirection"
      }
    ],
    "Tower B": [
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "00:15:01",
        "EmployeeID": "319936",
        "ObjectName1": "Singh, Vineet",
        "CardNumber": "608366",
        "PersonnelType": "Employee",
        "zone": "Tower B",
        "door": "APAC_IN_PUN_TOWER B_MAIN RECEPTION DOOR",
        "Direction": "InDirection"
      },
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "02:31:18",
        "EmployeeID": "318502",
        "ObjectName1": "Nene, Nikhil",
        "CardNumber": "411134",
        "PersonnelType": "Employee",
        "zone": "Tower B",
        "door": "APAC_IN_PUN_TOWER B_RECEPTION RIGHT DOOR",
        "Direction": "OutDirection"
      },
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "04:36:15",
        "EmployeeID": "0",
        "ObjectName1": "Karajagi, Riyaz",
        "CardNumber": "411160",
        "PersonnelType": "Property Management",
        "zone": "Tower B",
        "door": "APAC_IN_PUN_TOWER B_RECEPTION RIGHT DOOR",
        "Direction": "OutDirection"
      },
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "04:19:23",
        "EmployeeID": "0",
        "ObjectName1": "Shaikh, Sharif",
        "CardNumber": "410334",
        "PersonnelType": "Property Management",
        "zone": "Tower B",
        "door": "APAC_IN_PUN_TOWER B_RECEPTION RIGHT DOOR",
        "Direction": "OutDirection"
      },
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "06:26:57",
        "EmployeeID": "0",
        "ObjectName1": "Phukan, Nilmani",
        "CardNumber": "410372",
        "PersonnelType": "Property Management",
        "zone": "Tower B",
        "door": "APAC_IN_PUN_TOWER B_MAIN RECEPTION DOOR",
        "Direction": "InDirection"
      }
    ],
    "2nd Floor, Pune": [
      {
        "Dateonly": "2025-09-10",
        "Swipe_Time": "00:37:40",
        "EmployeeID": "W0026467",
        "ObjectName1": "Khamkar, Shraddha",
        "CardNumber": "620046",
        "PersonnelType": "Contractor",
        "zone": "2nd Floor, Pune",
        "door": "APAC_IN_PUN_2NDFLR_LIFTLOBBY TO RECEPTION EMTRY DOOR_10:05:74",
        "Direction": "InDirection"
      }
    ],
09/10/2025 01:00 AM
Today's Total
226
Today's Employees
174
Today's Contractors
52
Realtime Total
23
Realtime Employees
4
Realtime Contractors
19
this is frontedn 




// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\liveOccupancyController.js


const { DateTime } = require('luxon');
// const { poolConnect, pool, sql } = require('../config/db');
const { sql, getPool } = require('../config/db');

const doorZoneMap = require('../data/doorZoneMap');
const zoneFloorMap = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// track which door→zone keys we've already warned on
const warnedKeys = new Set();

//update
function getTodayString() {
  return DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');
}


function normalizeZoneKey(rawDoor, rawDir) {
  // 1) Ensure it’s a string and trim whitespace
  let door = String(rawDoor || '').trim();

  // 2) Strip any "_HH:MM:SS" or "_XX:XX:XX" suffix (hex codes or times at end)
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');

  // 3) Collapse multiple spaces into one, then uppercase
  door = door.replace(/\s+/g, ' ').toUpperCase();

  // 4) Pick the direction token exactly as doorZoneMap expects
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';

  return `${door}___${dir}`;
}

/** Normalize "Last, First" or "First Last" → lowercase "first last" */
function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

/**
 * Map a swipe’s door+direction → zone using exactly doorZoneMap.
 * If not in doorZoneMap, log once and return "Unknown Zone".
 * If OutDirection but not "Out of office", strip off " Zone" suffix.
 */
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = doorZoneMap[key];

  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('⛔ Unmapped door–direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }

  // If it's an OutDirection but not the real "Out of office", remove trailing " Zone"
  if (rawDir === 'OutDirection' && zone !== 'Out of office') {
    return zone.replace(/\s+Zone$/i, '');
  }

  return zone;
}


// async function fetchNewEvents(since) {
//   // await the shared pool promise instead of poolConnect
//   const pool = await getPool();
//   const req = pool.request();
//   req.input('since', sql.DateTime2, since);

//   // console.log('🔎 [Pune] fetchNewEvents called with since =', since.toISOString());
//   const { recordset } = await req.query(`
//     WITH CombinedQuery AS (
//       SELECT
//        DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       


//         t1.ObjectName1,
//         CASE
//           WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
//           ELSE CAST(t2.Int1 AS NVARCHAR)
//         END AS EmployeeID,
//         t1.ObjectIdentity1 AS PersonGUID,
//         t3.Name AS PersonnelType,
//         COALESCE(
//           TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
//           TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
//           sc.value
//         ) AS CardNumber,
//         t5a.value AS AdmitCode,
//         t5d.value AS Direction,
//         t1.ObjectName2 AS Door
//       FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
//       LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
//       LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
//       LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
//         ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
//       LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
//         ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
//       LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
//         ON t1.XmlGUID = t_xml.GUID
//       LEFT JOIN (
//         SELECT GUID, value
//         FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
//         WHERE Name IN ('Card','CHUID')
//       ) sc ON t1.XmlGUID = sc.GUID
//       WHERE
//         t1.MessageType     = 'CardAdmitted'
//         AND t1.PartitionName2 = 'APAC.Default'
//         AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >@since
//     )
//     SELECT
//       LocaleMessageTime,
//       CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
//       CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
//       EmployeeID,
//       PersonGUID,
//       ObjectName1,
//       PersonnelType,
//       CardNumber,
//       AdmitCode,
//       Direction,
//       Door
//     FROM CombinedQuery
//     ORDER BY LocaleMessageTime ASC;
//   `);

//   // console.log(`📥 [Pune] fetched ${recordset.length} rows:`,
//   // recordset.map(r => r.LocaleMessageTime.toISOString()));

//   return recordset;
// }

// ---------- helper already in file: parseRowUtcDateTime(...) ----------
// (keeps your existing implementation)

// ---------- fetchNewEvents ----------
async function fetchNewEvents(since) {
  const pool = await getPool();
  const req = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
       DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // --- Normalize rows in JS: parse the instant as UTC and compute IST fields deterministically ---
  const normalized = recordset.map(r => {
    const rowDt = parseRowUtcDateTime(r.LocaleMessageTime);
    if (!rowDt || !rowDt.isValid) return null;
    // keep a JS Date representing the canonical instant (UTC)
    r.LocaleMessageTime = rowDt.toJSDate();
    // compute IST calendar values
    r.Dateonly = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    r.Swipe_Time = rowDt.setZone('Asia/Kolkata').toFormat('HH:mm:ss');
    return r;
  }).filter(Boolean);

  return normalized;
}



async function buildOccupancy(allEvents) {
  const current = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zoneRaw = mapDoorToZone(Door, Direction);
    const zone = zoneRaw && zoneRaw.toLowerCase();

    // ─── 1) If we can’t map door+direction to a valid zone, skip this event entirely. ───
    //     (prevents "Unknown Zone" from ever entering uniquePeople/current)
    if (zoneRaw === 'Unknown Zone') {
      // We warned once in mapDoorToZone already; just ignore.
      continue;
    }

    const zoneLower = zoneRaw.toLowerCase();



    // 1) True "Out of office" → full eviction
    if (Direction === 'OutDirection' && zone === 'out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      continue;
    }



    if (Direction === 'OutDirection') {
      // Compare lowercased zone safely
      const zoneLower = String(zone).toLowerCase();

      // Only full eviction when it's the real "Out of office"
      if (zoneLower === 'out of office') {
        uniquePeople.delete(dedupKey);
        delete current[dedupKey];
      } else {
        // Keep the person in current headcount for all other OutDirection cases
        // Update their last-seen metadata (zone, door, Direction)
        uniquePeople.set(dedupKey, PersonnelType);
        current[dedupKey] = {
          Dateonly, Swipe_Time,
          EmployeeID, ObjectName1, CardNumber,
          PersonnelType,
          zone: zoneRaw,
          door: Door,
          Direction
        };
      }
      continue;
    }

    // 3) InDirection → normal check-in
    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType,
        zone: zoneRaw,
        door: Door,
        Direction
      };
      continue;
    }

    // 4) Catch-all eviction
    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  }

  // live headcounts (only from uniquePeople, which has already evicted all true out-of-office)
  let employeeCount = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee', 'Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  // Build zone→people map, but filter out any out-of-office at this final step too
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    const zKey = emp.zone.toLowerCase();
    if (zKey === 'out of office') continue;
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  // zoneDetails
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
    })
  );

  // floorBreakdown
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }


  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        // pick the correct name field (JSON uses "Name")
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);


        // find a matching swipe in current[]
        const matchEvt = Object.values(current).find(e => {
          return normalizePersonName(e.ObjectName1) === expected;
        });

        return {
          ...m,
          present: !!matchEvt,
          zone: matchEvt ? matchEvt.zone : null
        };
      });
      return [role, list];
    })
  );



  return {
    asOf: new Date().toISOString(),
    summary: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, count: d.total })),
    zoneBreakdown: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown: Object.entries(floorMap).map(([f, d]) => ({ floor: f, ...d.byPersonnelType, total: d.total })),
    details: zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    ertStatus,


    personnelBreakdown: (() => {
      const map = new Map();
      // uniquePeople: Map<dedupKey, PersonnelType>
      for (const pt of uniquePeople.values()) {
        map.set(pt, (map.get(pt) || 0) + 1);
      }
      return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
    })(),
  };
}


/**
 * Build “visited today” from the same in‐memory stream
 */
function buildVisitedToday(allEvents) {
  // “Today” in Asia/Kolkata, formatted as “yyyy-MM-dd”
  const today = DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  // Use evt.Dateonly (already “yyyy-MM-dd” in local zone) to pick out today's InDirection swipes
  const todayIns = allEvents.filter(evt => {
    return (
      evt.Direction === 'InDirection' &&
      evt.Dateonly === today
    );
  });

  // Dedupe by PersonGUID → keep the latest swipe
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID;
    const prev = dedup.get(key);
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  // Separate employees vs contractors
  const employees = finalList.filter(e =>
    !['Contractor', 'Terminated Contractor', 'Temp Badge', 'Visitor', 'Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}


// *******************

// ---------- fetchEventsWindow (24-hour window ending at `until`) ----------
async function fetchEventsWindow(until) {
  const pool = await getPool();
  const req = pool.request();
  req.input('until', sql.DateTime2, until);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) <= @until
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > DATEADD(HOUR, -24, @until)
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  const normalized = recordset.map(r => {
    const rowDt = parseRowUtcDateTime(r.LocaleMessageTime);
    if (!rowDt || !rowDt.isValid) return null;
    r.LocaleMessageTime = rowDt.toJSDate();
    r.Dateonly = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    r.Swipe_Time = rowDt.setZone('Asia/Kolkata').toFormat('HH:mm:ss');
    return r;
  }).filter(Boolean);

  return normalized;
}





// Helper: parse row LocaleMessageTime reliably as UTC DateTime (works for Date, epoch, or string)
function parseRowUtcDateTime(val) {
  if (!val) return null;

  // If it's already a JS Date object (some drivers may return Date)
  if (val instanceof Date) {
    return DateTime.fromMillis(val.getTime(), { zone: 'utc' });
  }

  // If it's a number (epoch milliseconds)
  if (typeof val === 'number') {
    return DateTime.fromMillis(val, { zone: 'utc' });
  }

  // Otherwise treat it as a string. Parse explicitly as UTC.
  // SQL/driver produces strings like "2025-09-10T05:26:08.000" (no Z). If we tell luxon "zone: 'utc'"
  // it will interpret that instant as UTC (NOT local) — which is what we want.
  try {
    const s = String(val).trim();
    // prefer fromISO for ISO-like strings, fall back to fromSQL if needed
    let dt = DateTime.fromISO(s, { zone: 'utc' });
    if (!dt.isValid) {
      dt = DateTime.fromSQL(s, { zone: 'utc' });
    }
    if (!dt.isValid) return null;
    return dt;
  } catch (e) {
    return null;
  }
}


// fetch all events for the IST calendar date that contain events up to `atDate` (inclusive)


// ---------- fetchEventsForDate (fetch events in the IST calendar day ending at `atDate`) ----------
async function fetchEventsForDate(atDate) {
  const pool = await getPool();
  const req  = pool.request();

  // Requested IST calendar day (string)
  const dayOnly = DateTime.fromJSDate(atDate, { zone: 'utc' })
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  // IST start-of-day for that date -> convert to UTC for SQL window start
  const startLocal = DateTime.fromISO(dayOnly, { zone: 'Asia/Kolkata' }).startOf('day');
  const startUTC = startLocal.toUTC().toJSDate();

  // Upper bound: use the requested instant as UTC (add 1ms so "< @end" includes exact instant)
  const endUTC = DateTime.fromJSDate(atDate, { zone: 'utc' })
    .plus({ milliseconds: 1 })
    .toUTC()
    .toJSDate();

  req.input('start', sql.DateTime2, startUTC);
  req.input('end',   sql.DateTime2, endUTC);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC) >= @start
        AND DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC) <  @end
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // Normalize and compute IST date/time fields deterministically in JS
  const normalized = recordset.map(r => {
    const rowDt = parseRowUtcDateTime(r.LocaleMessageTime);
    if (!rowDt || !rowDt.isValid) return null;
    r.LocaleMessageTime = rowDt.toJSDate();
    r.Dateonly = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    r.Swipe_Time = rowDt.setZone('Asia/Kolkata').toFormat('HH:mm:ss');
    return r;
  }).filter(Boolean);

  // Defensive post-filter in JS: guarantee every row is exactly on the requested IST day
  const atInstantUtc = DateTime.fromJSDate(atDate, { zone: 'utc' });
  const filtered = normalized.filter(r => {
    const rowDt = DateTime.fromJSDate(r.LocaleMessageTime, { zone: 'utc' });
    const rowIstDate = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    if (rowIstDate !== dayOnly) return false;
    return rowDt <= atInstantUtc;
  });

  return filtered;
}

function buildVisitedForDate(allEvents, atDate) {
  const asOfLocalDate = DateTime.fromJSDate(atDate, { zone: 'utc' })
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  const todayIns = allEvents.filter(evt => evt.Direction === 'InDirection' && evt.Dateonly === asOfLocalDate);

  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID;
    const prev = dedup.get(key);
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(key, e);
    }
  }
  const finalList = Array.from(dedup.values());
  const employees = finalList.filter(e =>
    !['Contractor', 'Terminated Contractor', 'Temp Badge', 'Visitor', 'Property Management'].includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;
  return { employees, contractors, total: finalList.length };
}

// Handler: GET /api/occupancy-at?at=<ISO-8601>
exports.getSnapshotAt = async (req, res) => {
  try {
    const atRaw = req.query.at;
    if (!atRaw) return res.status(400).json({ error: 'missing "at"' });

    const atDate = new Date(atRaw);
    if (Number.isNaN(atDate.getTime())) {
      return res.status(400).json({ error: 'invalid "at" timestamp' });
    }

    // requested IST calendar day (string "yyyy-LL-dd")
    const requestedIstDay = DateTime.fromJSDate(atDate, { zone: 'utc' })
      .setZone('Asia/Kolkata')
      .toFormat('yyyy-LL-dd');

    // fetch SQL rows limited to [IST start .. atDate)
    let events = await fetchEventsForDate(atDate);

    // Final defensive filter: parse each row as UTC instant & ensure IST day equals requested
    events = events.filter(r => {
      const rowDt = parseRowUtcDateTime(r.LocaleMessageTime);
      if (!rowDt) return false;
      return rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd') === requestedIstDay;
    });

    // Build occupancy from strictly filtered events
    const occupancy   = await buildOccupancy(events);
    const visitedStats = buildVisitedForDate(events, atDate);

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = visitedStats;
    occupancy.asOf = atDate.toISOString();

    return res.json(occupancy);
  } catch (err) {
    console.error('getSnapshotAt error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};
// Handler: GET /api/current-occupancy
exports.getCurrentOccupancy = async (req, res) => {
  try {
    const until = new Date();
    const events = await fetchEventsWindow(until);
    const occupancy = await buildOccupancy(events);
    const visitedStats = buildVisitedForDate(events, until);

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = {
      employees: visitedStats.employees,
      contractors: visitedStats.contractors,
      total: visitedStats.total
    };
    occupancy.asOf = until.toISOString();

    return res.json(occupancy);
  } catch (err) {
    console.error('getCurrentOccupancy error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
// *******************


/** Server‐Sent‐Events endpoint */
exports.getLiveOccupancy = async (req, res) => {



  try {
    // wait for the shared pool to be ready
    await getPool();

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    });
    res.write('\n');

    // pull last 24h on startup
    // let lastSeen = new Date(Date.now() - 24*60*60*1000);
    let lastSeen = new Date();
    const events = [];

    const push = async () => {




      // Option B: Recompute date from the JS timestamp in Asia/Kolkata:
      const todayKolkata = DateTime.now().setZone('Asia/Kolkata').toISODate();
      for (let i = events.length - 1; i >= 0; i--) {
        const ts = DateTime.fromJSDate(events[i].LocaleMessageTime, { zone: 'utc' })
          .setZone('Asia/Kolkata')
          .toISODate();
        if (ts !== todayKolkata) {
          events.splice(i, 1);
        }
      }


      //  console.log('🔄 [PUSH] Running at:', new Date().toISOString());
      // console.log('🔍 Last seen swipe time:', lastSeen);


      const fresh = await fetchNewEvents(lastSeen);

      //  console.log('📥 New events fetched:', fresh.length);




      if (fresh.length) {
        // lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        lastSeen = new Date();
        events.push(...fresh);
      }



      // build occupancy + today counts
      const occupancy = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday = {
        employees: todayStats.employees,
        contractors: todayStats.contractors,
        total: todayStats.total
      };




      // add an `id:` so EventSource treats even identical payloads as “new”

      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);


      if (typeof res.flush === 'function') {
        res.flush();
      }

    };
    await push();
    const timer = setInterval(push, 2000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};


