function mapCardTitleToFilterValue(title) {
    if (!title) return "all";
    const t = title.toLowerCase();

    if (t.includes("camera")) return "cameras";
    if (t.includes("archiver")) return "archivers";
    if (t.includes("controller")) return "controllers";
    if (t.includes("ccure")) return "servers";       // CCURE servers
    if (t.includes("db")) return "dbdetails";        // DB servers
    if (t.includes("desktop")) return "pcdetails";
    if (t.includes("total")) return "all";

    return "all";
}




...

// <your original header and variables remain unchanged>

const baseUrl = "http://localhost:80/api/regions";
let refreshInterval = 300000; // 5 minutes
let pingInterval = 60000; // 30 seconds
let countdownTime = refreshInterval / 1000; // Convert to seconds
let currentRegion = "global";
let deviceDetailsCache = {}; // Store previous details to prevent redundant updates
let latestDetails = null; // Cache the latest fetched details

document.addEventListener("DOMContentLoaded", () => {
    fetchData("global"); // Load initial data
    startAutoRefresh("global");

    document.querySelectorAll(".region-button").forEach((button) => {  
        button.addEventListener("click", () => {  
            const region = button.getAttribute("data-region");  
            document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;  
            switchRegion(region);  
        });  
    });  

    document.getElementById("close-modal").addEventListener("click", () => {  
        document.getElementById("modal").style.display = "none";  
    });

    // ---------------------------
    // NEW: Summary card click/dblclick filter behavior
    // Single click: set device-filter to that type and trigger change (show only that type)
    // Double click: set device-filter to 'all' and trigger change (show all)
    // ---------------------------

    (function attachSummaryCardFilterHandlers() {
        const summaryCards = document.querySelectorAll(".summary .card");
        if (!summaryCards || summaryCards.length === 0) return;

        // helper: derive deviceFilter value from card title text
        function mapCardTitleToFilterValue(title) {
            if (!title) return "all";
            const t = title.toLowerCase();
            if (t.includes("camera")) return "cameras";
            if (t.includes("archiver")) return "archivers";
            if (t.includes("controller")) return "controllers";
            // CCURE card shows server totals in summary; map to 'servers'
            if (t.includes("ccure") || t.includes("server") || t.includes("servers")) return "servers";
            if (t.includes("desktop")) return "pcdetails";
            if (t.includes("db")) return "dbdetails";
            if (t.includes("total")) return "all";
            return "all";
        }

        summaryCards.forEach((card) => {
            // make interactive
            card.style.cursor = "pointer";

            let clickTimer = null;
            const clickDelay = 300; // ms

            card.addEventListener("click", (ev) => {
                // set a timer â€” if dblclick occurs, it will clear this
                if (clickTimer) clearTimeout(clickTimer);
                clickTimer = setTimeout(() => {
                    const h3 = card.querySelector("h3");
                    const titleText = h3 ? h3.innerText.trim() : card.innerText.trim();
                    const filterValue = mapCardTitleToFilterValue(titleText);

                    const deviceFilterElem = document.getElementById("device-filter");
                    if (!deviceFilterElem) {
                        console.warn("device-filter element not found. Click will be ignored.");
                        return;
                    }

                    // set filter and dispatch change -> uses your existing listeners
                    deviceFilterElem.value = filterValue;
                    deviceFilterElem.dispatchEvent(new Event("change", { bubbles: true }));
                }, clickDelay);
            });

            card.addEventListener("dblclick", (ev) => {
                // double click -> show all
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                }
                const deviceFilterElem = document.getElementById("device-filter");
                if (!deviceFilterElem) {
                    console.warn("device-filter element not found. Double-click will be ignored.");
                    return;
                }
                deviceFilterElem.value = "all";
                deviceFilterElem.dispatchEvent(new Event("change", { bubbles: true }));
            });
        });
    })();

    // end DOMContentLoaded
});

// rest of your file continues unchanged...

// // --- Camera URL auto-detect helpers ---

function buildUrlFromHints(ip, cameraname = "", hyperlink = "") {
    ip = (ip || "").trim();
    hyperlink = (hyperlink || "").trim();

    // ðŸ”‘ Always prefer Excel's hyperlink if present  
    if (hyperlink && /^https?:\/\//.test(hyperlink)) {  
        return hyperlink;  
    }  

    // Direct IP  
    if (/^\d{1,3}(\.\d{1,3}){3}$/.test(ip)) {  
        return `http://${ip}`;  
    }  

    // Brand-based fallback  
    const name = (cameraname || "").toLowerCase();  
    if (/\bverkada\b/.test(name)) return `https://${ip}/#/login`;  
    if (/\bflir\b/.test(name)) return `http://${ip}/control/userimage.html`;  
    if (/\bhoneywell\b/.test(name)) return `http://${ip}/www/index.html`;  
    if (/axis/.test(name)) return `http://${ip}/view/view.shtml`;  

    return `http://${ip}`;

}

function openCamera(ip, name, hyperlink = "") {
    const url = buildUrlFromHints(ip, name, hyperlink);
    console.log("Opening URL:", url);  // Debug
    window.open(url, "_blank", "noopener");
}

function switchRegion(region) {
    clearExistingIntervals(); // Avoid interval duplication
    currentRegion = region;
    deviceDetailsCache = {};
    fetchData(region);
    startAutoRefresh(region);
}

// Auto-refresh mechanism
function startAutoRefresh(regionName) {
    fetchData(regionName); // Fetch initial data

    clearExistingIntervals();  

    // Start countdown timer  
    window.countdownTimer = setInterval(() => {  
        document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;  
        countdownTime--;  
        if (countdownTime < 0) countdownTime = refreshInterval / 1000;  
    }, 1000);  

    // Refresh summary & details every 5 minutes  
    window.refreshTimer = setInterval(() => {  
        fetchData(regionName);  
        countdownTime = refreshInterval / 1000;  
    }, refreshInterval);  

    // Ping devices every 30 seconds using history API  
    window.pingTimer = setInterval(() => {  
        pingAllDevices(regionName);  
    }, pingInterval);

}

function clearExistingIntervals() {
    clearInterval(window.countdownTimer);
    clearInterval(window.refreshTimer);
    clearInterval(window.pingTimer);
}

// Fetch summary and details together
function fetchData(regionName) {
    Promise.all([
        fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
        fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
    ])
    .then(([summary, details]) => {
        console.log("Summary Data:", summary);
        console.log("Details Data:", details);

        updateSummary(summary);  

        if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {  
            updateDetails(details);  
            deviceDetailsCache = details; // Update cache  
        }  
        // Cache details for pinging  
        latestDetails = details;  
    })  
    .catch((error) => console.error("Error fetching data:", error));

}

/*
Updated pingAllDevices:
Instead of calling a non-existent ping endpoint, we now use the history API to fetch
device history and update each deviceâ€™s status by updating the separate status dot and text.
*/

function copyToClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
        .then(() => {
            alert("IP copied: " + text);
        })
        .catch(err => {
            console.error("Clipboard API failed", err);
            fallbackCopyTextToClipboard(text);
        });
    } else {
        fallbackCopyTextToClipboard(text);
    }
}

function fallbackCopyTextToClipboard(text) {
    // Create a temporary textarea
    const textArea = document.createElement("textarea");
    textArea.value = text;
    // Prevent scrolling to bottom
    textArea.style.position = "fixed";
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.opacity = "0";

    document.body.appendChild(textArea);  
    textArea.focus();  
    textArea.select();  

    try {  
        const successful = document.execCommand("copy");  
        if (successful) {  
            alert("IP copied (fallback): " + text);  
        } else {  
            alert("Fallback copy failed");  
        }  
    } catch (err) {  
        console.error("Fallback copy failed", err);  
        alert("Unable to copy");  
    }  

    document.body.removeChild(textArea);

}

function pingAllDevices(regionName) {
    let details = latestDetails;
    if (!details || !details.details) return;

    fetch("http://localhost/api/devices/history")  
        .then(response => response.json())  
        .then(historyData => {  
            let statusChanged = false;  

            for (const [key, devices] of Object.entries(details.details)) {  
                if (!Array.isArray(devices) || devices.length === 0) continue;  

                devices.forEach((device) => {  
                    const ip = device.ip_address || "N/A";  
                    const card = document.querySelector(`[data-ip="${ip}"]`);  
                    if (!card) return;  

                    // Determine new status from history API if available.  
                    const historyArray = historyData[ip];  
                    let newStatus = (device.status || "offline").toLowerCase();  
                    if (Array.isArray(historyArray) && historyArray.length > 0) {  
                        const latestEntry = historyArray[historyArray.length - 1];  
                        newStatus = (latestEntry.status || "offline").toLowerCase();  
                    }  
                    const currentStatus = card.dataset.status;  

                    // Update UI: update the dot and the text.  
                    const statusDot = card.querySelector(".status-dot");  
                    const statusText = card.querySelector(".status-text");  
                    if (statusDot) {  
                        statusDot.style.backgroundColor = newStatus === "online" ? "green" : "red";  
                        statusDot.classList.remove("online-dot", "offline-dot");  
                        statusDot.classList.add(newStatus === "online" ? "online-dot" : "offline-dot");  
                    }  
                    else {  
                        console.warn(`Status dot element not found for IP: ${ip}`);  
                    }  
                    if (statusText) {  
                        const textColor = newStatus === "online" ? "green" : "red";  

                        statusText.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);  
                        statusText.style.color = textColor;  
                        statusText.style.backgroundColor = "transparent";  
                        statusText.style.padding = "0";  
                        statusText.style.borderRadius = "0";  
                    } else {  
                        console.warn(`Status text element not found for IP: ${ip}`);  
                    }  

                    if (newStatus !== currentStatus) {  
                        statusChanged = true;  
                        card.dataset.status = newStatus;  
                    }  
                });  
            }  

            setTimeout(() => {  
                if (statusChanged) {  
                    fetchData(regionName);  
                }  
            }, 5000);  
        })  
        .catch(error => {  
            console.error("Error fetching device history:", error);  
        });

}

// ... (the rest of your file unchanged, including updateSummary, updateDetails, showModal, scroll handlers, etc.)