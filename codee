// controllers/denversecurityrejection.js

const mssql = require('mssql');

/**
 * Controller: getDenverSecurityRejection
 * - Expects req.query.parts to be a comma-separated list of PartitionName2 values,
 *   e.g. parts=US.CO.OBS.15,US.CO.OBS.14
 *
 * Response JSON:
 * {
 *   securityByFloor: [{ floor: 'Floor 15', count: 4, ids: ['W00...', ...] }, ...],
 *   rejectionsByFloor: [{ floor: 'Floor 15', rejectionCount: 3, cards: ['...'] }, ...],
 *   raw: { /* optional raw rows for debugging */ }
 * }
 *
 * NOTE: adjust sqlConfig to reuse your app-wide pool/config if you have one.
 */

const sqlConfig = {
  user: process.env.DB_USER || 'your_user',
  password: process.env.DB_PASSWORD || 'your_password',
  server: process.env.DB_HOST || 'your_sql_server_host',
  database: process.env.DB_DATABASE || 'ACVSUJournal_00010029',
  port: parseInt(process.env.DB_PORT || '1433', 10),
  options: {
    encrypt: false, // set true if using Azure / encryption
    enableArithAbort: true,
  },
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 }
};

// Security officers list provided by you
const SECURITY_OFFICERS = [
  'W0003901','W0019956','W0023386','W0025278','W0025490',
  'W0025492','W0025493','W0025639','W0026149','W0026151',
  'W0026208','W0026455'
];

function sanitizePartitionList(partsRaw) {
  if (!partsRaw) return null;
  return partsRaw
    .split(',')
    .map(p => p.trim())
    .filter(p => p.length > 0)
    .map(p => p.replace(/'/g, "''")) // basic single-quote escape
    .map(p => `'${p}'`)
    .join(', ');
}

async function getDenverSecurityRejection(req, res) {
  let pool;
  try {
    const partsRaw = req.query.parts; // expected comma separated
    const partsList = sanitizePartitionList(partsRaw);
    if (!partsList) {
      return res.status(400).json({ error: "Missing or invalid 'parts' query param. Example: ?parts=US.CO.OBS.15,US.CO.OBS.14" });
    }

    pool = await mssql.connect(sqlConfig);

    // build a table-valued inline list of security officer IDs
    const secValues = SECURITY_OFFICERS.map(id => `('${id.replace("'", "''")}')`).join(',\n');

    const sql = `
-- Combined query for recent events (last 7 days)
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1      AS ObjectName1,
    t1.ObjectName2      AS Door,
    t1.PartitionName2   AS PartitionName2,
    COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
      sc.value
    ) AS CardNumber,
    t3.Name AS PersonnelType,
    t5_rej.value AS RejectionType,
    t1.MessageType
  FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
  LEFT JOIN [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, value
    FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
    WHERE Name IN ('Card','CHUID')
  ) AS sc
    ON t1.XmlGUID = sc.GUID
  LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    /* both accepted and rejected messages - we want security activity + rejections */
    t1.MessageType IN ('CardAccepted', 'CardRejected')
    AND t1.PartitionName2 IN (${partsList})
    AND CONVERT(DATE,
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)
        ) >= DATEADD(DAY, -7, CONVERT(DATE, GETDATE()))
),

-- Keep only events with a parsed CardNumber
EventsWithCard AS (
  SELECT *, LTRIM(RTRIM(CardNumber)) AS CardNumTrim
  FROM CombinedQuery
  WHERE COALESCE(LTRIM(RTRIM(CardNumber)), '') <> ''
),

-- Latest event per card (so we can approximate where that officer was last seen)
LatestPerCard AS (
  SELECT *
  , ROW_NUMBER() OVER (PARTITION BY CardNumTrim ORDER BY LocaleMessageTime DESC) AS rn
  FROM EventsWithCard
),

-- Security officers dataset (inline)
SecurityList AS (
  SELECT s.ID AS CardNumber FROM (VALUES
    ${secValues}
  ) AS s(ID)
),

-- Match latest security officers to floors
SecurityLatest AS (
  SELECT
    lp.CardNumTrim AS CardNumber,
    lp.PartitionName2,
    lp.LocaleMessageTime,
    'Floor ' + PARSENAME(lp.PartitionName2, 1) AS FloorLabel
  FROM LatestPerCard lp
  INNER JOIN SecurityList sec ON lp.CardNumTrim = sec.CardNumber
  WHERE lp.rn = 1
    AND lp.PartitionName2 IS NOT NULL
),

-- Aggregate security counts and lists per floor
SecurityByFloor AS (
  SELECT
    ISNULL('Floor ' + PARSENAME(PartitionName2, 1), PartitionName2) AS Floor,
    COUNT(DISTINCT CardNumber) AS SecurityCount,
    STRING_AGG(DISTINCT CardNumber, ',') AS SecurityIDs -- requires SQL Server 2017+
  FROM SecurityLatest
  GROUP BY PartitionName2
),

-- Rejection counts per floor (last 7 days)
Rejections AS (
  SELECT
    ISNULL('Floor ' + PARSENAME(PartitionName2, 1), PartitionName2) AS Floor,
    COUNT(*) AS RejectionCount,
    STRING_AGG(DISTINCT COALESCE(CardNumber, '?'), ',') AS Cards
  FROM CombinedQuery
  WHERE MessageType = 'CardRejected' AND COALESCE(LTRIM(RTRIM(CardNumber)), '') <> ''
  GROUP BY PartitionName2
)

SELECT
  (SELECT Floor, SecurityCount, SecurityIDs FROM SecurityByFloor FOR JSON PATH) AS securityJson,
  (SELECT Floor, RejectionCount, Cards FROM Rejections FOR JSON PATH) AS rejectionsJson;
`;

    const result = await pool.request().query(sql);

    // The SQL returns two JSON strings as single-row result
    const row = result.recordset && result.recordset[0];
    let securityByFloor = [];
    let rejectionsByFloor = [];

    if (row) {
      try {
        securityByFloor = row.securityJson ? JSON.parse(row.securityJson) : [];
      } catch (e) {
        securityByFloor = [];
      }
      try {
        rejectionsByFloor = row.rejectionsJson ? JSON.parse(row.rejectionsJson) : [];
      } catch (e) {
        rejectionsByFloor = [];
      }
    }

    return res.json({
      securityByFloor,
      rejectionsByFloor,
      meta: {
        partsRequested: partsRaw,
        securityOfficersCount: SECURITY_OFFICERS.length,
      }
    });

  } catch (err) {
    console.error('denverSecurityRejection error:', err);
    return res.status(500).json({ error: err.message || String(err) });
  } finally {
    try { if (pool) await pool.close(); } catch (e) { /* ignore */ }
  }
}

module.exports = {
  getDenverSecurityRejection
};
