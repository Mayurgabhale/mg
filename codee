
// REPLACE your existing filterData() with this:

function filterData() {
  const rawTypeSel = document.getElementById('device-type').value.toUpperCase();
  // normalize select values to match the Category text in the table
  const typeSel = rawTypeSel === 'PCDETAILS' ? 'PCDETAIL'
                : rawTypeSel === 'DBDETAILS' ? 'DBDETAIL'
                : rawTypeSel;

  const remarkSel = document.getElementById('remark-filter').value.toUpperCase();
  const citySel   = document.getElementById('cityFilter')?.value.toUpperCase() || "ALL";
  const searchTxt = document.getElementById('search-input').value.toUpperCase();

  document.querySelectorAll('#device-table tbody tr').forEach(r => {
    const ip     = r.cells[1].textContent.toUpperCase();
    const name   = r.cells[2].textContent.toUpperCase();
    const type   = r.cells[3].textContent.toUpperCase(); // e.g., CONTROLLER, PCDETAIL, DBDETAIL
    const city   = r.cells[4].textContent.toUpperCase();
    const remark = r.cells[9]?.textContent.toUpperCase();

    const matchesType   = (typeSel === 'ALL' || type === typeSel);
    const matchesRemark = (remarkSel === 'ALL' || remark.includes(remarkSel));
    const matchesCity   = (citySel === 'ALL' || city === citySel);
    const matchesSearch = (ip.includes(searchTxt) || name.includes(searchTxt));

    r.style.display = matchesType && matchesRemark && matchesCity && matchesSearch ? '' : 'none';
  });
}




......


   <option value="pcDetails">Desktop</option>
                <option value="DBDetails">DB Server</option> 
this two are not filte out, what is the issuue check carefully,



            <label for="device-type">Filter by Device Type:</label>
            <select id="device-type" onchange="filterData()">
                <option value="ALL">All</option>
                <option value="CONTROLLER">Controller</option>
                <option value="ARCHIVER">Archiver</option>
                <option value="CAMERA">Camera</option>
                <option value="SERVER">Server</option>
                <option value="pcDetails">Desktop</option>
                <option value="DBDetails">DB Server</option>
            </select>




let deviceUptimeTimers = {};
let deviceDowntimeTimers = {};

let deviceOfflineAlerted = {};
let deviceOnlineAlerted = {};

function notifyWindows(title, message) {
  if (Notification.permission === 'granted') {
    new Notification(title, { body: message });
  } else if (Notification.permission !== 'denied') {
    Notification.requestPermission().then(permission => {
      if (permission === 'granted') {
        new Notification(title, { body: message });
      }
    });
  }

  showToastAlert(title, message);
}


// function notifyWindows(title, message) {
//   showToastAlert(title, message);
// }

function showToastAlert(title, message) {
  const container = document.getElementById('alert-toast-container');

  const toast = document.createElement('div');
  toast.className = 'alert-toast';

  // toast.innerHTML = `
  //   <div class="close-btn" onclick="this.parentElement.remove()">Ã—</div>
  //   <h4>${title}</h4>
  //   <pre>${message}</pre>
  // `;

  toast.innerHTML = `
  <div class="close-btn">Ã—</div>
  <h4>${title}</h4>
  <pre>${message}</pre>
`;

  const closeBtn = toast.querySelector('.close-btn');
  closeBtn.addEventListener('click', () => {
    toast.remove();
  });

  container.appendChild(toast);

  // Auto-remove after 10 seconds
  setTimeout(() => {
    toast.remove();
  }, 180000);
}


function startDowntime(ip, hist, category) {
  const safe = sanitizeId(ip);
  clearInterval(deviceUptimeTimers[safe]);

  const off = hist.filter(e => e.status === 'Offline').pop();
  if (!off) return;

  const t0 = new Date(off.timestamp).getTime();

  deviceOfflineAlerted[safe] = false;  // Reset per event

  deviceDowntimeTimers[safe] = setInterval(() => {
    const secs = Math.floor((Date.now() - t0) / 1000);
    document.getElementById(`downtime-${safe}`).innerText = formatDuration(secs);
    document.getElementById(`downtime-count-${safe}`).innerText = hist.filter(e => e.status === 'Offline').length;
    updateRemarks(ip, hist, null, null);

    // ðŸ”” Notify if offline â‰¥ 3 min
    if (secs >= 180 && !deviceOfflineAlerted[safe]) {
      deviceOfflineAlerted[safe] = true;

      const name = document.getElementById(`name-${safe}`).innerText;
      const type = document.querySelector(`#ip-${safe}`).parentNode.nextElementSibling.textContent;
      const city = document.getElementById(`remark-${safe}`).dataset.city || 'Unknown';

      const title = "âš ï¸ Device Offline â‰¥ 3 min";
      const message =
        `Device Name: ${name}\n` +
        `Device Type: ${category}\n` +
        `Device IP: ${ip}\n` +
        `City: ${city}\n` +
        `Status: Device is Offline\n` +
        `Offline Time: ${formatDuration(secs)}`;

      notifyWindows(title, message);
    }
  }, 1000);
}



function startUptime(ip, hist, category) {
  const safe = sanitizeId(ip);
  clearInterval(deviceDowntimeTimers[safe]);

  const on = hist.filter(e => e.status === 'Online').pop();
  if (!on) return;

  const tOn = new Date(on.timestamp).getTime();

  // Calculate how long it was offline
  const lastOff = hist.slice().reverse().find(e => e.status === 'Offline');
  const offlineSecs = lastOff ? Math.floor((tOn - new Date(lastOff.timestamp)) / 1000) : 0;

  deviceOnlineAlerted[safe] = false;

  if (offlineSecs >= 120 && !deviceOnlineAlerted[safe]) {
    deviceOnlineAlerted[safe] = true;

    const name = document.getElementById(`name-${safe}`).innerText;
    const type = document.querySelector(`#ip-${safe}`).parentNode.nextElementSibling.textContent;
    const city = document.getElementById(`remark-${safe}`).dataset.city || 'Unknown';

    const title = "âœ… Device is Online after 2+ min";
    const message =
      `Device Name: ${name}\n` +
      `Device Type: ${category}\n` +
      `Device IP: ${ip}\n` +
      `City: ${city}`;

    notifyWindows(title, message);
  }

  const t0 = new Date(on.timestamp).getTime();
  deviceUptimeTimers[safe] = setInterval(() => {
    document.getElementById(`uptime-${safe}`).innerText =
      formatDuration(Math.floor((Date.now() - t0) / 1000));
  }, 1000);
}



// Utility to turn an IP (or any string) into a safe DOM-ID fragment
function sanitizeId(str) {
  return (str || '').replace(/[^a-zA-Z0-9]/g, '_');
}

function fetchDeviceData() {
  const region = document.getElementById('region').value;
  fetch(`http://localhost/api/regions/details/${region}`)
    .then(r => r.json())
    .then(d => fetchDeviceHistory(d.details))
    .catch(console.error);
}

function fetchDeviceHistory(details) {
  fetch(`http://localhost/api/devices/history`)
    .then(r => r.json())
    .then(historyData => {
      populateDeviceTable(details, historyData);
      window.deviceHistoryData = historyData;
    })
    .catch(console.error);
}

function populateDeviceTable(details, historyData) {
  const Devices = [];
  const tbody = document.querySelector('#device-table tbody');
  tbody.innerHTML = '';

  const devices = [];
  ['cameras', 'archivers', 'controllers', 'servers', 'pcDetails', 'DBDetails'].forEach(type => {
    (details[type] || []).forEach(dev => {
      const ip = dev.ip_address;
      const safe = sanitizeId(ip);
      // const name      = dev[type.slice(0,-1) + 'name'] || 'Unknown';
      const name = dev.hostname || dev.pc_name || dev[type.slice(0, -1) + 'name'] || dev.name || dev.device_name || dev.ip_address || 'Unknown';
      const category = type.slice(0, -1).toUpperCase();
      const rawHist = historyData[ip] || [];
      const city = dev.city || 'Unknown';
      const hist = filterHistoryForDisplay(rawHist, category);
      const lastRaw = rawHist[rawHist.length - 1]?.status || 'Unknown';
      // if last raw Offline but <5min, treat Online
      let status = lastRaw;
      if (lastRaw === 'Offline' && ((Date.now() - new Date(rawHist[rawHist.length - 1].timestamp)) / 1000) < 300) {
        status = 'Online';
      }
      const downCount = hist.filter(e => e.status === 'Offline').length;

      // devices.push({ ip, safe, name, category, rawHist, hist, status, downCount,city  });
      devices.push({ ip, safe, name, category, rawHist, hist, status, downCount, city, remark: dev.remark || '' });

    });
  });

  // sort by ongoing â‰¥5min offline first, then by downCount desc
  devices.sort((a, b) => {
    const now = Date.now();
    const aLast = a.hist[a.hist.length - 1], bLast = b.hist[b.hist.length - 1];
    const aOff = aLast?.status === 'Offline' ? (now - new Date(aLast.timestamp)) / 1000 : 0;
    const bOff = bLast?.status === 'Offline' ? (now - new Date(bLast.timestamp)) / 1000 : 0;
    if ((aOff >= 300) !== (bOff >= 300)) return aOff >= 300 ? -1 : 1;
    return b.downCount - a.downCount;
  });

  devices.forEach((d, i) => {
    const row = tbody.insertRow();

    // row.classList.add(d.status==='Online' ? 'status-online' : 'status-offline');

    if (d.status === 'Offline') {
      row.classList.add('row-offline');
    } else if (d.status === 'Online') {
      row.classList.add('row-online');
    } else {
      // Optional: handle unknown or other cases
      row.classList.add('row-repair');
    }


    //     row.innerHTML = `
    // <td>${i+1}</td>
    // <td><span id="ip-${d.safe}" class="copy-text" onclick="copyToClipboard('ip-${d.safe}')">${d.ip}</span></td>
    // <td><span id="name-${d.safe}" class="copy-text" onclick="copyToClipboard('name-${d.safe}')">${d.name}</span></td>
    // <td>${d.category}</td>
    // <td id="uptime-${d.safe}">0h/0m/0s</td>
    // <td id="downtime-count-${d.safe}">${d.downCount}</td>
    // <td id="downtime-${d.safe}">0h/0m/0s</td>
    // <td><button class="history-btn" onclick="openDeviceHistory('${d.ip}','${d.name}','${d.category}')">View History</button></td>
    // <td id="remark-${d.safe}">â€“</td>
    // `;


    row.innerHTML = `
<td>${i + 1}</td>
<td><span id="ip-${d.safe}" class="copy-text" onclick="copyToClipboard('ip-${d.safe}')">${d.ip}</span></td>
<td><span id="name-${d.safe}" class="copy-text" onclick="copyToClipboard('name-${d.safe}')">${d.name}</span></td>
<td>${d.category}</td>
<td>${d.city}</td>
<td id="uptime-${d.safe}">0h/0m/0s</td>
<td id="downtime-count-${d.safe}">${d.downCount}</td>
<td id="downtime-${d.safe}">0h/0m/0s</td>
<td><button class="history-btn" onclick="openDeviceHistory('${d.ip}','${d.name}','${d.category}')">View History</button></td>
<td id="remark-${d.safe}" data-city="${d.city}">â€“</td>
`;



    // show policy tooltip on hover for rows with explicit "Not accessible" remark
    // modern hover message for "Not accessible" rows
    if (d.remark && /not\s+access/i.test(d.remark)) {
      row.classList.add('row-not-accessible');

      // create tooltip element
      const tooltip = document.createElement("div");
      tooltip.className = "modern-tooltip";
      tooltip.textContent = "Due to Network policy, this camera is Not accessible";
      row.appendChild(tooltip);
    }


    if (d.status === 'Online') startUptime(d.ip, d.hist, d.category);
    else startDowntime(d.ip, d.hist, d.category);

    updateRemarks(d.ip, d.hist, d.status, d.downCount);
  });



  // âœ… Add this block AFTER `devices.forEach(...)` inside populateDeviceTable
  const cityFilter = document.getElementById('cityFilter');
  if (cityFilter) {
    const uniqueCities = [...new Set(devices.map(dev => dev.city).filter(Boolean))].sort();
    cityFilter.innerHTML = '<option value="all">All Cities</option>';
    uniqueCities.forEach(city => {
      const option = document.createElement('option');
      option.value = city;
      option.textContent = city;
      cityFilter.appendChild(option);
    });
  }

  filterData();


}


document.addEventListener('DOMContentLoaded', () => {
  if (Notification.permission !== 'granted') {
    Notification.requestPermission();
  }

  ['region', 'device-type', 'remark-filter'].forEach(id => {
    document.getElementById(id)?.addEventListener('change', id === 'region' ? fetchDeviceData : filterData);
  });

  document.getElementById('search-input')?.addEventListener('input', filterData);
  document.getElementById('cityFilter')?.addEventListener('change', filterData);

  fetchDeviceData();
});

function showToast(message) {
  const toast = document.getElementById("toast");
  toast.textContent = message;
  toast.className = "toast show";
  setTimeout(() => {
    toast.className = toast.className.replace("show", "");
  }, 2500);
}


function filterData() {

  const typeSel = document.getElementById('device-type').value.toUpperCase();
  const remarkSel = document.getElementById('remark-filter').value.toUpperCase();
  const citySel = document.getElementById('cityFilter')?.value.toUpperCase() || "ALL";
  const searchTxt = document.getElementById('search-input').value.toUpperCase();

  document.querySelectorAll('#device-table tbody tr').forEach(r => {
    const ip = r.cells[1].textContent.toUpperCase();
    const name = r.cells[2].textContent.toUpperCase();
    const type = r.cells[3].textContent.toUpperCase();
    const city = r.cells[4].textContent.toUpperCase();
    const remark = r.cells[9]?.textContent.toUpperCase(); // âœ… Corrected index to 9

    const matchesType = (typeSel === 'ALL' || type === typeSel);
    const matchesRemark = (remarkSel === 'ALL' || remark.includes(remarkSel)); // âœ… Case-insensitive match
    const matchesCity = (citySel === 'ALL' || city === citySel);
    const matchesSearch = (ip.includes(searchTxt) || name.includes(searchTxt));

    r.style.display = matchesType && matchesRemark && matchesCity && matchesSearch ? '' : 'none';
  });

}
