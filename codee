// ---- Replace the "4. Final query" block with this block ----
const query = `
  WITH Hist AS (
    ${unionQueries}
  ),
  PerDay AS (
    -- compute first/last per person per calendar day (based on LocaleMessageTime date)
    SELECT
      PersonGUID,
      CONVERT(date, LocaleMessageTime) AS SwipeDate,
      MIN(LocaleMessageTime) AS FirstSwipe,
      MAX(LocaleMessageTime) AS LastSwipe,
      DATEDIFF(SECOND, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationSeconds
    FROM Hist
    GROUP BY PersonGUID, CONVERT(date, LocaleMessageTime)
  )
  SELECT
    h.*,
    p.FirstSwipe,
    p.LastSwipe,
    p.DurationSeconds
  FROM Hist h
  LEFT JOIN PerDay p
    ON p.PersonGUID = h.PersonGUID
   AND p.SwipeDate = CONVERT(date, h.LocaleMessageTime)
  ${outerFilter}
  ORDER BY LocaleMessageTime ASC;
`;





....


// ---- Replace the simple query/mapping at the end with this mapping ----
const result = await req.query(query);

return result.recordset.map(r => {
  // ensure DurationSeconds is numeric (SQL may return as number or bigint)
  const durSec = r.DurationSeconds != null ? Number(r.DurationSeconds) : null;

  // format HH:MM:SS from seconds in a safe way (handles >24h if it occurs)
  const formatHMS = (secs) => {
    if (secs == null || Number.isNaN(secs)) return null;
    const h = Math.floor(secs / 3600);
    const m = Math.floor((secs % 3600) / 60);
    const s = Math.floor(secs % 60);
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  };

  return {
    ...r,
    // keep raw DurationSeconds (optional) and add readable duration per day
    DurationSeconds: durSec,
    duration: durSec != null ? formatHMS(durSec) : null,
    // normalize FirstSwipe/LastSwipe to ISO strings (if they come back as Date objects)
    FirstSwipe: r.FirstSwipe ? (r.FirstSwipe instanceof Date ? r.FirstSwipe.toISOString() : String(r.FirstSwipe)) : null,
    LastSwipe: r.LastSwipe ? (r.LastSwipe instanceof Date ? r.LastSwipe.toISOString() : String(r.LastSwipe)) : null
  };
});