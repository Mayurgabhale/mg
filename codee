// Handler: GET /api/occupancy-at?at=<ISO-8601>
exports.getSnapshotAt = async (req, res) => {
  try {
    const atRaw = req.query.at;
    if (!atRaw) return res.status(400).json({ error: 'missing "at" query parameter (ISO timestamp required)' });

    // Parse the incoming ISO (frontend sends UTC instant like "2025-09-11T05:30:00.000Z")
    const atDate = new Date(atRaw);
    if (Number.isNaN(atDate.getTime())) {
      return res.status(400).json({ error: 'invalid "at" timestamp' });
    }

    // Convert that instant to the calendar date in Asia/Kolkata (yyyy-LL-dd)
    const asOfLocalDate = DateTime.fromJSDate(atDate, { zone: 'utc' })
      .setZone('Asia/Kolkata')
      .toFormat('yyyy-LL-dd');

    // Compute the UTC window corresponding to that entire local day:
    // Asia/Kolkata 00:00 (start) -> converted to UTC, and Asia/Kolkata 23:59:59.999 (end) -> converted to UTC
    const startUtc = DateTime.fromISO(asOfLocalDate, { zone: 'Asia/Kolkata' })
      .startOf('day')
      .setZone('utc')
      .toJSDate();

    const endUtc = DateTime.fromISO(asOfLocalDate, { zone: 'Asia/Kolkata' })
      .endOf('day')
      .setZone('utc')
      .toJSDate();

    // Fetch events strictly within that UTC window (use the fetchEventsRange helper)
    // make sure fetchEventsRange is defined in this file (it was present in your previous code)
    const events = await fetchEventsRange(startUtc, endUtc);

    // Optionally (defensive): also filter by the SQL Dateonly field if you want to be double-safe
    const filteredEvents = events.filter(evt => String(evt.Dateonly) === asOfLocalDate);

    // Build occupancy and visited stats from the filtered events only
    const occupancy = await buildOccupancy(filteredEvents);
    const visitedStats = buildVisitedForDate(filteredEvents, atDate);

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = {
      employees: visitedStats.employees,
      contractors: visitedStats.contractors,
      total: visitedStats.total
    };

    // Keep the returned `asOf` as the client-requested UTC instant (so frontend still sees the instant it asked for)
    occupancy.asOf = atDate.toISOString();

    return res.json(occupancy);
  } catch (err) {
    console.error('getSnapshotAt error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};






.....

...

function isoToInput(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  const year = d.getFullYear();
  const month = pad(d.getMonth() + 1);
  const day = pad(d.getDate());
  const hours = pad(d.getHours());
  const minutes = pad(d.getMinutes());
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}



.....