// normalize & cheap-match helper
const normalizeZone = (s = '') =>
  s.toString().toLowerCase().replace(/[–—-]/g, '-').replace(/\s+/g, ' ').trim();

const zoneMatches = (value = '', filterZone = '') => {
  if (!value || !filterZone) return false;
  // compare only the floor/area text, not zone color suffixes
  const v = normalizeZone(value);
  const f = normalizeZone(filterZone);
  // make 'podium floor - red zone' match 'podium floor'
  return v.includes(f);
};




....


const members = filterZone
  ? membersRaw.filter(m => {
      // only include present members per your existing rule
      if (!m.present) return false;

      // member-level locations (support different property names)
      const memberLoc = m.zone || m['Base Location'] || m.Floor || m.baseLocation || '';
      // 1) match if member has a live/member location that matches
      if (zoneMatches(memberLoc, filterZone)) return true;

      // 2) only if member has NO location info at all, fall back to role-level base
      const hasMemberLocation = !!(m.zone || m['Base Location'] || m.Floor || m.baseLocation);
      if (!hasMemberLocation && baseLocationByRole[role] && zoneMatches(baseLocationByRole[role], filterZone)) {
        return true;
      }

      return false;
    })
  : membersRaw;




...


const filtered = filterZone
  ? members.filter(m => {
      if (!m.present) return false;
      const memberLoc = m.liveLocation || m.baseLocation || '';
      if (zoneMatches(memberLoc, filterZone)) return true;
      // only use role-level fallback if member has no location properties
      const hasMemberLocation = !!(m.liveLocation || m.baseLocation);
      if (!hasMemberLocation && baseLocationByRole['ERT Team Members'] && zoneMatches(baseLocationByRole['ERT Team Members'], filterZone)) {
        return true;
      }
      return false;
    })
  : members;
