// Replace the entire getSnapshotAt handler with this
exports.getSnapshotAt = async (req, res) => {
  try {
    const atRaw = req.query.at;
    if (!atRaw) return res.status(400).json({ error: 'missing "at" query parameter (ISO timestamp required)' });

    const atDate = new Date(atRaw);
    if (Number.isNaN(atDate.getTime())) {
      return res.status(400).json({ error: 'invalid "at" timestamp' });
    }

    // requested IST calendar day (string "yyyy-LL-dd")
    const requestedIstDay = DateTime.fromJSDate(atDate, { zone: 'utc' })
      .setZone('Asia/Kolkata')
      .toFormat('yyyy-LL-dd');

    // fetch a 24h SQL window ending at atDate (keeps SQL simple/reusable)
    let events = await fetchEventsWindow(atDate);

    // helper: normalize row into a Luxon DateTime (treat LocaleMessageTime as UTC instant)
    const toRowDateTime = (r) => {
      const v = r && r.LocaleMessageTime;
      if (!v) return null;
      // If driver returned a JS Date
      if (v instanceof Date) return DateTime.fromJSDate(v, { zone: 'utc' });
      // If it's a number (epoch ms)
      if (typeof v === 'number') return DateTime.fromMillis(v, { zone: 'utc' });
      // Otherwise try parsing as ISO string and force UTC interpretation
      const s = String(v).trim();
      let dt = DateTime.fromISO(s, { zone: 'utc' });
      if (!dt.isValid) dt = DateTime.fromSQL(s, { zone: 'utc' });
      return dt.isValid ? dt : null;
    };

    // Final defensive filter: keep only rows whose IST calendar-day === requested day
    // AND whose instant <= requested instant (in UTC)
    const atInstantUtc = DateTime.fromJSDate(atDate, { zone: 'utc' });
    events = events.filter(r => {
      const rowDt = toRowDateTime(r);
      if (!rowDt) return false;
      const rowIstDay = rowDt.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
      if (rowIstDay !== requestedIstDay) return false;
      return rowDt <= atInstantUtc;
    });

    // Now build occupancy / visited from strictly filtered events
    const occupancy = await buildOccupancy(events);
    const visitedStats = buildVisitedForDate(events, atDate);

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = visitedStats;
    occupancy.asOf = atDate.toISOString();

    return res.json(occupancy);
  } catch (err) {
    console.error('getSnapshotAt error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};