// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    // Month start/end in Pune local zone
    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    // Today in Pune (string yyyy-LL-dd)
    const todayKolkataStr = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

    // Build all dates in month
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // If requested month is current month, only consider days up to today for attendance math.
    const isRequestedMonthCurrent =
      start.toFormat('yyyy-LL') === DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL');

    const consideredDates = isRequestedMonthCurrent
      ? allDates.filter(d => d <= todayKolkataStr)
      : allDates.slice();

    // ---------- configuration: exclude Sundays from working days ----------
    // Set to true because you said "not come only sunday"
    const excludeSundays = true;
    const consideredDatesFiltered = consideredDates.filter(d => {
      if (!excludeSundays) return true;
      return DateTime.fromISO(d, { zone: 'Asia/Kolkata' }).weekday !== 7; // 7 = Sunday
    });

    // SQL boundaries (UTC)
    const startUtc = start.setZone('utc').toJSDate();
    const endUtc = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    // Fetch events with Card/CHUID (CardNumber)
    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door,
          sc.value AS CardNumber
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC BETWEEN @start AND @end
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    // Normalize to Pune local time and enrich
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Build canonical key function (stable)
    function canonicalKey(e) {
      const guid = (e.PersonGUID || '').toString().trim();
      const card = (e.CardNumber || '').toString().trim();
      const emp  = (e.EmployeeID || '').toString().trim();
      const name = (e.ObjectName1 || '').toString().trim().toLowerCase();
      if (guid) return `g:${guid}`;
      if (card) return `c:${card}`;
      // prefer EmployeeID if it's a meaningful id (not '0' or empty)
      if (emp && emp !== '0') return `e:${emp}`;
      if (name) return `n:${name}`;
      return `unknown`;
    }

    // Containers
    const visitCounter = new Map();     // key -> {count, employeeId, name, personnelType}
    const presenceByPerson = new Map(); // key -> { employeeId, name, personnelType, days:Set }

    // Scan all events once and populate presence & visits
    for (const e of events) {
      const date = e.Dateonly;
      const key = canonicalKey(e);

      // initialize presence record if needed
      if (!presenceByPerson.has(key)) {
        presenceByPerson.set(key, {
          employeeId: e.EmployeeID,
          name: e.ObjectName1,
          personnelType: e.PersonnelType,
          days: new Set()
        });
      }

      // presence: mark day present for ANY event on that date (this counts IN/OUT/null)
      presenceByPerson.get(key).days.add(date);

      // visits: count explicit InDirection swipes only
      if (e.Direction === 'InDirection') {
        if (!visitCounter.has(key)) {
          visitCounter.set(key, {
            count: 0,
            employeeId: e.EmployeeID,
            name: e.ObjectName1,
            personnelType: e.PersonnelType
          });
        }
        visitCounter.get(key).count++;
      }
    }

    // Build dailySummaries & peakOccupancy from events grouped by date (simulate counter)
    const byDateMap = new Map(); // date -> list of events
    for (const ev of events) {
      if (!byDateMap.has(ev.Dateonly)) byDateMap.set(ev.Dateonly, []);
      byDateMap.get(ev.Dateonly).push(ev);
    }

    const dailySummaries = [];
    const peakOccupancy = [];
    for (const d of allDates) {
      const dayEvents = byDateMap.get(d) || [];
      // Unique daily headcount: dedupe per-person for that day using canonicalKey
      const uniqueSet = new Set(dayEvents.map(e => canonicalKey(e)));
      dailySummaries.push({ date: d, total: uniqueSet.size });

      // peak occupancy simulate
      let current = 0, maxCount = 0;
      for (const ev of dayEvents) {
        if (ev.Direction === 'InDirection') current++;
        else if (ev.Direction === 'OutDirection') current = Math.max(0, current - 1);
        // ignore unknown Direction for counter
        if (current > maxCount) maxCount = current;
      }
      peakOccupancy.push({ date: d, peak: maxCount });
    }

    // Compute avg daily headcount over consideredDatesFiltered (excludes Sundays if configured)
    const totalsByDate = Object.fromEntries(dailySummaries.map(d => [d.date, d.total]));
    const consideredTotals = consideredDatesFiltered.map(d => totalsByDate[d] || 0);
    const avgDailyHeadcount = consideredTotals.length
      ? Math.round(consideredTotals.reduce((s, v) => s + v, 0) / consideredTotals.length)
      : 0;

    // Top10 visitors by raw InDirection counts
    const top10Visitors = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({ employeeId: v.employeeId, name: v.name, personnelType: v.personnelType, visits: v.count }));

    // Build attendance sheet rows for every canonical person seen in month
    const attendanceSheet = Array.from(presenceByPerson.values()).map(p => {
      const row = { employeeId: p.employeeId, name: p.name, personnelType: p.personnelType };
      let presentCount = 0;

      for (const d of allDates) {
        const isFuture = (isRequestedMonthCurrent && d > todayKolkataStr);
        if (isFuture) { row[d] = null; continue; }

        // If we exclude Sundays from considered days, mark Sundays as null (not applicable)
        if (excludeSundays && DateTime.fromISO(d, { zone: 'Asia/Kolkata' }).weekday === 7) {
          row[d] = null; // not considered working day
          continue;
        }

        if (p.days.has(d)) { row[d] = 'P'; presentCount++; }
        else { row[d] = 'A'; }
      }

      const workingDaysToDate = consideredDatesFiltered.length;
      const daysAbsent = Math.max(0, workingDaysToDate - presentCount);
      const attendancePercent = workingDaysToDate > 0
        ? ((presentCount / workingDaysToDate) * 100).toFixed(1) + '%'
        : '0.0%';

      row.daysPresent = presentCount;
      row.daysAbsent = daysAbsent;
      row.attendancePercent = attendancePercent;
      return row;
    });

    return res.json({
      month,
      today: todayKolkataStr,
      workingDaysConsidered: consideredDatesFiltered.length,
      avgDailyHeadcount,
      peakOccupancy,
      top10Visitors,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
