// src/components/FloorOccupancyChart.jsx
import React from 'react';
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  Cell,
  LabelList,
  Legend,
  Customized
} from 'recharts';
import { Card } from 'react-bootstrap';
import {
  FaSearch,
  FaStar,
  FaEnvelope,
  FaChartBar,
  FaUsers
} from 'react-icons/fa';
import floorCapacities from '../constants/floorCapacities';

/*
  COLOR PALETTE: distinct gradient pairs for each cylinder (repeats if more floors)
*/
const CYLINDER_COLORS = [
  ['#BEE9FF', '#4DB8FF'], // light -> mid blue
  ['#0B4F8C', '#2F80ED'], // dark -> lighter blue
  ['#F27FA6', '#B93F72'], // pink shades
  ['#FFB84D', '#F26B00'], // orange shades
  ['#C6F28B', '#4DB646']  // green shades
];

/*
  ICONS: map icons per cylinder (repeats if more floors)
*/
const CYLINDER_ICONS = [FaUsers, FaStar, FaEnvelope, FaChartBar, FaSearch];

export default function FloorOccupancyChart({ data = [] }) {
  if (!data.length) {
    return (
      <Card body className="bg-dark text-white">
        No floor data available
      </Card>
    );
  }

  // -------------------------------
  // YOUR LOGIC: enrichment, totals,
  // sorting — left exactly as you had it
  // -------------------------------
  const enriched = data.map((floorObj) => {
    const { floor, total: liveCount } = floorObj;
    const capacity = floorCapacities[floor] ?? 0;
    const usedPct = capacity > 0
      ? ((liveCount / capacity) * 100).toFixed(1)
      : '0.0';
    return {
      ...floorObj,           // includes breakdown fields: employees, contractors, etc.
      capacity,
      liveCount,
      usedPct: Number(usedPct),
      label: `${liveCount}/${capacity}`
    };
  });

  // 2) Compute “Pune Office Total” across all floors
  const totalLive = enriched.reduce((sum, f) => sum + f.liveCount, 0);
  const totalCap = enriched.reduce((sum, f) => sum + f.capacity, 0);
  const totalUsedPct = totalCap > 0
    ? ((totalLive / totalCap) * 100).toFixed(1)
    : '0.0';

  const totalEntry = {
    floor: 'Pune Office Total',
    liveCount: totalLive,
    capacity: totalCap,
    usedPct: Number(totalUsedPct),
    label: `${totalLive}/${totalCap}`
  };

  // 3) Sort floors by liveCount descending, then prepend “Pune Office Total”
  const sortedFloors = [...enriched].sort((a, b) => b.liveCount - a.liveCount);
  const chartData = [totalEntry, ...sortedFloors];

  // 4) Determine the maximum capacity to set Y-axis domain
  const maxCapacity = Math.max(...chartData.map(f => f.capacity)) || 0;

  // 5) Custom tooltip to show raw counts, percentages, and breakdown (left intact)
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload?.length) return null;
    const floorObj = payload[0].payload;
    const { liveCount, capacity, usedPct } = floorObj;

    const breakdownEntries = Object.entries(floorObj).filter(
      ([key]) =>
        !['floor', 'liveCount', 'capacity', 'usedPct', 'label'].includes(key)
    );

    return (
      <div
        style={{
          backgroundColor: '#1a1a1a',
          color: '#FFD100',
          border: '1px solid var(--wu-yellow)',
          borderRadius: 4,
          padding: '0.75rem',
          minWidth: 200
        }}
      >
        <div style={{ marginBottom: 4, fontSize: '1rem' }}>
          <strong>Floor: {floorObj.floor}</strong>
        </div>
        <div style={{ marginBottom: 6, fontWeight: 'bold', fontSize: '0.9rem' }}>
          Live: {liveCount} / {capacity} ({usedPct}%)
        </div>
        {breakdownEntries.map(([type, value]) => (
          <div
            key={type}
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              marginTop: 2,
              color: '#fff',
              fontSize: '0.85rem'
            }}
          >
            <span style={{ opacity: 0.8 }}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </span>
            <span style={{ fontWeight: 'bold' }}>{value}</span>
          </div>
        ))}
      </div>
    );
  };

  // -------------------------------
  // Cylinder shape (single cylinder per floor)
  // Recharts calls this with props: x, y, width, height, payload, etc.
  // We derive the index by matching payload.floor in chartData.
  // -------------------------------
  const CylinderShape = (props) => {
    const { x, y, width, height, payload } = props;
    const floorName = payload && payload.floor;
    const idx = chartData.findIndex(d => d.floor === floorName);
    const colorPair = CYLINDER_COLORS[idx % CYLINDER_COLORS.length];
    const fill = `url(#cyl-grad-${idx})`;

    const cx = x + width / 2;
    const topRy = Math.max(8, width * 0.12);
    const bottomRy = Math.max(10, width * 0.14);
    const bottomY = y + height;

    // icon and two-digit number
    const Icon = CYLINDER_ICONS[idx % CYLINDER_ICONS.length];
    const displayNumber = String(idx + 1).padStart(2, '0');

    return (
      <g>
        {/* shadow under the cylinder */}
        <ellipse
          cx={cx}
          cy={bottomY + bottomRy * 0.9}
          rx={width * 0.62}
          ry={bottomRy * 0.45}
          fill="rgba(0,0,0,0.25)"
        />
        {/* cylinder body */}
        <rect
          x={x}
          y={y}
          width={width}
          height={height}
          rx={12}
          ry={12}
          fill={fill}
          stroke="rgba(255,255,255,0.06)"
          strokeWidth={1}
        />
        {/* top ellipse */}
        <ellipse
          cx={cx}
          cy={y}
          rx={width / 2}
          ry={topRy}
          fill={fill}
          stroke="rgba(255,255,255,0.12)"
          strokeWidth={1}
        />
        {/* bottom ellipse for 3D look */}
        <ellipse
          cx={cx}
          cy={bottomY}
          rx={width / 2}
          ry={bottomRy}
          fill="rgba(255,255,255,0.03)"
        />

        {/* Icon + number + percentage / label inside cylinder using SVG text (keeps everything SVG, robust) */}
        <g transform={`translate(${cx}, ${y + height * 0.36})`} textAnchor="middle" fill="#ffffff">
          {/* icon (drawn with path via react-icons->svg) */}
          {Icon && (
            <g transform="translate(-12, -6)">
              {/* Render icon as an inline SVG element - using react icon component */}
              <Icon />
            </g>
          )}

          <text x="0" y="30" fontSize="20" fontWeight="700" fill="#fff">
            {displayNumber}
          </text>

          <text x="0" y="52" fontSize="11" fill="rgba(255,255,255,0.9)">
            {payload && payload.label ? payload.label : ''}
          </text>
        </g>
      </g>
    );
  };

  // -------------------------------
  // Curve overlay that passes exactly through the top centers of the bars
  // Customized component receives xAxisMap and yAxisMap we can use for exact pixel coords
  // -------------------------------
  const CurveOverlay = ({ width, height, xAxisMap, yAxisMap }) => {
    // xAxisMap and yAxisMap may have keys; use first key
    const xKey = Object.keys(xAxisMap || {})[0];
    const yKey = Object.keys(yAxisMap || {})[0];

    if (!xKey || !yKey) return null;

    const xScale = xAxisMap[xKey].scale; // ordinal scale for x (domain of floors)
    const yScale = yAxisMap[yKey].scale; // linear scale for y values

    // For each data point compute pixel coordinates for the top center of the cylinder:
    const points = chartData.map((d, i) => {
      // For ordinal band scales, xScale(d.floor) gives start; bandwidth() gives width
      const x = xScale(d.floor) + (xScale.bandwidth ? xScale.bandwidth() / 2 : 0);
      // y for top of cylinder: use liveCount value
      const y = yScale(d.liveCount);
      return { x, y, label: String.fromCharCode(65 + i) };
    });

    if (points.length < 2) return null;

    // Build a smooth path using cubic/smooth Quadratic bezier approach
    // We'll construct a path that flows through the points — create intermediate control points
    const pathParts = [];
    pathParts.push(`M ${points[0].x} ${points[0].y}`);

    for (let i = 1; i < points.length; i++) {
      const prev = points[i - 1];
      const cur = points[i];
      const midX = (prev.x + cur.x) / 2;
      const midY = (prev.y + cur.y) / 2;
      // Quadratic from prev to mid using prev as control point gives smoothness
      pathParts.push(`Q ${prev.x} ${prev.y} ${midX} ${midY}`);
    }
    // finish to last point
    const last = points[points.length - 1];
    pathParts.push(`T ${last.x} ${last.y}`);
    const path = pathParts.join(' ');

    return (
      <g>
        {/* faint grey helper line */}
        <path d={path} fill="none" stroke="#cccccc" strokeWidth={2} strokeOpacity={0.6} />

        {/* bright accent line on top */}
        <path d={path} fill="none" stroke="#FFD100" strokeWidth={3} strokeOpacity={0.9} strokeLinecap="round" />

        {/* markers and letters */}
        {points.map((p, idx) => (
          <g key={`marker-${idx}`}>
            <circle cx={p.x} cy={p.y} r={5} fill="#ffffff" />
            <text x={p.x} y={p.y - 10} textAnchor="middle" fontSize={12} fontWeight="700" fill="#333">
              {p.label}
            </text>
            {/* thin vertical drop line to cylinder top (like sample) */}
            <line x1={p.x} y1={p.y - 4} x2={p.x} y2={p.y + 20} stroke="rgba(0,0,0,0.12)" strokeWidth={1} />
          </g>
        ))}
      </g>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center fw-bold" style={{ borderBottom: '2px solid var(--wu-yellow)', fontSize: '1.2rem' }}>
        Western Union-Pune Headcount against Occupancy
      </Card.Header>

      <Card.Body style={{ height: '60vh', padding: 0, backgroundColor: 'var(--wu-gray-dark)' }}>
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            margin={{ top: 60, right: 24, left: 20, bottom: 40 }}
            barCategoryGap="20%"
          >
            {/* define per-cylinder gradients */}
            <defs>
              {chartData.map((_, idx) => {
                const [c1, c2] = CYLINDER_COLORS[idx % CYLINDER_COLORS.length];
                return (
                  <linearGradient id={`cyl-grad-${idx}`} key={`cyl-grad-${idx}`} x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stopColor={c1} stopOpacity={1} />
                    <stop offset="100%" stopColor={c2} stopOpacity={1} />
                  </linearGradient>
                );
              })}
            </defs>

            <CartesianGrid stroke="#444" strokeDasharray="3 3" />
            <XAxis
              dataKey="floor"
              tick={{ fontSize: 12, fill: '#fff' }}
              interval={0}
              height={80}
            />
            <YAxis
              tick={{ fontSize: 13, fill: '#fff' }}
              domain={[0, Math.ceil(maxCapacity / 50) * 50]}
            />

            <Tooltip content={renderTooltip} />

            <Legend
              verticalAlign="top"
              align="center"
              wrapperStyle={{ color: '#fff', paddingBottom: 8 }}
              payload={[
                { value: 'Live HeadCount (Infographic)', type: 'square', color: '#4DB8FF' }
              ]}
            />

            {/*
              SINGLE BAR: each datum -> one cylinder drawn by CylinderShape
              barSize controls how wide the cylinders are visually
            */}
            <Bar dataKey="liveCount" barSize={110} shape={<CylinderShape />}>
              {chartData.map((d, idx) => (
                <Cell key={`cyl-cell-${idx}`} fill={`url(#cyl-grad-${idx})`} />
              ))}
              {/* optional LabelList placed on top (raw count) */}
              <LabelList
                dataKey="liveCount"
                position="top"
                formatter={(val) => val}
                style={{ fill: '#fff', fontSize: 13, fontWeight: '700' }}
              />
            </Bar>

            {/* overlay: curve passing through top-centers */}
            <Customized component={(props) => <CurveOverlay {...props} />} />
          </BarChart>
        </ResponsiveContainer>
      </Card.Body>
    </Card>
  );
}