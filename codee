Not disply only today: 
Highest inconsistency: 15 on Floor 14
Floor	In Swipes	Out Swipes	In − Out	Security	Rejection (Today)
Floor 14	269	254	15	0	0
Floor 15	37	27	10	0	4
Floor 01	15	6	9	1	9
Floor 13	165	160	5	0	1
Floor 11	147	142	5	0	0
Floor 12	203	198	5	0	22
Floor 09	128	124	4	0	5
Floor 06	86	82	4	0	9

I want to disply one today in table 

http://localhost:5000/api/rejections
{
  "summary": [
    {
      "floor": "Floor 12",
      "rejectionCount": 22
    },
    {
      "floor": "Floor 1",
      "rejectionCount": 9
    },
    {
      "floor": "Floor 6",
      "rejectionCount": 9
    },
    {
      "floor": "Floor 15",
      "rejectionCount": 4
    },
    {
      "floor": "Floor 9",
      "rejectionCount": 5
    },
    {
      "floor": "Floor 13",
      "rejectionCount": 1
    }
  ],
  "dateWise": [
    {
      "date": "2025-09-16",
      "floors": [
        {
          "floor": "Floor 12",
          "rejectionCount": 7
        },
        {
          "floor": "Floor 1",
          "rejectionCount": 2
        }
      ]
    },
    {
      "date": "2025-09-15",
      "floors": [
        {
          "floor": "Floor 6",
          "rejectionCount": 3
        },
        {
          "floor": "Floor 12",
          "rejectionCount": 2
        },
        {
          "floor": "Floor 1",
          "rejectionCount": 2
        }
      ]
    },
    {
      "date": "2025-09-12",
      "floors": [
        {
          "floor": "Floor 1",
          "rejectionCount": 1
        },
        {
          "floor": "Floor 15",
          "rejectionCount": 3
        }
      ]
    },
    {
      "date": "2025-09-11",
      "floors": [
        {
          "floor": "Floor 12",
          "rejectionCount": 10
        },
        {
          "floor": "Floor 9",
          "rejectionCount": 5
        },
        {
          "floor": "Floor 13",
          "rejectionCount": 1
        }
      ]
    },
    {
      "date": "2025-09-10",
      "floors": [
        {
          "floor": "Floor 6",
          "rejectionCount": 5
        },
        {
          "floor": "Floor 12",
          "rejectionCount": 1
        },
        {
          "floor": "Floor 1",
          "rejectionCount": 2
        }
      ]
    },
    {
      "date": "2025-09-09",
      "floors": [
        {
          "floor": "Floor 6",
          "rejectionCount": 1
        },
        {
          "floor": "Floor 12",
          "rejectionCount": 2
        },
        {
          "floor": "Floor 1",
          "rejectionCount": 2
        },
        {
          "floor": "Floor 15",
          "rejectionCount": 1
        }
      ]
    }
  ],
  "details": [
    {
      "LocaleMessageTime": "2025-09-16T13:39:11.000Z",
      "DateOnly": "2025-09-16T00:00:00.000Z",
      "SwipeTime": "1970-01-01T13:39:11.000Z",
      "CardNumber": "618861",
      "PersonnelType": "Employee",
      "Location": "US.CO.OBS",
      "Door": "US.CO.HQ. 12. South Lobby Doors-IN",
      "RejectionType": "CardDisabled",
      "floor": "Floor 12"
    },
    {
      "LocaleMessageTime": "2025-09-16T13:38:51.000Z",
      "DateOnly": "2025-09-16T00:00:00.000Z",
      "SwipeTime": "1970-01-01T13:38:51.000Z",
      "CardNumber": "618861",
      "PersonnelType": "Employee",
      "Location": "US.CO.OBS",
      "Door": "US.CO.HQ. 12. North Lobby Doors-IN",
      "RejectionType": "CardDisabled",
      "floor": "Floor 12"
    },
    {
      "LocaleMessageTime": "2025-09-16T13:38:42.000Z",
      "DateOnly": "2025-09-16T00:00:00.000Z",





// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\denverRejection.js
const { denver } = require("../config/siteConfig");
const doorFloorMap = require("../data/denverDoorFloorMap");
const normalizeKey = require("../data/normalizeKey");

// helper: regex fallback to extract floor number from Door string
function extractFloorFromDoor(door) {
  if (!door) return "Unknown";
  const match = door.match(/HQ\.\s*(\d{2})\./i);
  if (match) {
    return `Floor ${parseInt(match[1], 10)}`;
  }
  return "Unknown";
}

async function getRejections(req, res) {
  try {
    const pool = await denver.poolPromise;

    const query = `
      WITH CombinedQuery AS (
        SELECT
          DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
          t1.ObjectName1      AS ObjectName1,
          t1.ObjectName2      AS Door,
          t1.PartitionName2   AS PartitionName2,
          COALESCE(
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
            sc.value
          )                    AS CardNumber,
          t3.Name              AS PersonnelType,
          t5_rej.value         AS RejectionType
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
        LEFT JOIN [ACVSCore].[Access].[Personnel] AS t2
          ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
          ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] AS t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) AS sc
          ON t1.XmlGUID = sc.GUID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] AS t5_rej
          ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
        WHERE
          t1.MessageType = 'CardRejected'
          AND t1.PartitionName2 = 'US.CO.OBS'
          AND CONVERT(DATE,
               DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)
              ) >= DATEADD(DAY, -7, CONVERT(DATE, GETDATE()))
      )
      SELECT
        LocaleMessageTime,
        CONVERT(date, LocaleMessageTime)    AS DateOnly,
        CONVERT(time(0), LocaleMessageTime) AS SwipeTime,
        CardNumber,
        PersonnelType,
        PartitionName2                     AS Location,
        Door,
        RejectionType
      FROM CombinedQuery
      ORDER BY LocaleMessageTime DESC;
    `;

    const result = await pool.request().query(query);

    // Post-process in JS
    const details = result.recordset.map(r => {
      let floor = "Unknown";

      try {
        const [doorRaw, dirRaw] = (r.Door || "").split("___");
        const normKey = normalizeKey(doorRaw || "", dirRaw || "");
        const mapped = doorFloorMap[normKey];

        if (mapped && mapped !== "Out of office") {
          floor = mapped;
        } else {
          floor = extractFloorFromDoor(r.Door);
        }
      } catch (e) {
        console.warn("Failed to resolve floor for door:", r.Door, e.message);
      }

      return { ...r, floor };
    });

    // Floor-wise rejection count (all days combined)
    const summary = details.reduce((acc, row) => {
      if (row.floor !== "Unknown") {
        if (!acc[row.floor]) acc[row.floor] = 0;
        acc[row.floor]++;
      }
      return acc;
    }, {});
    const summaryArr = Object.entries(summary).map(([floor, rejectionCount]) => ({
      floor,
      rejectionCount,
    }));

    // Date + Floor-wise rejection count
    const dateWiseMap = {};
    details.forEach(row => {
      if (row.floor === "Unknown") return;
      const date = row.DateOnly.toISOString().split("T")[0]; // yyyy-mm-dd
      if (!dateWiseMap[date]) dateWiseMap[date] = {};
      if (!dateWiseMap[date][row.floor]) dateWiseMap[date][row.floor] = 0;
      dateWiseMap[date][row.floor]++;
    });

    const dateWiseArr = Object.entries(dateWiseMap).map(([date, floors]) => ({
      date,
      floors: Object.entries(floors).map(([floor, rejectionCount]) => ({
        floor,
        rejectionCount,
      })),
    }));

    res.json({
      summary: summaryArr,
      dateWise: dateWiseArr,
      details,
    });
  } catch (err) {
    console.error("Error fetching rejection data:", err);
    res.status(500).send("Server Error");
  }
}

module.exports = { getRejections };






// src/components/FloorInOutTable.jsx
// (only showing the full component for completeness — replace your file with this)
import React, { useEffect, useMemo, useState } from 'react';
import { Card, Table, Modal, OverlayTrigger, Tooltip } from 'react-bootstrap';

// Accent palette
const ROW_COLORS = [
  '#FFC72C', '#C9A9A6', '#FFE680',
  '#FFF5EE', '#FFD11A', '#96DED1', '#FFEB99'
];

// Security Employee IDs (hardcoded)
const SECURITY_IDS = [
  "W0023386", "W0026455", "W0028120"
].map(id => id.toUpperCase());

const normalizeId = v => String(v || '').trim().toUpperCase();

// normalize floor names so "Floor 01" == "Floor 1"
const normalizeFloorName = (f) => {
  if (!f && f !== 0) return '';
  return String(f).replace(/^Floor\s0*/, 'Floor ').trim();
};

export default function FloorInOutTable({
  data = [],
  floorBreakdown = [],
  floorInOutSummary = []
}) {
  const securitySet = useMemo(() => new Set(SECURITY_IDS), []);

  // Security modal state
  const [showSecurityModal, setShowSecurityModal] = useState(false);
  const [selectedFloorSecurity, setSelectedFloorSecurity] = useState(null);
  const [selectedPeopleSecurity, setSelectedPeopleSecurity] = useState([]);

  // Rejection state (we'll only store *today*'s rejections)
  const [rejectionDetails, setRejectionDetails] = useState({}); // { normFloor -> [records...] }
  const [rejectionSummaryMap, setRejectionSummaryMap] = useState({}); // { normFloor -> count }
  const [rejectionsLoading, setRejectionsLoading] = useState(false);

  // Build securityByFloor from occupants & inOnlyPersons
  const securityByFloor = useMemo(() => {
    const byFloor = {};

    (floorBreakdown || []).forEach(fb => {
      const people = [];
      (fb.occupants || []).forEach(o => {
        const empId = normalizeId(o.EmployeeID);
        if (securitySet.has(empId)) people.push(o);
      });
      if (people.length) {
        byFloor[fb.floor] = (byFloor[fb.floor] || []).concat(people);
      }
    });

    (floorInOutSummary || []).forEach(f => {
      (f.inOnlyPersons || []).forEach(pid => {
        const empId = normalizeId(pid);
        if (securitySet.has(empId)) {
          byFloor[f.floor] = (byFloor[f.floor] || []).concat([
            { EmployeeID: empId, ObjectName1: "(Unknown)", Swipe_Time: "—", Door: "—", PersonnelType: "—" }
          ]);
        }
      });
    });

    return byFloor;
  }, [floorBreakdown, floorInOutSummary, securitySet]);

  // --- NEW: fetch rejections and keep only today's (Denver) records ---
  useEffect(() => {
    let mounted = true;

    async function loadRejectionsTodayOnly() {
      setRejectionsLoading(true);
      try {
        const res = await fetch('/api/rejections');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();

        // Determine "today" in Denver (YYYY-MM-DD)
        const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });

        const allDetails = Array.isArray(payload.details) ? payload.details : [];

        // Filter to only today's records using LocaleMessageTime (fallback to DateOnly)
        const detailsToday = allDetails.filter(d => {
          const dtRaw = d.LocaleMessageTime || d.DateOnly || d.LocaleMessageTime;
          if (!dtRaw) return false;
          try {
            const dt = new Date(dtRaw);
            const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
            return dtStr === todayDenver;
          } catch (e) {
            // fallback: try to take first 10 chars if it's an ISO-like string
            const maybeDate = String(dtRaw).slice(0, 10);
            return maybeDate === todayDenver;
          }
        });

        // Build detailsByFloor grouped by normalized floor key (prefer d.floor then d.Location)
        const detailsByFloor = {};
        detailsToday.forEach(d => {
          const rawFloor = d.floor || d.Floor || d.Location || '';
          const normFloorFromRecord = normalizeFloorName(rawFloor);
          const key = normFloorFromRecord || normalizeFloorName(d.Location || '') || 'Unknown';
          detailsByFloor[key] = detailsByFloor[key] || [];
          detailsByFloor[key].push(d);
        });

        // Build summaryMap from detailsToday (today only)
        const summaryMap = {};
        Object.entries(detailsByFloor).forEach(([floorKey, arr]) => {
          summaryMap[floorKey] = arr.length;
        });

        if (!mounted) return;
        setRejectionSummaryMap(summaryMap);
        setRejectionDetails(detailsByFloor);
      } catch (err) {
        console.error('Failed to load rejections:', err);
        if (mounted) {
          setRejectionSummaryMap({});
          setRejectionDetails({});
        }
      } finally {
        if (mounted) setRejectionsLoading(false);
      }
    }

    loadRejectionsTodayOnly();
    return () => { mounted = false; };
  }, []);

  // Build sorted rows and attach securityCount & rejectionCount (today only)
  const sorted = useMemo(() => {
    const rows = (Array.isArray(data) ? data : []).map(({ floor, inSwipes, outSwipes }) => {
      const normFloor = normalizeFloorName(floor);
      return {
        floor,
        normFloor,
        inSwipes: Number(inSwipes || 0),
        outSwipes: Number(outSwipes || 0),
        inconsistency: Number(inSwipes || 0) - Number(outSwipes || 0),
        securityCount: (securityByFloor[floor] || []).length,
        rejectionCount: rejectionSummaryMap[normFloor] || 0
      };
    });
    return rows.sort((a, b) => b.inconsistency - a.inconsistency);
  }, [data, securityByFloor, rejectionSummaryMap]);

  const top = sorted[0];

  const handleSecurityCellClick = (floor) => {
    const people = securityByFloor[floor] || [];
    if (people.length > 0) {
      setSelectedFloorSecurity(floor);
      setSelectedPeopleSecurity(people);
      setShowSecurityModal(true);
    }
  };

  // Tooltip content uses rejectionDetails (already filtered to today)
  const renderRejectionTooltip = (floor) => {
    const nf = normalizeFloorName(floor);
    const byFloor = rejectionDetails[nf] || [];
    if (!byFloor.length) return 'No rejections today';
    const lines = [`Total today: ${byFloor.length}`, '', 'Recent:'];
    byFloor.slice(0, 6).forEach(d => {
      const date = d.LocaleMessageTime ? d.LocaleMessageTime.slice(0,10) : (d.DateOnly ? d.DateOnly.slice(0,10) : '');
      const time = d.SwipeTime || (d.LocaleMessageTime ? d.LocaleMessageTime.slice(11,19) : '');
      lines.push(`${date} ${time} — ${d.RejectionType || ''}`);
    });
    if (byFloor.length > 6) lines.push(`… +${byFloor.length - 6} more`);
    return lines.join('\n');
  };

  return (
    <>
      <Card className="mb-4 shadow-sm" style={{ background: '#1a1a1a', border: '2px solid #FFC72C' }}>
        <Card.Header className="text-center fw-bold" style={{ background: '#000', color: '#FFC72C' }}>
          Floor In vs Out Swipe Summary (Rejections — Today)
        </Card.Header>

        <Card.Body style={{ height: 450, padding: '1rem', overflowY: 'auto' }}>
          {top && (
            <div className="mb-3" style={{ color: '#fff', fontSize: '1rem' }}>
              Highest inconsistency:&nbsp;
              <span style={{ color: '#FFC72C', fontWeight: 'bold' }}>{top.inconsistency}</span>
              &nbsp;on&nbsp;
              <span style={{ color: '#FFC72C', fontWeight: 'bold' }}>{top.floor}</span>
            </div>
          )}

          <Table striped bordered hover size="sm" variant="dark" className="mb-0">
            <thead>
              <tr>
                <th>Floor</th>
                <th>In Swipes</th>
                <th>Out Swipes</th>
                <th>In − Out</th>
                <th>Security</th>
                <th>Rejection (Today)</th>
              </tr>
            </thead>

            <tbody>
              {sorted.map((row, idx) => (
                <tr key={row.floor} style={{ backgroundColor: row.securityCount > 0 ? '#333300' : undefined }}>
                  <td style={{ color: '#fff' }}>{row.floor}</td>
                  <td style={{ color: ROW_COLORS[idx % ROW_COLORS.length] }}>{row.inSwipes}</td>
                  <td style={{ color: ROW_COLORS[(idx + 1) % ROW_COLORS.length] }}>{row.outSwipes}</td>
                  <td style={{ color: ROW_COLORS[(idx + 2) % ROW_COLORS.length], fontWeight: 'bold' }}>
                    {row.inconsistency}
                  </td>

                  {/* Security cell - clickable only this cell */}
                  <td
                    style={{
                      color: row.securityCount > 0 ? '#FFC72C' : '#aaa',
                      fontWeight: row.securityCount > 0 ? 'bold' : 'normal',
                      cursor: row.securityCount > 0 ? 'pointer' : 'default',
                      textDecoration: row.securityCount > 0 ? 'underline' : 'none'
                    }}
                    onClick={() => { if (row.securityCount > 0) handleSecurityCellClick(row.floor); }}
                  >
                    {row.securityCount}
                  </td>

                  {/* Rejection cell (today only) */}
                  <td style={{
                    color: row.rejectionCount > 0 ? '#FFCCCB' : '#aaa',
                    fontWeight: row.rejectionCount > 0 ? 'bold' : 'normal',
                    cursor: row.rejectionCount > 0 ? 'help' : 'default'
                  }}>
                    {row.rejectionCount > 0 ? (
                      <OverlayTrigger
                        placement="top"
                        overlay={<Tooltip id={`rej-tip-${row.floor.replace(/\s+/g,'_')}`}>{renderRejectionTooltip(row.normFloor || row.floor)}</Tooltip>}
                      >
                        <span>{row.rejectionCount}</span>
                      </OverlayTrigger>
                    ) : 0}
                  </td>
                </tr>
              ))}
            </tbody>
          </Table>
        </Card.Body>
      </Card>

      {/* Security Modal */}
      <Modal show={showSecurityModal} onHide={() => setShowSecurityModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title>Security Occupants - {selectedFloorSecurity}</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Table striped bordered hover size="sm">
            <thead>
              <tr>
                <th>EmployeeID</th>
                <th>Name</th>
                <th>Swipe Time</th>
                <th>Door</th>
                <th>Type</th>
              </tr>
            </thead>
            <tbody>
              {selectedPeopleSecurity.map((p, idx) => (
                <tr key={idx}>
                  <td>{p.EmployeeID}</td>
                  <td>{p.ObjectName1 || "(Unknown)"}</td>
                  <td>{p.Swipe_Time || "—"}</td>
                  <td>{p.Door || "—"}</td>
                  <td>{p.PersonnelType || "—"}</td>
                </tr>
              ))}
            </tbody>
          </Table>
        </Modal.Body>
      </Modal>
    </>
  );
}
