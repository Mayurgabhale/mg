['region', 'device-type', 'remark-filter'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;

    if (id === 'region') {
      el.addEventListener('change', fetchDeviceData);
    } else if (id === 'device-type') {
      el.addEventListener('change', () => {
        filterData();
        updateCityFilter();
      });
    } else {
      // remark-filter
      el.addEventListener('change', filterData);
    }
  });



...

// ---------- MOVE/ADD: global updateCityFilter() ----------
function updateCityFilter() {
  const cityFilter = document.getElementById('cityFilter');
  if (!cityFilter) return;

  // Get selected device type from the device-type select (normalized to uppercase)
  const selectedType = (document.getElementById('device-type').value || 'ALL').toUpperCase();

  // Collect cities from table rows that match the selected device type.
  const citiesSet = new Set();
  document.querySelectorAll('#device-table tbody tr').forEach(r => {
    const rowType = (r.cells[3]?.textContent || '').trim().toUpperCase(); // displayCategory column
    const rowCity = (r.cells[4]?.textContent || '').trim();
    if (!rowCity) return;

    // If 'ALL' selected, include all cities; otherwise only include if row type matches.
    if (selectedType === 'ALL' || rowType === selectedType) {
      citiesSet.add(rowCity);
    }
  });

  const uniqueCities = Array.from(citiesSet).sort((a,b) => a.localeCompare(b));

  // Preserve previous selection where possible
  const previous = cityFilter.value;

  cityFilter.innerHTML = '<option value="all">All Cities</option>';
  uniqueCities.forEach(city => {
    const opt = document.createElement('option');
    opt.value = city;
    opt.textContent = city;
    cityFilter.appendChild(opt);
  });

  // If the previous value still exists, keep it; otherwise reset to 'all'
  if (previous && Array.from(cityFilter.options).some(o => o.value === previous)) {
    cityFilter.value = previous;
  } else {
    cityFilter.value = 'all';
  }
}