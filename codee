// src/components/FloorOccupancyChart.jsx
import React, { useMemo } from 'react';
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  Cell,
  LabelList,
  Legend,
  Customized
} from 'recharts';
import { Card, Row, Col, Badge } from 'react-bootstrap';
import { FaUsers } from 'react-icons/fa';
import './FloorOccupancyChart.css';
import floorCapacities from '../constants/floorCapacities';

/* Design palettes */
const CYLINDER_PALETTES = [
  ['#CFEFFF', '#4DB8FF'],
  ['#DDEBFF', '#2F80ED'],
  ['#FFDEE1', '#E74C7C'],
  ['#FFF1D6', '#FF9A3D'],
  ['#E6FCD7', '#46C853']
];

export default function FloorOccupancyChart({ data = [] }) {
  if (!data || !data.length) {
    return (
      <Card body className="bg-dark text-white no-data-card">
        No floor data available
      </Card>
    );
  }

  // enrich with capacity, usedPct, label, and breakdown fields preserved
  const enriched = useMemo(() => {
    return data.map(item => {
      const floor = item.floor;
      const liveCount = Number(item.total || item.liveCount || 0);
      const capacity = Number(floorCapacities[floor] ?? 0);
      const usedPct = capacity > 0 ? Number(((liveCount / capacity) * 100).toFixed(1)) : 0;
      return {
        ...item,
        floor,
        liveCount,
        capacity,
        usedPct,
        label: `${liveCount}/${capacity}`
      };
    });
  }, [data]);

  // compute totals and sorted data
  const totalLive = enriched.reduce((s, f) => s + f.liveCount, 0);
  const totalCap = enriched.reduce((s, f) => s + f.capacity, 0);
  const totalPct = totalCap > 0 ? Number(((totalLive / totalCap) * 100).toFixed(1)) : 0;

  const sorted = [...enriched].sort((a, b) => b.liveCount - a.liveCount);
  const chartData = [{ floor: 'Pune Office Total', liveCount: totalLive, capacity: totalCap, usedPct: totalPct, label: `${totalLive}/${totalCap}`, ...{} }, ...sorted];

  // axis max — scale using max live count for nicer visuals
  const maxLive = Math.max(...chartData.map(d => d.liveCount), ...chartData.map(d => d.capacity)) || 10;
  const yMax = Math.ceil(maxLive * 1.15 / 10) * 10;

  // Tooltip content
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload?.length) return null;
    const d = payload[0].payload;
    const entries = Object.entries(d)
      .filter(([k]) => !['floor', 'liveCount', 'capacity', 'usedPct', 'label'].includes(k));
    return (
      <div className="fo-tooltip">
        <div className="fo-tooltip-title">{d.floor}</div>
        <div className="fo-tooltip-main">{d.liveCount} / {d.capacity} &nbsp; <span className="fo-tooltip-pct">({d.usedPct}%)</span></div>
        <div className="fo-tooltip-breakdown">
          {entries.map(([k, v]) => (
            <div key={k} className="fo-row">
              <span className="fo-key">{k.charAt(0).toUpperCase() + k.slice(1)}</span>
              <span className="fo-val">{v}</span>
            </div>
          ))}
        </div>
      </div>
    );
  };

  /*
    Cylinder shape: tall rectangle with top ellipse (3D feel), a subtle gloss,
    a little capacity label centered inside, and a small percent badge above.
  */
  const CylinderShape = (props) => {
    const { x, y, width, height, payload } = props;
    const idx = chartData.findIndex(c => c.floor === payload.floor);
    const [c1, c2] = CYLINDER_PALETTES[idx % CYLINDER_PALETTES.length];

    const cx = x + width / 2;
    const topRy = Math.max(6, width * 0.12);
    const bottomRy = Math.max(10, width * 0.14);
    const bottomY = y + height;

    const gradId = `cgrad-${idx}`;

    return (
      <g>
        {/* defs placed here for unique gradient per cylinder */}
        <defs>
          <linearGradient id={gradId} x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stopColor={c1} stopOpacity="1" />
            <stop offset="100%" stopColor={c2} stopOpacity="1" />
          </linearGradient>
          <linearGradient id={`gloss-${idx}`} x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stopColor="rgba(255,255,255,0.45)" />
            <stop offset="35%" stopColor="rgba(255,255,255,0.08)" />
            <stop offset="100%" stopColor="rgba(255,255,255,0.02)" />
          </linearGradient>
        </defs>

        {/* soft shadow under cylinder */}
        <ellipse cx={cx} cy={bottomY + bottomRy * 0.9} rx={width * 0.6} ry={bottomRy * 0.45} fill="rgba(0,0,0,0.22)" />

        {/* main body */}
        <rect x={x} y={y} width={width} height={height} rx={12} ry={12} fill={`url(#${gradId})`} stroke="rgba(255,255,255,0.06)" strokeWidth={1} />

        {/* top oval (gives roundness) */}
        <ellipse cx={cx} cy={y + topRy * 0.24} rx={width / 2} ry={topRy * 0.9} fill={`url(#${gradId})`} opacity={0.92} />

        {/* gloss overlay */}
        <rect x={x} y={y} width={width} height={height * 0.45} rx={12} ry={12} fill={`url(#gloss-${idx})`} opacity={0.65} />

        {/* bottom ellipse */}
        <ellipse cx={cx} cy={bottomY} rx={width / 2} ry={bottomRy} fill="rgba(255,255,255,0.03)" />

        {/* centered label (live/cap) */}
        <text x={cx} y={y + height / 2 + 6} textAnchor="middle" fontSize={Math.max(12, Math.round(width * 0.16))} fontWeight="700" fill="#0c1220">
          {payload.label}
        </text>

        {/* percent badge above the cylinder */}
        <g transform={`translate(${cx}, ${y - 12})`}>
          <rect x={-28} y={-18} width={56} height={26} rx={14} fill="#111827" opacity={0.9} stroke="rgba(255,255,255,0.06)" />
          <text x="0" y={-2} textAnchor="middle" fontSize={11} fontWeight="700" fill="#FFD100">
            {payload.usedPct}% used
          </text>
        </g>
      </g>
    );
  };

  // Curve overlay: draws smooth path through top-centers using provided scales (recharts Customized props)
  const CurveOverlay = (props) => {
    const { xAxisMap, yAxisMap } = props;
    if (!xAxisMap || !yAxisMap) return null;
    const xKey = Object.keys(xAxisMap)[0];
    const yKey = Object.keys(yAxisMap)[0];
    const xScale = xAxisMap[xKey].scale;
    const yScale = yAxisMap[yKey].scale;
    if (!xScale || !yScale) return null;

    const points = chartData.map(d => {
      // center of the bar's category
      const x = xScale(d.floor) + (xScale.bandwidth ? xScale.bandwidth() / 2 : 0);
      const y = yScale(d.liveCount);
      return { x, y };
    });
    if (points.length < 2) return null;

    // create smooth cubic path (simple approach)
    let path = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const p0 = points[i - 1];
      const p1 = points[i];
      const midX = (p0.x + p1.x) / 2;
      path += ` Q ${p0.x} ${p0.y} ${midX} ${(p0.y + p1.y) / 2}`;
    }
    const last = points[points.length - 1];
    path += ` T ${last.x} ${last.y}`;

    return (
      <g>
        <path d={path} fill="none" stroke="rgba(255,255,255,0.14)" strokeWidth={4} strokeDasharray="8 8" />
        <path d={path} fill="none" stroke="#FFD100" strokeWidth={3} strokeLinecap="round" strokeOpacity={0.9} />
      </g>
    );
  };

  return (
    <Card className="fo-card">
      <Card.Header className="fo-header">
        <div className="fo-title">
          <FaUsers /> &nbsp; Western Union — Pune Headcount vs Occupancy
        </div>

        <div className="fo-kpis">
          <div className="kpi">
            <div className="kpi-label">Total Live</div>
            <div className="kpi-value">{totalLive.toLocaleString()}</div>
            <div className="kpi-sub">of {totalCap.toLocaleString()} capacity</div>
          </div>
          <div className="kpi">
            <div className="kpi-label">Utilization</div>
            <div className="kpi-value">{totalPct}%</div>
            <div className="kpi-sub">office average</div>
          </div>
        </div>
      </Card.Header>

      <Card.Body className="fo-body">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            margin={{ top: 12, right: 24, left: 24, bottom: 60 }}
            barCategoryGap="18%"
          >
            <XAxis dataKey="floor" tick={{ fill: '#E6E6E6', fontSize: 12 }} tickLine={false} axisLine={false} interval={0} height={80} />
            <YAxis tick={{ fill: '#E6E6E6', fontSize: 12 }} axisLine={false} tickLine={false} domain={[0, yMax]} />
            <Tooltip content={renderTooltip} />
            <Legend verticalAlign="top" align="right" wrapperStyle={{ color: '#fff', paddingRight: 12 }} payload={[{ value: 'Live Headcount', type: 'square', color: CYLINDER_PALETTES[0][1] }]} />

            <Bar dataKey="liveCount" barSize={120} animationDuration={900} shape={<CylinderShape />}>
              {chartData.map((entry, idx) => (
                <Cell key={`cell-${idx}`} fill={`url(#cgrad-${idx})`} />
              ))}
              <LabelList dataKey="liveCount" position="top" formatter={(v) => v} style={{ fill: '#fff', fontWeight: 800 }} />
            </Bar>

            <Customized component={(props) => <CurveOverlay {...props} />} />
          </BarChart>
        </ResponsiveContainer>
      </Card.Body>
    </Card>
  );
}






....

/* FloorOccupancyChart.css */
.fo-card {
  border-radius: 12px;
  overflow: hidden;
  background: linear-gradient(180deg, #0b0f14 0%, #0f1419 100%);
  border: 1px solid rgba(255,209,0,0.04);
  color: #fff;
  min-height: 420px;
  box-shadow: 0 12px 40px rgba(2,6,23,0.6);
}

.fo-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 18px;
  background: linear-gradient(90deg, rgba(0,0,0,0.35), rgba(0,0,0,0.12));
  border-bottom: 1px solid rgba(255,209,0,0.06);
}

.fo-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 700;
  color: #FFD100;
  font-size: 1.05rem;
}

.fo-kpis {
  display: flex;
  gap: 14px;
  align-items: center;
}

.kpi {
  background: rgba(255,255,255,0.03);
  padding: 8px 12px;
  border-radius: 10px;
  text-align: right;
  min-width: 130px;
  box-shadow: inset 0 -3px 6px rgba(0,0,0,0.45);
}
.kpi-label { font-size: 0.78rem; color: rgba(255,255,255,0.7); }
.kpi-value { font-size: 1.15rem; font-weight: 800; color: #fff; margin-top: 4px; }
.kpi-sub { font-size: 0.72rem; color: rgba(255,255,255,0.45); margin-top: 2px; }

/* Chart body */
.fo-body {
  height: 56vh; /* allow breathing room; adjust as needed */
  padding: 12px 8px;
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.04));
}

/* Tooltip style */
.fo-tooltip {
  background: linear-gradient(180deg, #0f1720, #0b0f14);
  border: 1px solid rgba(255,209,0,0.16);
  color: #fff;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
}
.fo-tooltip-title { font-weight: 800; color: #FFD100; margin-bottom: 4px; }
.fo-tooltip-main { font-weight: 700; margin-bottom: 6px; color: #fff; }
.fo-tooltip-pct { color: #9AE6B4; font-weight: 700; }
.fo-row { display:flex; justify-content:space-between; gap:12px; margin-top:6px; color:#E6E6E6; }
.fo-key { opacity: 0.85; }
.fo-val { font-weight:700; }

/* small responsive tweaks */
@media (max-width: 900px) {
  .fo-body { height: 52vh; }
  .fo-kpis { display: none; } /* hide KPIs on small screens for space */
}