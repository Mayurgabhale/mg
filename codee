// helper: return current Denver datetime as an ISO-like string "YYYY-MM-DDTHH:MM:SS"
function getDenverNowIsoString() {
  const fmt = new Intl.DateTimeFormat('en-CA', {
    timeZone: 'America/Denver',
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit',
    hour12: false
  });
  const parts = fmt.formatToParts(new Date());
  const m = {};
  parts.forEach(p => { if (p.type !== 'literal') m[p.type] = p.value; });
  // format parts into ISO-like string (always zero-padded by Intl)
  return `${m.year}-${m.month}-${m.day}T${m.hour}:${m.minute}:${m.second}`;
}





.....


..

// replace your applySnapshot with this updated version
const applySnapshot = async () => {
  if (!snapshotTime) {
    setSnapshotError('Select a time first.');
    return;
  }
  if (!snapshotDate) {
    setSnapshotError('Select a date first.');
    return;
  }

  // Ensure time has seconds (append :00 if only HH:MM)
  const timeForApi = snapshotTime.length === 5 ? `${snapshotTime}:00` : snapshotTime;

  // Build Denver-local ISO-like strings (no timezone suffix) and compare lexicographically
  const snapshotIso = `${snapshotDate}T${timeForApi}`;             // e.g. "2025-09-17T07:00:00"
  const nowDenverIso = getDenverNowIsoString();                    // current Denver like "2025-09-17T04:30:12"

  // If snapshot time is strictly in the future relative to Denver now -> block
  if (snapshotIso > nowDenverIso) {
    const msg = 'Please select a relevant time â€” snapshot cannot be in the future (Denver local time).';
    setSnapshotError(msg);
    // small popup to alert user immediately
    window.alert(msg);
    return;
  }

  setSnapshotLoading(true);
  setSnapshotError(null);

  try {
    const url = `http://localhost:5000/api/occupancy-at-time-denver?date=${encodeURIComponent(snapshotDate)}&time=${encodeURIComponent(timeForApi)}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`${resp.status} ${resp.statusText} - ${txt}`);
    }
    const json = await resp.json();

    // Store snapshot payload
    setSnapshotData(json);

    // set visitedOccupants from snapshot (if present)
    setVisitedOccupants(json.visitedOccupants || []);

    // activate snapshot mode
    setSnapshotMode(true);
  } catch (err) {
    console.error('Failed to fetch snapshot:', err);
    setSnapshotError(err.message || 'Failed to fetch snapshot');
    setSnapshotData(null);
    setSnapshotMode(false);
  } finally {
    setSnapshotLoading(false);
  }
};
