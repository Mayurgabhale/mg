// ── Routing logic ──────────────────────────────────────────────────────────
const segments = location.pathname.split('/').filter(Boolean);
const isPartitionPage = segments[0] === 'partition' && Boolean(segments[1]);
const currentPartition = isPartitionPage ? decodeURIComponent(segments[1]) : '';
// preserve everything after the partition segment (e.g. "details", "history", etc.)
const suffixSegments = isPartitionPage ? segments.slice(2) : [];

// ... flagMap etc ...

const handlePartitionChange = newPartition => {
  if (!newPartition) return navigate('/');
  // build the base path for the new partition
  let path = `/partition/${encodeURIComponent(newPartition)}`;
  // if we had suffix segments (like "details" or "history/123"), preserve them
  if (suffixSegments.length) {
    path += '/' + suffixSegments.join('/');
  }
  navigate(path);
};

const handleDetailsClick = () => {
  if (isPartitionPage) {
    // keep any existing suffix (if already details, this will effectively re-navigate to same path)
    const suffix = suffixSegments.length ? '/' + suffixSegments.join('/') : '';
    // ensure we end up on <partition>/details — override or append details
    // replace any existing suffix with 'details' (so /partition/X/history -> /partition/X/details)
    // simpler: always navigate explicitly to details
    navigate(`/partition/${encodeURIComponent(currentPartition)}/details`);
  } else {
    navigate('/partition/US.CO.OBS/details');
  }
};






....
in this one problme in 
<IconButton onClick={handleDetailsClick} color="inherit">
              <InfoIcon />
            </IconButton>
get this http://localhost:3000/partition/US.CO.OBS/details this is correct but
after in select box i select 
Miami
New York
 Austin Texas

we got this http://localhost:3000/partition/US.FL.Miami, but this is wrong 

but we require this http://localhost:3000/partition/US.FL.Miami/details

i hove you understand 
when i click on on this i got this problme, 



// src/components/Header.jsx

// ── ALL IMPORTS AT THE VERY TOP ───────────────────────────────────────────────
import React, { useEffect, useState } from 'react';

// MUI core + pickers
import {
  AppBar,
  Toolbar,
  Box,
  Typography,
  Select,
  MenuItem,
  IconButton,
  Popover,
  TextField,
  Button
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { DatePicker, TimePicker } from '@mui/x-date-pickers';

// Day.js + plugins
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';

// React Router
import { useNavigate, useLocation, Link } from 'react-router-dom';

// Icons
import HomeIcon from '@mui/icons-material/Home';
import HistoryIcon from '@mui/icons-material/History';
import InfoIcon from '@mui/icons-material/Info';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import LiveTvIcon from '@mui/icons-material/LiveTv';

// Assets & hooks
import WuLogo from '../assets/wu-logo.png';
import DenverFlag from '../assets/flags/denver.png';
import MiamiFlag from '../assets/flags/miami.png';
import NewYorkFlag from '../assets/flags/new-york.png';
import AustinFlag from '../assets/flags/austin.png';
import DefaultFlag from '../assets/flags/default.png';

import { partitionList } from '../services/occupancy.service';
import { useLiveOccupancy } from '../hooks/useLiveOccupancy';

// ── Initialize Day.js UTC/timezone ────────────────────────────────────────────
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.tz.setDefault('UTC');

// ── Display name map ─────────────────────────────────────────────────────────
const displayNameMap = {
  'US.CO.OBS': 'Denver',
  'US.FL.Miami': 'Miami',
  'US.NYC': 'New York',
  'USA/Canada Default': 'Austin Texas'
};

// ── Header Component ──────────────────────────────────────────────────────────
export default function Header({
  title,
  mode,
  onTimeSelect,
  onLiveClick
}) {
  const navigate = useNavigate();
  const location = useLocation();
  const { data } = useLiveOccupancy(1000);

  const [lastUpdate, setLastUpdate] = useState('');
  const [anchorEl, setAnchorEl] = useState(null);
  const [draftDate, setDraftDate] = useState(dayjs().utc());

  // Update the “last update” timestamp on each live fetch
  useEffect(() => {
    if (data) setLastUpdate(new Date().toLocaleTimeString());
  }, [data]);

  // ── Routing logic ──────────────────────────────────────────────────────────
  const segments = location.pathname.split('/').filter(Boolean);
  const isPartitionPage = segments[0] === 'partition' && Boolean(segments[1]);
  const currentPartition = isPartitionPage ? decodeURIComponent(segments[1]) : '';
  const suffixSegments = isPartitionPage ? segments.slice(2) : [];

  const flagMap = {
    'US.CO.OBS': DenverFlag,
    'US.FL.Miami': MiamiFlag,
    'US.NYC': NewYorkFlag,
    'USA/Canada Default': AustinFlag
  };
  const selectedFlag = flagMap[currentPartition] || DefaultFlag;



  // Detect if we’re currently on any “history” page
  const isHistoryPage = location.pathname.includes('/history');

  const handlePartitionChange = newPartition => {
    if (!newPartition) return navigate('/');
    // Always point at the new partition
    let path = `/partition/${encodeURIComponent(newPartition)}`;
    // If we were on “history”, keep the history view
    if (isHistoryPage) path += '/history';
    navigate(path);
  };


  const handleDetailsClick = () => {
    if (isPartitionPage) {
      navigate(`/partition/${encodeURIComponent(currentPartition)}/details`);
    } else {
      navigate('/partition/US.CO.OBS/details');
    }
  };

  // ── Date/Time popover handlers ─────────────────────────────────────────────
  const openPopover = e => {
    setDraftDate(dayjs().utc());
    setAnchorEl(e.currentTarget);
  };
  const closePopover = () => setAnchorEl(null);
  const handleGo = () => {
    onTimeSelect(draftDate.toISOString());
    closePopover();
  };

  return (
    <>
      <AppBar position="static" color="primary" sx={{ mb: 2 }}>
        <Toolbar sx={{ justifyContent: 'space-between', alignItems: 'center' }}>

          {/* ── Left: logo, title, nav & time/live icons ── */}
          <Box display="flex" alignItems="center" sx={{ flexGrow: 1 }}>
            <Box component="img" src={WuLogo} alt="WU Logo" sx={{ height: 36, mr: 2 }} />

            <Typography variant="h6" sx={{ fontWeight: 600, mr: 3 }}>
              {title}
              {currentPartition ? ` • ${displayNameMap[currentPartition]}` : ''}
            </Typography>

            <IconButton
              component={Link}
              to={isPartitionPage ? `/partition/${encodeURIComponent(currentPartition)}` : '/'}
              color="inherit"
            >
              <HomeIcon />
            </IconButton>

    
 <IconButton
   component={Link}
   to={
     currentPartition
       ? `/partition/${encodeURIComponent(currentPartition)}/history`
       : '/history'
   }
   color="inherit"
 >
   <HistoryIcon />
 </IconButton>

            <IconButton onClick={handleDetailsClick} color="inherit">
              <InfoIcon />
            </IconButton>

            <IconButton
              color={mode === 'time' ? 'secondary' : 'inherit'}
              onClick={openPopover}
              title="Jump to specific time"
            >
              <AccessTimeIcon />
            </IconButton>  

            <IconButton
              color={mode === 'live' ? 'secondary' : 'inherit'}
              onClick={onLiveClick}
              title="Return to live"
            >
              <LiveTvIcon />
            </IconButton>
          </Box>

          {/* ── Right: region selector, flag, last-update/historic label ── */}
          <Box display="flex" alignItems="center" gap={1}>
            <Select
              size="small"
              value={currentPartition}
              displayEmpty
              onChange={e => handlePartitionChange(e.target.value)}
              sx={{ bgcolor: 'background.paper', mr: 1, minWidth: 160 }}
            >
              <MenuItem value="">— Select Region —</MenuItem>
              {partitionList.map(p => (
                <MenuItem key={p} value={p}>
                  {displayNameMap[p] || p}
                </MenuItem>
              ))}
            </Select>

            <Box component="img" src={selectedFlag} alt="Flag" sx={{ height: 32, mr: 2 }} />

            <Typography variant="body2" sx={{ color: '#FFF' }}>
              {mode === 'live'
                ? `Last update: ${lastUpdate}`
                : 'Viewing historic'}
            </Typography>
          </Box>
        </Toolbar>
      </AppBar>

      <Popover
        open={Boolean(anchorEl)}
        anchorEl={anchorEl}
        onClose={closePopover}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Box p={2} display="flex" flexDirection="column" gap={2}>
          <LocalizationProvider dateAdapter={AdapterDayjs}>
            <DatePicker
              label="Select Date (UTC)"
              value={draftDate}
              onChange={newVal => setDraftDate(newVal)}
              renderInput={props => <TextField {...props} />}
            />
            <TimePicker
              label="Select Time (UTC)"
              value={draftDate}
              onChange={newVal => setDraftDate(newVal)}
              renderInput={props => <TextField {...props} />}
            />
          </LocalizationProvider>
          <Box display="flex" justifyContent="flex-end" gap={1}>
            <Button onClick={closePopover}>Cancel</Button>
            <Button variant="contained" onClick={handleGo}>Go</Button>
          </Box>
        </Box>
      </Popover>
    </>
  );
}















//C:\Users\W0024618\Desktop\namer-occupancy-frontend\namer-occupancy-frontend\src\pages\PartitionDetailDetails.jsx

import React, { useEffect, useState, useMemo } from "react";
import { fetchHistory } from "../api/occupancy.service";
import {
  Container,
  Box,
  Typography,
  Button,
  TextField,
  TableContainer,
  Paper,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@mui/material";
import { useParams, useNavigate } from "react-router-dom";
import Header from "../components/Header";
import Footer from "../components/Footer";
import LoadingSpinner from "../components/LoadingSpinner";
import DataTable from "../components/DataTable";
import { fetchLiveSummary } from "../api/occupancy.service";
import { lookupFloor } from "../utils/floorLookup";

export default function PartitionDetailDetails() {
  const { partition } = useParams();
  const navigate = useNavigate();
  const [mode, setMode] = useState("live");

  const [details, setDetails] = useState([]);
  const [liveCounts, setLiveCounts] = useState({});
  const [loading, setLoading] = useState(false);
  const [lastUpdate, setLastUpdate] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [expandedFloor, setExpandedFloor] = useState(null);

  


  // handler when user jumps to a historic timestamp
  const handleTimeSelect = async isoTimestamp => {
    setMode("time");
    setLoading(true);
    // Assuming you have an API that can return summary/details at a given ISO time:

  const json = await fetchHistory(partition, isoTimestamp);

  // defensive: if `realtime` or that partition key is missing, default to empty
    // defensive: if `realtime` or that partition key is missing, default to empty


  //  const partitionRealtime = json.realtime?.[partition] ?? {};
  //   setLiveCounts(partitionRealtime.floors ?? {});

    
     // stamp each record with its computed floor
   const detRaw = json.details.filter(
      r => r.PartitionName2 === partition && r.Direction === "InDirection"
    );
    const det = detRaw.map(r => ({
      ...r,
      floor: lookupFloor(partition, r.Door, r.Direction)
    }));
    setDetails(det);


 // **recompute counts** based on your stamped floors
 const counts = det.reduce((acc, r) => {
   const f = r.floor || "Unknown";
   acc[f] = (acc[f] || 0) + 1;
   return acc;
 }, {});
 setLiveCounts(counts);


    
    setLastUpdate(new Date(isoTimestamp).toLocaleTimeString());
    setLoading(false);  
  };
  // handler to go back to live mode
  const handleLiveClick = () => {
    setMode("live");
    // you could also fire your original live-fetch effect immediately:
    fetchLiveSummary().then(json => {
      setLiveCounts(json.realtime[partition]?.floors || {});

     // stamp each record with its computed floor
    const detRaw = json.details.filter(
      r => r.PartitionName2 === partition && r.Direction === "InDirection"
    );
    const det = detRaw.map(r => ({
      ...r,
      floor: lookupFloor(partition, r.Door, r.Direction)
    }));
    setDetails(det);


      setLastUpdate(new Date().toLocaleTimeString());
    });
  };


  // Initial load
  useEffect(() => {
    let isMounted = true;
    setLoading(true);
    fetchLiveSummary().then(json => {
      if (!isMounted) return;
      const counts = json.realtime[partition]?.floors || {};
      setLiveCounts(counts);

   
      // details already stamped with .floor by your backend — just filter & use that
      const det = json.details.filter(
        r => r.PartitionName2 === partition && r.Direction === "InDirection"
      );


      setDetails(det);
      setLastUpdate(new Date().toLocaleTimeString());
      setLoading(false);
    });
    return () => {
      isMounted = false;
    };
  }, [partition, mode]);
  // Auto-refresh
  useEffect(() => {
    const interval = setInterval(async () => {


      let json;

      if (mode === "live") {
        // live mode: fetch the latest
        json = await fetchLiveSummary();
      } else {
        // time mode: do nothing (or optionally skip)
        return;
      }

      // now json is always defined for live mode:
      setLiveCounts(json.realtime[partition]?.floors || {});

      const det = json.details.filter(
        r => r.PartitionName2 === partition && r.Direction === "InDirection"
      );
      setDetails(det);
      setLastUpdate(new Date().toLocaleTimeString());




    }, 1000);
    return () => clearInterval(interval);
 }, [partition, mode]);

  // Group by floor
  const floorMap = useMemo(() => {
    const m = {};
    Object.keys(liveCounts).forEach(floorName => {
      m[floorName] = [];
    });
    details.forEach(r => {
      if (!(r.floor in m)) m[r.floor] = [];
      m[r.floor].push(r);
    });
    return m;
  }, [details, liveCounts]);

  // Filter + sort
  const displayed = useMemo(() => {
  const term = searchTerm.trim().toLowerCase();
  return Object.entries(floorMap)
    .map(([floor, emps]) => {
      const filtered = !term
        ? emps
        : emps.filter(e =>
            e.ObjectName1?.toLowerCase().includes(term) ||
            e.EmployeeID?.toString().toLowerCase().includes(term) ||
            e.CardNumber?.toString().toLowerCase().includes(term)
          );
      return [floor, filtered];
    })
    .filter(([, filtered]) => filtered.length > 0) // show only floors with matching results
    .sort(([aFloor], [bFloor]) => (liveCounts[bFloor] || 0) - (liveCounts[aFloor] || 0));
}, [floorMap, searchTerm, liveCounts]);

  const columns = [
    { field: "EmployeeID", headerName: "Emp ID" },
    { field: "ObjectName1", headerName: "Name" },
    { field: "LocaleMessageTime", headerName: "Swipe Time" },
    { field: "PersonnelType", headerName: "Type" },
    { field: "CardNumber", headerName: "Card" },
    { field: "Door", headerName: "Door" },
  ];

  return (
    <>
      {/* <Header /> */}

      <Header
        title={`Partition: ${partition}`}
        mode={mode}
        onTimeSelect={handleTimeSelect}
        onLiveClick={handleLiveClick}
      />

      <Box component="main" sx={{ pt: 1, pb: 1, background: 'rgba(0,0,0,0.6)' }}>
        <Container maxWidth={false} disableGutters>
          {/* Back button */}
          <Box display="flex" alignItems="center" mb={2} sx={{ px: "20px" }}>
            <Button 
              size="small" 
              onClick={() => navigate(-1)}
              sx={{ color: '#FFC107' }}
            >
              ← Back to Overview
            </Button>
          </Box>

          {/* Search */}
          <Box display="flex" alignItems="center" gap={2} mb={2} sx={{ px: "20px" }}>
            <Typography variant="h6" sx={{ color: '#FFC107' }}>
              Floor Details
            </Typography>
            <Typography variant="body2" sx={{ color: '#FFC107' }}>
              Last updated: {lastUpdate}
            </Typography>
            <TextField
              size="small"
              placeholder="Search floor / emp…"
              value={searchTerm}
              onChange={e => setSearchTerm(e.target.value)}
              sx={{
                '& .MuiInputBase-input': { color: '#FFC107' },
                '& .MuiInputLabel-root': { color: '#FFC107' },
                '& .MuiOutlinedInput-root': {
                  '& fieldset': { borderColor: '#FFC107' },
                }
              }}
            />
          </Box>

          {loading ? (
            <Box sx={{ px: "20px", py: 8 }}>
              <LoadingSpinner />
            </Box>
          ) : (
            <>
              {/* Cards */}
              <Box
                sx={{
                  display: "flex",
                  flexWrap: "wrap",
                  width: "100%",
                  margin: 0,
                  padding: 0,
                }}
              >
                {displayed.map(([floor, emps]) => (
                  <Box
                    key={floor}
                    sx={{
                      width: "50%",
                      boxSizing: "border-box",
                      p: "20px",
                    }}
                  >
                    <Box
                      sx={{
                        border: "2px solid #FFC107",
                        borderRadius: 2,
                        height: "100%",
                        p: 2,
                        background: 'rgba(0,0,0,0.4)'
                      }}
                    >
                      <Typography 
                        variant="subtitle1" 
                        fontWeight={600} 
                        gutterBottom
                        sx={{ color: '#FFC107' }}
                      >
                        {floor} (Total {liveCounts[floor] ?? 0})
                      </Typography>

                      <TableContainer 
                        component={Paper} 
                        variant="outlined" 
                        sx={{ mb: 1, background: 'rgba(0,0,0,0.4)' }}
                      >
                        <Table size="small">
                          <TableHead>
                            <TableRow sx={{ bgcolor: '#000' }}>
                              {["Emp ID", "Name", "Swipe Time", "Type", "Card", "Door"].map(h => (
                                <TableCell 
                                  key={h} 
                                  sx={{ 
                                    fontWeight: "bold",
                                    color: '#FFC107',
                                    border: '1px solid #FFC107'
                                  }}
                                >
                                  {h}
                                </TableCell>
                              ))}
                            </TableRow>
                          </TableHead>
                          <TableBody>
                            {emps.slice(0, 10).map((r, i) => {
                              const term = searchTerm.trim().toLowerCase();
                              const isMatch =
                                term &&
                                (r.ObjectName1.toLowerCase().includes(term) ||
                                  r.EmployeeID.toLowerCase().includes(term));
                              return (
                                <TableRow
                                  key={`${r.PersonGUID}-${i}`}
                                  sx={isMatch ? { 
                                    backgroundColor: "rgba(255, 235, 59, 0.3)" 
                                  } : {}}
                                >
                                  <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                    {r.EmployeeID}
                                  </TableCell>
                                  <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                    {r.ObjectName1}
                                  </TableCell>
                                  <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                    {new Date(r.LocaleMessageTime).toLocaleTimeString()}
                                  </TableCell>
                                  <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                    {r.PersonnelType}
                                  </TableCell>
                                  <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                    {r.CardNumber}
                                  </TableCell>
                                  <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                    {r.Door}
                                  </TableCell>
                                </TableRow>
                              );
                            })}
                          </TableBody>
                        </Table>
                      </TableContainer>
                      <Button
                        size="small"
                        onClick={() =>
                          setExpandedFloor(expandedFloor === floor ? null : floor)
                        }
                        sx={{ color: '#FFC107' }}
                      >
                        {expandedFloor === floor ? "Hide" : "See more…"}
                      </Button>
                    </Box>
                  </Box>
                ))}
              </Box>

              {/* Expanded table */}
              {expandedFloor && (
                <Box sx={{ px: "20px", mt: 2 }}>
                  <Typography variant="h6" gutterBottom sx={{ color: '#FFC107' }}>
                    {expandedFloor} — All Entries
                  </Typography>
                  <DataTable
                    columns={columns}
                    rows={floorMap[expandedFloor].map(r => ({
                      ...r,
                      LocaleMessageTime: new Date(r.LocaleMessageTime).toLocaleTimeString(),
                    }))}
                  />
                </Box>
              )}
            </>
          )}
        </Container>
      </Box>

      <Footer />
    </>
  );
}
