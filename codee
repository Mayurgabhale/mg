// NEW: company click/filter state (like EMEA)
  const [selectedCompany, setSelectedCompany] = useState(null);







.......

// Simple canonicalizer (keeps most names but groups blanks / visitors / contractors)
  const getCanonicalCompany = (r) => {
    const normalize = (s) => {
      if (!s) return '';
      return String(s).toLowerCase().trim().replace(/\s+/g, ' ');
    };
    const raw = r.CompanyName && String(r.CompanyName).trim();
    const pt = (r.PersonnelType && String(r.PersonnelType).toLowerCase()) || '';

    if (raw) {
      const n = normalize(raw);
      if (n === 'unknown' || n === '') return 'Unknown';
      // quick grouping examples (add more if you need)
      if (n.includes('western union') || n.startsWith('wu')) return 'WU Srvcs Private Ltd';
      if (n.includes('g4s')) return 'G4S Secure Solutions';
      if (n.includes('addendum')) return 'Addendum Solutions';
      return raw; // preserve original capitalization if no special mapping
    }

    if (pt.includes('contractor')) return 'Contractor';
    if (pt.includes('visitor')) return 'Visitor';
    if (pt.includes('temp')) return 'Temp Badge';
    return 'Unknown';
  };





..........

// --- LACA companyRows: aggregated by CompanyName for pickedDate (EMEA-style) ---
  const companyRows = useMemo(() => {
    if (!data || !pickedDate) return [];

    const ds = format(pickedDate, 'yyyy-MM-dd');
    const codeToCountry = {
      AR: 'Argentina',
      BR: 'Brazil',
      CR: 'Costa Rica',
      MX: 'Mexico',
      PA: 'Panama',
      PE: 'Peru'
    };

    // filter details for this date and only for partitions we care about
    const filtered = data.details.filter(r =>
      (r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10) === ds ||
       r.SwipeDate && r.SwipeDate.slice(0, 10) === ds) &&
      (!filterCode || (r.PartitionName2 && r.PartitionName2.startsWith(filterCode + '.')))
    );

    const map = new Map();

    filtered.forEach(r => {
      const [code, cityRaw] = String(r.PartitionName2 || '').split('.');
      const city = (cityRaw || r.PartitionName2 || 'Unknown').replace('Partition','').trim();
      const country = codeToCountry[code] || code || 'Unknown';

      const company = getCanonicalCompany(r);

      const key = `${country}||${city}||${company}`;
      const existing = map.get(key);
      if (existing) {
        existing.total += 1;
      } else {
        map.set(key, { country, city, company, total: 1 });
      }
    });

    return Array.from(map.values()).sort((a, b) => {
      if (a.country !== b.country) return a.country.localeCompare(b.country);
      if (a.city !== b.city) return a.city.localeCompare(b.city);
      return a.company.localeCompare(b.company);
    });
  }, [data, pickedDate, filterCode]);






......


const detailRows = useMemo(() => {
    if (!data || !pickedDate || !showDetails) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');

    const filtered = data.details.filter(r => {
      const inDay = (r.SwipeDate && r.SwipeDate.startsWith(ds))
        || (r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10) === ds);

      const inPartition = !filterCode
        || (r.PartitionName2 && r.PartitionName2.startsWith(filterCode + '.'));
      return inDay && inPartition;
    });

    filtered.sort((a, b) =>
      (a.LocaleMessageTime || '').localeCompare(b.LocaleMessageTime || '')
    );

    // dedupe by PersonGUID, keep first
    const seen = new Set();
    let rows = filtered.filter(r => {
      if (seen.has(r.PersonGUID)) return false;
      seen.add(r.PersonGUID);
      return true;
    });

    // attach computed company
    rows = rows.map(r => ({ ...r, CompanyNameComputed: getCanonicalCompany(r) }));

    // If a company is selected, filter to match country||city||company
    if (selectedCompany) {
      const [selCountry, selCity, selCompanyRaw] = selectedCompany.split('||');
      const selCompanyNorm = String(selCompanyRaw || '').replace(/\s+/g, ' ').trim().toLowerCase();

      rows = rows.filter(r => {
        const rnCompany = String(r.CompanyNameComputed || 'Unknown').replace(/\s+/g, ' ').trim().toLowerCase();
        const [code, cityRaw] = String(r.PartitionName2 || '').split('.');
        const rowCity = (cityRaw || r.PartitionName2 || '').replace('Partition','').trim();
        const codeToCountry = {
          AR: 'Argentina',
          BR: 'Brazil',
          CR: 'Costa Rica',
          MX: 'Mexico',
          PA: 'Panama',
          PE: 'Peru'
        };
        const rowCountry = codeToCountry[code] || code || 'Unknown';
        return rnCompany === selCompanyNorm && rowCity === selCity && rowCountry === selCountry;
      });
    }

    return rows;
  }, [data, pickedDate, showDetails, filterCode, selectedCompany]);





....






const handleExportCompanies = async () => {
    if (!pickedDate || !companyRows.length) return;
    try {
      const excelModule = await import('exceljs');
      const Excel = excelModule.default || excelModule;

      let wb;
      if (Excel && Excel.Workbook) wb = new Excel.Workbook();
      else if (typeof Excel === 'function') wb = new Excel();
      else throw new Error('ExcelJS Workbook constructor not found');

      const ws = wb.addWorksheet('Company Summary');

      ws.columns = [
        { header: 'Country', key: 'country', width: 20 },
        { header: 'City', key: 'city', width: 25 },
        { header: 'Company', key: 'company', width: 40 },
        { header: 'Total', key: 'total', width: 12 },
      ];

      // Title row
      ws.mergeCells('A1:D1');
      const dateCell = ws.getCell('A1');
      dateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
      dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
      dateCell.font = { name: 'Calibri', size: 14, bold: true };

      ws.addRow([]);

      // Header styling
      const headerRow = ws.addRow(['Country', 'City', 'Company', 'Total']);
      headerRow.eachCell(cell => {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
        cell.font = { bold: true, color: { argb: 'FF000000' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });

      companyRows.forEach((r, i) => {
        const row = ws.addRow([r.country, r.city, r.company, r.total]);
        row.eachCell((cell, colNumber) => {
          cell.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          if (colNumber === 4) {
            cell.alignment = { horizontal: 'right', vertical: 'middle' };
            cell.numFmt = '#,##0';
          } else {
            cell.alignment = { horizontal: 'left', vertical: 'middle' };
          }
        });
        // zebra
        if (i % 2 === 1) {
          row.eachCell(cell => {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
          });
        }
      });

      // totals row
      const total = companyRows.reduce((s, r) => s + r.total, 0);
      const totalRow = ws.addRow(['Total', '', '', total]);
      totalRow.eachCell((cell, colNumber) => {
        cell.font = { bold: true };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        if (colNumber === 4) {
          cell.alignment = { horizontal: 'right', vertical: 'middle' };
          cell.numFmt = '#,##0';
        } else {
          cell.alignment = { horizontal: colNumber === 1 ? 'left' : 'center', vertical: 'middle' };
        }
      });

      const buf = await wb.xlsx.writeBuffer();
      saveAs(new Blob([buf]), `laca_companies_${format(pickedDate, 'yyyyMMdd')}.xlsx`);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('handleExportCompanies error:', err);
    }
  };





.....



