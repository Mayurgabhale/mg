
TypeError: argument handler must be a function
    at Route.<computed> [as get] (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\node_modules\router\lib\route.js:228:15)
    at Router.<computed> [as get] (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\node_modules\router\index.js:448:19)
    at Object.<anonymous> (C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\routes\occupancyDenverRoutes.js:66:8)
    at Module._compile (node:internal/modules/cjs/loader:1730:14)
    at Object..js (node:internal/modules/cjs/loader:1895:10)
    at Module.load (node:internal/modules/cjs/loader:1465:32)
    at Function._load (node:internal/modules/cjs/loader:1282:12)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:235:24)
    at Module.require (node:internal/modules/cjs/loader:1487:12)

Node.js v22.17.0
PS C:\Users\W0024618\Desktop\swipeData\employee-ai-insights> 

const { DateTime } = require('luxon');
const { denver } = require('../config/siteConfig');
const normalizeKey = require('../data/normalizeKey');
const doorFloorMap = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql = require('mssql');

const warnedKeys = new Set();
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(([door, dir]) => normalizeKey(door, dir))
);

function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' }).toFormat('yyyy-LL-dd');
  const today = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`â›” Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

async function fetchEventsUntil(time) {
  // Fetch all events today up to the selected time
  let pool;
  try { pool = await denver.poolPromise; } 
  catch (err) { console.error(err); return []; }
  if (!pool) return [];

  const req = pool.request();
  req.input('until', sql.DateTime2, time);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010029.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5a ON t1.XmlGUID = t5a.GUID AND t5a.Name='AdmitCode'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5d ON t1.XmlGUID = t5d.GUID AND t5d.Name='Direction'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxml t_xml ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (SELECT GUID,value FROM ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred WHERE Name IN ('Card','CHUID')) sc ON t1.XmlGUID=sc.GUID
      WHERE t1.MessageType='CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE,-1* t1.MessageLocaleOffset, t1.MessageUTC) <= @until
    )
    SELECT *
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC
  `);

  return recordset;
}

function buildOccupancyAtTime(allEvents) {
  // reuse Denver logic: evict "Out of office" and compute current count
  const evicted = new Set();
  const lastByPerson = new Map();
  allEvents.forEach(evt => {
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    const prev = lastByPerson.get(key);
    if (!prev || evt.LocaleMessageTime > prev.LocaleMessageTime) {
      lastByPerson.set(key, evt);
    }
  });
  lastByPerson.forEach(evt => {
    if (evt.Direction === 'OutDirection' && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office') {
      evicted.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });

  const activeEvents = allEvents.filter(evt => !evicted.has(evt.PersonGUID || evt.EmployeeID || evt.CardNumber));

  // Live occupancy counts
  const latestByPerson = new Map();
  activeEvents.forEach(e => {
    const key = e.PersonGUID;
    const prev = latestByPerson.get(key);
    if (!prev || DateTime.fromFormat(e.Swipe_Time, 'HH:mm:ss') > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(key, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // Floor & personnel breakdown
  const floorMap = {};
  let employees = 0, contractors = 0;
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') employees++;
    else contractors++;
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
    let emp=0, ctr=0, temp=0, others=0;
    occ.forEach(e => {
      switch(e.PersonnelType){
        case 'Employee':
        case 'Terminated Personnel': emp++; break;
        case 'Contractor':
        case 'Terminated Contractor': ctr++; break;
        case 'Temp Badge': temp++; break;
        default: others++;
      }
    });
    return { floor, total: occ.length, employees: emp, contractors: ctr, tempBadge: temp, others, occupants: occ };
  });

  // Personnel summary
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => { m.set(e.PersonnelType, (m.get(e.PersonnelType)||0)+1); return m; }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  return {
    asOf: new Date().toISOString(),
    currentCount: finalList.length,
    floorBreakdown,
    personnelSummary: { employees, contractors },
    personnelBreakdown
  };
}

// API handler
exports.getDenverOccupancyAtTime = async (req, res) => {
  try {
    const { at } = req.query;
    if (!at) return res.status(400).json({ error: 'Missing "at" query parameter' });

    const atDate = new Date(at);
    if (Number.isNaN(atDate.getTime())) return res.status(400).json({ error: 'Invalid "at" timestamp' });

    const today = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
    const atLocal = DateTime.fromJSDate(atDate).setZone('America/Denver').toFormat('yyyy-LL-dd');
    if (today !== atLocal) return res.status(400).json({ error: 'Only current day supported' });

    const events = await fetchEventsUntil(atDate);
    const occupancy = buildOccupancyAtTime(events);

    return res.json(occupancy);
  } catch (err) {
    console.error('getDenverOccupancyAtTime error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};






..

const { getDenverOccupancyAtTime } = require('../controllers/denverLiveOccupancyController');

// occupancy at selected time
router.get('/occupancy-at-denver', getDenverOccupancyAtTime);
