wrong present ans absent data:
this emplooye is not that much absent:
this is wrong logic. write correct 
http://localhost:5000/api/monthly-summary?month=2025-08
 {
      "employeeId": "W0024618",
      "name": "Diwate, Swapnil",
      "personnelType": "Contractor",
      "2025-08-01": "A",
      "2025-08-02": "A",
      "2025-08-03": "A",
      "2025-08-04": "A",
      "2025-08-05": "A",
      "2025-08-06": "A",
      "2025-08-07": "A",
      "2025-08-08": "A",
      "2025-08-09": "A",
      "2025-08-10": "A",
      "2025-08-11": "A",
      "2025-08-12": "A",
      "2025-08-13": "A",
      "2025-08-14": "A",
      "2025-08-15": "A",
      "2025-08-16": "A",
      "2025-08-17": "A",
      "2025-08-18": "A",
      "2025-08-19": "A",
      "2025-08-20": "P",
      "2025-08-21": "P",
      "2025-08-22": "P",
      "2025-08-23": "P",
      "2025-08-24": "A",
      "2025-08-25": "P",
      "2025-08-26": "P",
      "2025-08-27": "P",
      "2025-08-28": "P",
      "2025-08-29": "P",
      "2025-08-30": "P",
      "2025-08-31": "A",
      "daysPresent": 10,
      "daysAbsent": 21,
      "attendancePercent": "32.3%"
    },
    {


 {
      "employeeId": "314345",
      "name": "Dass, Lloyds",
      "personnelType": "Employee",
      "2025-08-01": "A",
      "2025-08-02": "A",
      "2025-08-03": "A",
      "2025-08-04": "A",
      "2025-08-05": "A",
      "2025-08-06": "A",
      "2025-08-07": "A",
      "2025-08-08": "A",
      "2025-08-09": "A",
      "2025-08-10": "A",
      "2025-08-11": "A",
      "2025-08-12": "A",
      "2025-08-13": "A",
      "2025-08-14": "A",
      "2025-08-15": "A",
      "2025-08-16": "A",
      "2025-08-17": "A",
      "2025-08-18": "A",
      "2025-08-19": "A",
      "2025-08-20": "P",
      "2025-08-21": "P",
      "2025-08-22": "P",
      "2025-08-23": "A",
      "2025-08-24": "A",
      "2025-08-25": "A",
      "2025-08-26": "A",
      "2025-08-27": "A",
      "2025-08-28": "A",
      "2025-08-29": "P",
      "2025-08-30": "A",
      "2025-08-31": "A",
      "daysPresent": 4,
      "daysAbsent": 27,
      "attendancePercent": "12.9%"




// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    // Month start/end in Pune local zone
    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    // Today in Pune (string yyyy-LL-dd)
    const todayKolkataStr = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

    // Full month dates (1..endOfMonth) as strings
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // Considered dates (for attendance math) = up to today if the requested month is current month,
    // otherwise the full month (for past months).
    const isRequestedMonthCurrent =
      start.toFormat('yyyy-LL') === DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL');

    const consideredDates = isRequestedMonthCurrent
      ? allDates.filter(d => d <= todayKolkataStr)
      : allDates.slice(); // full month for past months

    // SQL boundaries (UTC)
    const startUtc = start.setZone('utc').toJSDate();
    const endUtc = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    const { recordset } = await reqDb.query(`
      SELECT
        t1.MessageUTC,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND t1.MessageUTC BETWEEN @start AND @end
      ORDER BY t1.MessageUTC ASC;
    `);

    // Convert to Pune local time & normalize events
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),            // ISO string
        Dateonly: local.toFormat('yyyy-LL-dd'),     // day string
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Group events by day
    const byDay = new Map();
    for (const evt of events) {
      if (!byDay.has(evt.Dateonly)) byDay.set(evt.Dateonly, []);
      byDay.get(evt.Dateonly).push(evt);
    }

    // Aggregates
    const dailySummaries = [];        // {date, total}
    const peakOccupancy = [];         // {date, peak}
    const visitCounter = new Map();   // key -> {count, employeeId, name, personnelType}
    const presenceByPerson = new Map(); // key -> {employeeId, name, personnelType, days: Set}

    // Helper to create stable dedupe key
    const dedupeKey = (e) => (e.PersonGUID || e.EmployeeID || e.ObjectName1 || ('unk_' + Math.random()));

    // Process each day that has any events (only days present in data)
    for (const [date, dayEvents] of byDay.entries()) {
      // Unique daily headcount: dedupe per-person for that day
      const uniquePeople = new Set();
      for (const e of dayEvents) {
        uniquePeople.add(dedupeKey(e));
      }
      dailySummaries.push({ date, total: uniquePeople.size });

      // Peak occupancy simulation (+1 on InDirection, -1 on OutDirection)
      let currentCount = 0;
      let maxCount = 0;
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') currentCount++;
        else if (e.Direction === 'OutDirection') currentCount = Math.max(0, currentCount - 1);
        if (currentCount > maxCount) maxCount = currentCount;
      }
      peakOccupancy.push({ date, peak: maxCount });

      // Track visits and presence (count only InDirection as presence marker)
      for (const e of dayEvents) {
        if (e.Direction !== 'InDirection') continue;
        const key = dedupeKey(e);

        // visits (raw swipe-ins)
        if (!visitCounter.has(key)) {
          visitCounter.set(key, {
            count: 0,
            employeeId: e.EmployeeID,
            name: e.ObjectName1,
            personnelType: e.PersonnelType
          });
        }
        visitCounter.get(key).count++;

        // presence (days set)
        if (!presenceByPerson.has(key)) {
          presenceByPerson.set(key, {
            employeeId: e.EmployeeID,
            name: e.ObjectName1,
            personnelType: e.PersonnelType,
            days: new Set()
          });
        }
        presenceByPerson.get(key).days.add(date);
      }
    }

    // Average daily headcount: average over considered dates (only days that have data up to today)
    // We compute average over the intersection: for each considered date, if dailySummaries contains it use its total else 0.
    const dailyTotalsByDate = Object.fromEntries(dailySummaries.map(d => [d.date, d.total]));
    const consideredTotals = consideredDates.map(d => dailyTotalsByDate[d] || 0);
    const avgDailyHeadcount = consideredTotals.length
      ? Math.round(consideredTotals.reduce((s, v) => s + v, 0) / consideredTotals.length)
      : 0;

    // Top 10 visitors by swipe count (unchanged)
    const top10Visitors = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({
        employeeId: v.employeeId,
        name: v.name,
        personnelType: v.personnelType,
        visits: v.count
      }));

    // Attendance sheet:
    // - For each person who appeared at least once in month, produce a row with all month columns.
    // - For dates after today (if it's the current month) mark as null (not applicable) and DO NOT count them into daysAbsent/attendance%.
    const attendanceSheet = Array.from(presenceByPerson.entries()).map(([key, p]) => {
      const row = {
        employeeId: p.employeeId,
        name: p.name,
        personnelType: p.personnelType
      };

      let presentCount = 0;

      for (const d of allDates) {
        const isFuture = (isRequestedMonthCurrent && d > todayKolkataStr);
        if (isFuture) {
          // Future date for current month: mark as null (not yet applicable)
          row[d] = null;
          continue;
        }

        // Not future => count as Present (P) if in p.days else Absent (A)
        if (p.days.has(d)) {
          row[d] = "P";
          presentCount++;
        } else {
          row[d] = "A";
        }
      }

      const workingDaysToDate = consideredDates.length; // number of days we consider for attendance
      const daysAbsent = workingDaysToDate - presentCount;
      const attendancePercent = workingDaysToDate > 0
        ? ((presentCount / workingDaysToDate) * 100).toFixed(1) + '%'
        : '0.0%';

      row.daysPresent = presentCount;
      row.daysAbsent = daysAbsent;
      row.attendancePercent = attendancePercent;
      return row;
    });

    return res.json({
      month,
      today: todayKolkataStr,
      workingDaysConsidered: consideredDates.length,
      avgDailyHeadcount,
      peakOccupancy,
      top10Visitors,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};



______________________________


async function fetchNewEvents(since) {
  // await the shared pool promise instead of poolConnect
  const pool = await getPool();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

// console.log('🔎 [Pune] fetchNewEvents called with since =', since.toISOString());
  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
       DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       


        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >@since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // console.log(`📥 [Pune] fetched ${recordset.length} rows:`,
    // recordset.map(r => r.LocaleMessageTime.toISOString()));

  return recordset;
}


