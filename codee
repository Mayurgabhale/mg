// Build occupancy for "today" where "today" can be the real today OR the date represented by atDt (Denver)
function buildOccupancyForToday(allEvents, freshEvents = [], atDt = null) {
  // normalize reference DateTime (if provided) to America/Denver
  const refDt = atDt ? atDt.setZone('America/Denver') : null;

  // HELPER: canonical person key used throughout
  const personKey = (evt) => evt.PersonGUID || evt.EmployeeID || evt.CardNumber;

  // ─── PREFILTER: only keep events on the same Denver date AND (if atDt provided) that occurred at or before atDt
  const relevantEvents = allEvents.filter(evt => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;

    // evt.LocaleMessageTime should be a Date-like value from DB; make a Luxon DateTime in Denver zone
    const evtDt = DateTime.fromJSDate(new Date(evt.LocaleMessageTime)).setZone('America/Denver');
    return evtDt <= refDt;
  });

  // ─── A) Evict “Out of office” ───────────────────────────────────
  const evicted = new Set();
  const lastByPerson = new Map();

  // use LocaleMessageTime for deciding the last event per person
  relevantEvents.forEach(evt => {
    const key = personKey(evt);
    const prev = lastByPerson.get(key);
    const evtDt = DateTime.fromJSDate(new Date(evt.LocaleMessageTime));
    if (!prev || evtDt > DateTime.fromJSDate(new Date(prev.LocaleMessageTime))) {
      lastByPerson.set(key, evt);
    }
  });

  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection'
      && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(personKey(evt));
    }
  });

  const activeEvents = relevantEvents.filter(evt => !evicted.has(personKey(evt)));

  // ─── 1) Live occupancy dedupe by last InDirection ───────────────
  const todayIn = activeEvents.filter(e => e.Direction === 'InDirection');

  // use LocaleMessageTime ordering and canonical person key
  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const key = personKey(e);
    const prev = latestByPerson.get(key);
    const eDt = DateTime.fromJSDate(new Date(e.LocaleMessageTime));
    if (!prev || eDt > DateTime.fromJSDate(new Date(prev.LocaleMessageTime))) {
      latestByPerson.set(key, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // ─── 2) Floor breakdown & personnel counts (live) ───────────────
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      employees++;
    } else {
      contractors++;
    }
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
    let empCount = 0;
    let contractorCount = 0;
    let tempBadgeCount = 0;
    let otherCount = 0;

    occ.forEach(e => {
      switch (e.PersonnelType) {
        case 'Employee':
        case 'Terminated Personnel':
          empCount++;
          break;
        case 'Contractor':
        case 'Terminated Contractor':
          contractorCount++;
          break;
        case 'Temp Badge':
          tempBadgeCount++;
          break;
        default:
          otherCount++;
      }
    });

    return {
      floor,
      total: occ.length,
      employees: empCount,
      contractors: contractorCount,
      tempBadge: tempBadgeCount,
      others: otherCount,
      occupants: occ
    };
  });

  // ─── 3) Personnel breakdown ───────────────────────────────────────
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // ─── 4) Swipe stats (fresh only) ─────────────────────────────────
  const totalInSwipes = (freshEvents || []).filter(e =>
    e.Direction === 'InDirection' && isSameDenverDate(e.Dateonly, refDt) &&
      (!refDt || DateTime.fromJSDate(new Date(e.LocaleMessageTime)).setZone('America/Denver') <= refDt)
  ).length;
  const totalOutSwipes = (freshEvents || []).filter(e =>
    e.Direction === 'OutDirection' && isSameDenverDate(e.Dateonly, refDt) &&
      (!refDt || DateTime.fromJSDate(new Date(e.LocaleMessageTime)).setZone('America/Denver') <= refDt)
  ).length;

  // ─── 5) Floor In/Out summary (strict doors only) ───────────────
  const validEvents = relevantEvents
    .filter(evt => {
      const doorNoTime = stripTimeSuffix(evt.Door.trim());
      const key = normalizeKey(doorNoTime, evt.Direction.trim());
      return normalizedMonitoredKeys.has(key);
    });

  // Dedupe per person+floor+direction using LocaleMessageTime ordering
  const deduped = new Map();
  validEvents.forEach(evt => {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    const mapKey = `${personKey(evt)}___${floor}___${evt.Direction}`;
    const prev = deduped.get(mapKey);
    const now = DateTime.fromJSDate(new Date(evt.LocaleMessageTime));
    if (!prev || now > DateTime.fromJSDate(new Date(prev.LocaleMessageTime))) {
      deduped.set(mapKey, evt);
    }
  });

  // Aggregate inSwipes/outSwipes per floor
  const floorMapIO = {};
  for (const evt of deduped.values()) {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    if (!floorMapIO[floor]) {
      floorMapIO[floor] = {
        inSwipes: 0,
        outSwipes: 0,
        inSet: new Set(),
        outSet: new Set()
      };
    }

    const id = personKey(evt);
    if (evt.Direction === 'InDirection') {
      floorMapIO[floor].inSwipes++;
      floorMapIO[floor].inSet.add(id);
    } else {
      floorMapIO[floor].outSwipes++;
      floorMapIO[floor].outSet.add(id);
    }
  }

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes: stats.inSwipes,
      outSwipes: stats.outSwipes,
      inOnlyCount: inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ─── 6) Visited today breakdown ─────────────────────────────────
  const visited = computeVisitedToday(allEvents, refDt);

  // Build final payload; include both local Denver and UTC `asOf`
  const asOfLocal = refDt ? refDt.toISO() : DateTime.now().setZone('America/Denver').toISO();
  const asOfUTC = refDt ? refDt.toUTC().toISO() : new Date().toISOString();

  return {
    asOfLocal,
    asOfUTC,
    currentCount: finalList.length,
    floorBreakdown,
    personnelSummary: { employees, contractors },
    personnelBreakdown,
    totalVisitedToday: visited.total,
    visitedToday: {
      employees: visited.employees,
      contractors: visited.contractors,
      total: visited.total
    },
    swipeStats: { totalInSwipes: totalInSwipes, totalOutSwipes: totalOutSwipes },
    floorInOutSummary
  };
}
