/**
 * Given the server payload `p` and an ISO timestamp string `isoRequested` (like "2025-09-11T00:00:00.000Z"),
 * produce a filtered copy of `p` where:
 *  - p.summary (if array) is filtered to items containing the requested UTC date
 *  - p.details (if object mapping -> arrays) has each array filtered by date
 *  - totalVisitedToday and visitedToday.total are recomputed from filtered details (sum of lengths)
 *  - personnelSummary (employees/contractors) is recomputed by scanning filtered details
 *
 * The personnel-type detection is heuristic: it looks for common field names and values
 * (personnelType, type, category, role, isContractor, contractor, employee, etc).
 */
function filterPayloadByDate(p, isoRequested) {
  if (!p || !isoRequested) return p;
  const targetDate = isoRequested.slice(0, 10); // "YYYY-MM-DD"
  const newP = { ...p };

  // Filter summary if array
  if (Array.isArray(p.summary)) {
    newP.summary = filterArrayByUTCDate(p.summary, targetDate);
  }

  // Filter details: object with zone -> array
  let newDetails = {};
  if (p.details && typeof p.details === 'object' && !Array.isArray(p.details)) {
    for (const key of Object.keys(p.details)) {
      const arr = p.details[key];
      if (Array.isArray(arr)) {
        newDetails[key] = filterArrayByUTCDate(arr, targetDate);
      } else {
        newDetails[key] = arr;
      }
    }
    newP.details = newDetails;
  }

  // recompute totalVisitedToday as sum of lengths in details (fallback: use filtered summary length)
  let recomputedTotal = 0;
  if (newP.details && typeof newP.details === 'object') {
    for (const k of Object.keys(newP.details)) {
      const arr = newP.details[k];
      if (Array.isArray(arr)) recomputedTotal += arr.length;
    }
  }
  if (recomputedTotal === 0 && Array.isArray(newP.summary)) {
    recomputedTotal = newP.summary.length;
  }

  newP.totalVisitedToday = recomputedTotal;
  newP.visitedToday = { ...(p.visitedToday || {}), total: recomputedTotal };

  // --------------------
  // Recompute personnelSummary (employees / contractors)
  // --------------------
  let employees = 0;
  let contractors = 0;

  // helper: try to infer personnel type from a single record
  function inferPersonnelType(record) {
    if (!record || typeof record !== 'object') return null;

    // boolean-style flags
    if (record.isContractor === true || record.contractor === true || record.is_contractor === true) return 'contractor';
    if (record.isEmployee === true || record.employee === true || record.is_employee === true) return 'employee';

    // numeric flags (1/0)
    if (record.contractor === 1 || record.isContractor === 1) return 'contractor';
    if (record.employee === 1 || record.isEmployee === 1) return 'employee';

    // common string fields: personnelType, type, category, role, personType, badgeType
    const keysToCheck = ['personnelType','personnel_type','personnelCategory','type','category','role','personType','badgeType','jobType','jobRole'];
    for (const k of keysToCheck) {
      if (k in record && record[k] != null) {
        const v = String(record[k]).toLowerCase();
        if (v.includes('contract')) return 'contractor';
        if (v.includes('employee') || v.includes('emp')) return 'employee';
        // sometimes labels like "C" or "E"
        if (v === 'c') return 'contractor';
        if (v === 'e') return 'employee';
      }
    }

    // fallback: look for any field value that contains the words
    for (const key of Object.keys(record)) {
      const val = record[key];
      if (val == null) continue;
      if (typeof val === 'string') {
        const vs = val.toLowerCase();
        if (vs.includes('contract')) return 'contractor';
        if (vs.includes('employee') || vs.includes('emp')) return 'employee';
      }
    }

    return null;
  }

  // count across filtered details arrays
  if (newP.details && typeof newP.details === 'object') {
    for (const k of Object.keys(newP.details)) {
      const arr = newP.details[k];
      if (!Array.isArray(arr)) continue;
      for (const rec of arr) {
        const t = inferPersonnelType(rec);
        if (t === 'employee') employees += 1;
        else if (t === 'contractor') contractors += 1;
        // unknown -> we do not count toward either bucket (keeps it conservative)
      }
    }
  }

  // If no explicit types were found but we have a recomputedTotal, attempt a fallback:
  if (employees === 0 && contractors === 0 && recomputedTotal > 0) {
    // Try to use visitedToday from payload if it had employees/contractors numbers
    const visited = p.visitedToday || {};
    const vEmp = typeof visited.employees === 'number' ? visited.employees : 0;
    const vCont = typeof visited.contractors === 'number' ? visited.contractors : 0;
    if (vEmp + vCont > 0) {
      // scale down proportionally to the filtered total if original visitedToday.total differs
      const originalTotal = (p.visitedToday && p.visitedToday.total) || (vEmp + vCont);
      if (originalTotal > 0) {
        const scale = recomputedTotal / originalTotal;
        employees = Math.round(vEmp * scale);
        contractors = Math.round(vCont * scale);
        // adjust rounding edge
        const diff = recomputedTotal - (employees + contractors);
        if (diff > 0) employees += diff;
      } else {
        // just put everything into employees as a last resort (conservative)
        employees = recomputedTotal;
        contractors = 0;
      }
    } else {
      // last resort: assign all to employees so UI shows something consistent
      employees = recomputedTotal;
      contractors = 0;
    }
  }

  newP.personnelSummary = { employees, contractors };

  // Also ensure personnelBreakdown is at least defined (optional)
  if (!Array.isArray(newP.personnelBreakdown)) {
    newP.personnelBreakdown = [
      { personnelType: 'Employees', count: employees },
      { personnelType: 'Contractors', count: contractors }
    ];
  } else {
    // if backend provided a breakdown, leave it alone (we set personnelSummary which is the source for the cards)
  }

  // Done
  return newP;
}