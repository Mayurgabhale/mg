// src/components/TimeTravelControl.jsx
import React, { useEffect, useState } from 'react';
import { Button, InputGroup, FormControl, Spinner } from 'react-bootstrap';

/**
 * TimeTravelControl
 * - shows a "YYYY-MM-DDTHH:mm" input
 * - when Apply clicked -> sends "<local-value>:00.000+05:30" (Asia/Kolkata)
 * - keeps input in sync with parent-provided currentTimestamp (ISO)
 */
export default function TimeTravelControl({ currentTimestamp, onApply, onLive, loading }) {
  // store local value as "YYYY-MM-DDTHH:mm" (no timezone marker)
  const [local, setLocal] = useState(currentTimestamp ? isoToInput(currentTimestamp) : '');

  // sync when parent changes currentTimestamp
  useEffect(() => {
    if (currentTimestamp) setLocal(isoToInput(currentTimestamp));
    else setLocal('');
  }, [currentTimestamp]);

  function handleApply() {
    if (!local) return;
    // Send the picked time as Asia/Kolkata (+05:30)
    // e.g. "2025-09-11T16:00" -> "2025-09-11T16:00:00.000+05:30"
    const isoKolkata = `${local}:00.000+05:30`;
    onApply(isoKolkata);
  }

  function handleLive() {
    setLocal('');
    onLive();
  }

  return (
    <div style={{ display: 'flex', gap: 8, alignItems: 'center', minWidth: 340 }}>
      <InputGroup>
        <FormControl
          type="datetime-local"
          value={local}
          onChange={(e) => setLocal(e.target.value)}
          placeholder="Select date & time"
        />
      </InputGroup>

      <div style={{ display: 'flex', gap: 6 }}>
        <Button variant="outline-warning" onClick={handleApply} disabled={loading || !local}>
          {loading ? <><Spinner animation="border" size="sm" />&nbsp;Applying</> : 'Apply'}
        </Button>
        <Button variant="warning" onClick={handleLive} disabled={loading}>
          Live
        </Button>
      </div>
    </div>
  );
}

/** helpers **/

// zero-pad
function pad(n) { return String(n).padStart(2, '0'); }

/**
 * Convert an ISO timestamp (any zone) into a "YYYY-MM-DDTHH:mm" string for the input,
 * interpreting the instant in Asia/Kolkata so the displayed value matches the KS local time.
 */
function isoToInput(iso) {
  if (!iso) return '';
  const d = new Date(iso);

  // Use Intl to format in Asia/Kolkata and extract parts so we don't need an external lib
  const parts = new Intl.DateTimeFormat('en-GB', {
    timeZone: 'Asia/Kolkata',
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', hour12: false
  }).formatToParts(d);

  const get = (type) => (parts.find(p => p.type === type) || {}).value || '';
  const year = get('year');
  const month = get('month');
  const day = get('day');
  const hour = get('hour');
  const minute = get('minute');

  if (!year) return '';
  return `${year}-${month}-${day}T${hour}:${minute}`;
}




...

..
// helper inside App component (or above it)
function formatAsKolkata(iso) {
  if (!iso) return '';
  try {
    const d = new Date(iso);
    // produce: "2025-09-11 04:00 PM"
    const parts = new Intl.DateTimeFormat('en-GB', {
      timeZone: 'Asia/Kolkata',
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', hour12: true
    }).formatToParts(d);
    const get = (type) => (parts.find(p => p.type === type) || {}).value || '';
    const y = get('year'), m = get('month'), day = get('day');
    const hour = get('hour'), minute = get('minute'), ampm = get('dayPeriod');
    // output ISO-like date but human friendly: "2025-09-11 04:00 PM"
    return `${y}-${m}-${day} ${hour}:${minute} ${ampm}`;
  } catch (e) {
    return iso;
  }
}


...

<strong>{formatAsKolkata(timeTravelTimestamp)}</strong>