✅ Query executed, rows: 17670
PS C:\Users\W0024618\Desktop\employee-verification> npm start

> employee-verification@1.0.0 start
> node server.js

🚀 Server running on http://localhost:5001
🎯 [GET] /api/employees/2097201235/image called
✅ MSSQL pool connected
✅ DB pool acquired for image
✅ Image query rows: 2
✅ Serving image, type: image/jpeg size: 4017
Occupancy fetch failed for http://10.199.22.57:3008/api/occupancy/live-summary timeout of 3000ms exceeded
Occupancy fetch failed for http://10.199.22.57:4000/api/occupancy/live-summary timeout of 3000ms exceeded
Occupancy fetch failed for http://10.199.22.57:3008/api/occupancy/live-summary timeout of 3000ms exceeded
Occupancy fetch failed for http://10.199.22.57:4000/api/occupancy/live-summary timeout of 3000ms exceeded
🎯 [GET] /api/employees/2097201236/image called
✅ DB pool acquired for image
✅ Image query rows: 2
✅ Serving image, type: image/jpeg size: 4017
Occupancy fetch failed for http://10.199.22.57:3008/api/occupancy/live-summary timeout of 3000ms exceeded
🎯 [GET] /api/employees/2097207990/image called
✅ DB pool acquired for image
✅ Image query rows: 1
✅ Serving image, type: image/jpeg size: 13803
Occupancy fetch failed for http://10.199.22.57:3008/api/occupancy/live-summary timeout of 3000ms exceeded


WHERE IS THE COME THIS ERROR BACKEND OR FRONTEND 

const sql    = require('mssql');
const dotenv = require('dotenv');
dotenv.config();

const config = {
  server:   process.env.DB_SERVER,
  user:     process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  connectionTimeout: 30000,    // 30 s to establish
  requestTimeout:    0,        // no timeout on individual queries
  pool: {
    max:                  100,
    min:                   0,

    // Use maximum 32-bit signed‐int (~24.8 days) so Node/tarn doesn't overflow
    idleTimeoutMillis:    2147483647,
    acquireTimeoutMillis: 2147483647
  },
  options: {
    encrypt:               true,
    trustServerCertificate: true
  }
};

let poolPromise = null;

async function getPool(attempts = 100) {
  if (poolPromise) return poolPromise;

  poolPromise = (async () => {
    try {
      const pool = await sql.connect(config);
      console.log('✅ MSSQL pool connected');
      return pool;
    } catch (err) {
      console.error('❌ MSSQL pool connection failed:', err);
      poolPromise = null;
      if (attempts > 0) {
        console.log(`⏳ Retrying MSSQL connect (${attempts} left)…`);
        await new Promise(res => setTimeout(res, 3000));
        return getPool(attempts - 1);
      }
      throw err;
    }
  })();

  sql.on('error', err => {
    console.error('❌ MSSQL global error:', err);
    // Don’t force‐reset poolPromise here unless it’s a fatal error you want to recover from.
  });

  return poolPromise;
}

// Keep‐alive ping every 5 minutes
setInterval(async () => {
  try {
    const pool = await getPool();
    await pool.request().query('SELECT 1');
    // console.log('🔄 MSSQL keep‐alive succeeded');
  } catch (err) {
    console.error('⚠️ MSSQL keep‐alive ping failed:', err);
    // poolPromise stays intact so we keep using the same pool
  }
}, 5 * 60 * 1000);

module.exports = { sql, getPool };



// CurrentLocation.jsx
import React, { useEffect, useState } from 'react';
import axios from 'axios';

export default function CurrentLocation({ empId }) {
  const [loading, setLoading] = useState(false);
  const [loc, setLoc] = useState(null);
  const [error, setError] = useState('');

  useEffect(() => {
    if (!empId) {
      setLoc(null);
      setError('');
      return;
    }

    let cancelled = false;
    setLoading(true);
    setError('');
    setLoc(null);

    axios.get(`http://localhost:5001/api/employees/${empId}/location`, { timeout: 5000 })
      .then(res => {
        if (cancelled) return;
        setLoc(res.data);
      })
      .catch(err => {
        if (cancelled) return;
        console.error('Location load error', err && err.message ? err.message : err);
        setError('Failed to load location');
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
    };
  }, [empId]);

  if (!empId) return null;

  // return (
  //   <div className="current-location-card" style={{ marginTop: 8 }}>
  //     <h4 style={{ margin: '0 0 6px 0', fontSize: 14 }}>Swipe Details</h4>

  //     {loading && <div style={{ color: '#fff' }}>Loading location…</div>}

  //     {error && <div style={{ color: '#fff' }}>{error}</div>}

  //     {!loading && loc && !loc.found && <div style={{ color: '#2ced0e' }}>No recent swipe</div>}

  //     {!loading && loc && loc.found && (
  //       <div style={{ fontSize: 14, color: '#fff' }}>
  //         <div style={{ fontWeight: 600 }}>
  //           {loc.partition || '—'}{loc.floor ? ` · ${loc.floor}` : ''}
  //         </div>

  //         <div style={{ marginTop: 6, color: '#fff' }}>
  //           {loc.door && <div>{loc.door}</div>}
  //           {loc.direction && <div>Direction: {loc.direction}</div>}
  //           {loc.timestampUTC && (
  //             <div style={{ marginTop: 6, fontSize: 13, color: '#fff' }}>
  //               Last seen: {new Date(loc.timestampUTC).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })} (IST)
  //             </div>
  //           )}
  //         </div>
  //       </div>
  //     )}
  //   </div>
  // );




  return (
  <div className="current-location-card" style={{ marginTop: 2 }}>
    <h4 style={{ margin: '0 0 2px 0', fontSize: 14 }}>Swipe Details</h4>

    {loading && <div style={{ color: '#fff' }}>Loading location…</div>}

    {error && <div style={{ color: '#fff' }}>{error}</div>}

    {!loading && loc && !loc.found && (
      <div style={{ color: '#2ced0e' }}>No recent swipe</div>
    )}

    {!loading && loc && loc.found && (
      <div style={{ fontSize: 14, color: '#fff' }}>
        {/* Location */}
        <div style={{ fontWeight: 600 }}>
          {loc.partition || '—'}
          {loc.floor ? ` · ${loc.floor}` : ''}
        </div>

        {/* Swipe Details */}
        {loc.timestampUTC && (() => {
          const istDate = new Date(loc.timestampUTC).toLocaleDateString('en-IN', {
            timeZone: 'Asia/Kolkata',
          });
          const istTime = new Date(loc.timestampUTC).toLocaleTimeString('en-IN', {
            timeZone: 'Asia/Kolkata',
          });
          return (
            <>
              <div style={{ marginTop: 6 }}>Date: {istDate}</div>
              <div>Time: {istTime}</div>
            </>
          );
        })()}

        {loc.door && (
          <div style={{ marginTop: 4 }}>Door: {loc.door}</div>
        )}

        {loc.direction && (
          <div>Direction: {loc.direction}</div>
        )}
      </div>
    )}



    
  </div>
)

}

