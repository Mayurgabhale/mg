{
  "success": true,
  "today": {
    "total": 19,  <<<<<-- 48 ok 
    "Employee": 16,
    "Contractor": 3
  },
total is wrong,, correc total is 48
slove the isssue read below code carefully and slove hte issue 
this is corret 
Abi Nader, Fadi	Employee	322695	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Aghazada, Kanan	Employee	325710	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Anderson, Stacey-Ann Natasha	Employee	319488	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
Bekis-Sturo, Svetlana	Employee	242825	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Benimana, Geraldine	Employee	321868	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Blazys, Aurimas	Employee	319213	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Budreikaite, Justina	Employee	312782	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Deka, Uttara Robin	Employee	315321	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
Dobrovolskis, Marius	Employee	320831	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Elcin, Bunyamin	Employee	325182	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Fin, Talea	Employee	306334	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
George, Josen	Employee	319033	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
Girulskis, Raimondas	Employee	316618	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Grybeniene, Viktorija	Employee	314803	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Hina, Mutaz Mohammad Sami	Employee	307256	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
Jhorar, Kapil	Employee	326022	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Karpickis, Mantas	Employee	300844	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Keble, Onute	Employee	317403	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Kusi-Asante, Michelle	Employee	325004	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Laseviciene, Stasele	Contractor	W0021570	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Leonickaite, Ugne	Employee	320291	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Loufa, Hamza	Employee	321072	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Maciulskis, Ignas	Employee	320714	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Mahbub, Arif	Employee	322438	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Maquieira, Nicolas	Employee	328103	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Marhaba, Ahmed	Contractor	W0020932	Casablanca - 1100 Boulevard Al	MA.Casablanca	CardAdmitted	10/30/2025
Marostica, Dan	Employee	74908	Denver - WU HQ	LT.Vilnius	CardAdmitted	10/30/2025
Masiulyte, Meile	Employee	318523	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Maslova, Diana	Employee	328829	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Misevicius, Darius	Employee	303049	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Miskis, Tatjana	Contractor	W0014254	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Moradi, Moei	Employee	326933	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Nkwakep, Fandio Russel Franck	Employee	325529	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Ntoh Yuh, Juliette	Employee	322295	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Odio Amrhein, Diego	Employee	325736	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Panin, Dmitrij	Employee	305231	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Paskevicius, Kristijonas	Employee	321875	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Pelanis, Vilgirdas	Employee	323145	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Petrauskaite, Greta	Employee	313482	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Pietrzak, Danuta Anna	Property Management		Vienna	AUT.Vienna	CardAdmitted	10/30/2025
Pswarayi, Toziveyi	Employee	314605	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
Puikis, Vaidotas	Employee	322101	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
Sablinskaja, Helena	Contractor	W0024344	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Tamim, Marwa	Employee	305401	Dubai - Dubai Media City	DU.Abu Dhab	CardAdmitted	10/30/2025
Valiunas, Sigitas	Contractor	86142356	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Vilkaityte, Viktorija	Employee	309566	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025
VOLSKAJA, TERESA	Contractor	75183902	Vilnius - Technopolis	LT.Vilnius	CardAdmitted	10/30/2025
Zemlianskiene, Monika	Employee	316569	Vilnius - Gama Business Center	LT.Vilnius	CardAdmitted	10/30/2025



{
  "success": true,
  "today": {
    "total": 19,
    "Employee": 16,
    "Contractor": 3
  },
  "realtime": {
    "LT.Vilnius": {
      "total": 6,
      "Employee": 5,
      "Contractor": 1,
      "floors": {
        "9th Floor": 3,
        "1st Floor": 3
      }
    },
    "RU.Moscow": {   ths a  this alos wrong 
      "total": 1,
      "Employee": 0,
      "Contractor": 1,
      "floors": {
        "Moscow": 1
      }
    }
  },
  "details": [
    {
      "ObjectName1": "Pelanis, Vilgirdas",
      "Door": "EMEA_LT_VNO_GAMA_9th Flr_Main Entrance",
      "PersonnelType": "Employee",
      "EmployeeID": "323145",
      "CardNumber": "607682",
      "PartitionName2": "LT.Vilnius",
      "LocaleMessageTime": "2025-10-29T23:51:02.000Z",
      "Direction": "InDirection",
      "PersonGUID": "E658E8DA-8A35-4DC3-8026-595641F1A368",
      "CompanyName": "WU Processing Lithuania, UAB",
      "PrimaryLocation": "Vilnius - Gama Business Center",
      "Floor": "9th Floor"
    },
    {
      "ObjectName1": "Moradi, Moei",
      "Door": "EMEA_LT_VNO_GAMA_9th Flr_Main Entrance",
      "PersonnelType": "Employee",
      "EmployeeID": "326933",
      "CardNumber": "615016",
      "PartitionName2": "LT.Vilnius",
      "LocaleMessageTime": "2025-10-29T22:12:14.000Z",
      "Direction": "InDirection",
      "PersonGUID": "27135A48-87C2-4D72-B755-6EE734AB4C4C",
      "CompanyName": "WU Processing Lithuania, UAB",
      "PrimaryLocation": "Vilnius - Technopolis",
      "Floor": "9th Floor"
    },
    {
      "ObjectName1": "Valiunas, Sigitas",
      "Door": "EMEA_LT_VNO_GAMA_1st Flr_Security Room",
      "PersonnelType": "Contractor",
      "EmployeeID": "86142356",
      "CardNumber": "615409",
      "PartitionName2": "LT.Vilnius",
      "LocaleMessageTime": "2025-10-29T23:47:07.000Z",
      "Direction": "InDirection",
      "PersonGUID": "EF662CB7-25AF-4D49-8B3D-7C7D843CFE5A",
      "CompanyName": "G4S Lietuva, UAB (HCT)",
      "PrimaryLocation": "Vilnius - Technopolis",
      "Floor": "1st Floor"
    },
    {
      "ObjectName1": "Technical staff 3, Moscow",
      "Door": "EMEA_RU_Moscow_main entrance",
      "PersonnelType": "Property Management",
      "EmployeeID": "",
      "CardNumber": "201858",
      "PartitionName2": "RU.Moscow",
      "LocaleMessageTime": "2025-10-29T21:06:53.000Z",
      "Direction": "InDirection",
      "PersonGUID": "6B7E4C5E-D340-4818-99C4-A5BD4935C658",
      "CompanyName": "",
      "PrimaryLocation": "Moscow, Russia",
      "Floor": "Moscow"
    },
    {
      "ObjectName1": "Jhorar, Kapil",
      "Door": "EMEA_LTU_VNO_GAMA_1st Floor_Community Space",
      "PersonnelType": "Employee",
      "EmployeeID": "326022",
      "CardNumber": "614631",
      "PartitionName2": "LT.Vilnius",
      "LocaleMessageTime": "2025-10-29T23:14:06.000Z",
      "Direction": "InDirection",
      "PersonGUID": "121818E7-1C6F-4133-952F-AEA4B69C6C49",
      "CompanyName": "WU Processing Lithuania, UAB",
      "PrimaryLocation": "Vilnius - Gama Business Center",
      "Floor": "1st Floor"
    },
    {
      "ObjectName1": "Mahbub, Arif",
      "Door": "EMEA_LT_VNO_GAMA_9th Flr_Main Entrance",
      "PersonnelType": "Employee",
      "EmployeeID": "322438",
      "CardNumber": "607293",
      "PartitionName2": "LT.Vilnius",
      "LocaleMessageTime": "2025-10-29T22:37:40.000Z",
      "Direction": "InDirection",
      "PersonGUID": "25E51F35-1F49-44F2-BA69-C26F12D5D02C",
      "CompanyName": "WU Processing Lithuania, UAB",
      "PrimaryLocation": "Vilnius - Gama Business Center",
      "Floor": "9th Floor"
    },
    {
      "ObjectName1": "Aghazada, Kanan",
      "Door": "EMEA_LTU_VNO_GAMA_1st Floor_Community Space",
      "PersonnelType": "Employee",
      "EmployeeID": "325710",
      "CardNumber": "614745",
      "PartitionName2": "LT.Vilnius",
      "LocaleMessageTime": "2025-10-29T23:11:28.000Z",
      "Direction": "InDirection",
      "PersonGUID": "332D1672-F7C6-4623-8A28-D8B378C75988",
      "CompanyName": "WU Processing Lithuania, UAB",
      "PrimaryLocation": "Vilnius - Gama Business Center",
      "Floor": "1st Floor"
    }
  ]
}

//C:\Users\W0024618\Desktop\emea-occupancy-backend\src\services\occupancy.service.js
const { poolPromise, sql } = require('../config/db');

/**
 * EMEA partition list
 */
const partitionList = [
  'AUT.Vienna',
  'DU.Abu Dhab',
  'IE.Dublin',
  'IT.Rome',
  'LT.Vilnius',
  'MA.Casablanca',
  'RU.Moscow',
  'UK.London',
  'ES.Madrid'
];


/**
 * Live occupancy (today)
 */
exports.fetchLiveOccupancy = async () => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');

  const query = `
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2            AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                       AS EmployeeID,
        t2.text5                  AS Text5,
        t1.PartitionName2         AS PartitionName2,
        t1.ObjectIdentity1        AS PersonGUID,
        t3.Name                   AS PersonnelType,
        t2.Text4                   AS CompanyName,   -- âœ… company
        t2.Text5                   AS PrimaryLocation, -- âœ… location
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                         AS CardNumber,
        t5a.value                 AS AdmitCode,
        t5d.value                 AS Direction
      FROM [ACVSUJournal_00011029].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 IN (${partitionsSql})
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            = CONVERT(DATE, GETDATE())
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8), LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      Door,
      PersonnelType,
      CardNumber,
      Text5,
      PartitionName2,
      AdmitCode,
      Direction,
      CompanyName,
      PrimaryLocation
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `;

  const result = await pool.request().query(query);
  return result.recordset;
};

/**
 * Core rawâ€data fetch for the past N days, all or by location.
 */
exports.fetchHistoricalData = async ({ days = 7, location = null }) => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');
  const locationFilter = location
    ? `AND t1.PartitionName2 = @location`
    : `AND t1.PartitionName2 IN (${partitionsSql})`;

  const query = `
    WITH Hist AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2       AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                   AS EmployeeID,
        t2.text5             AS Text5,
        t1.PartitionName2    AS PartitionName2,
        t1.ObjectIdentity1   AS PersonGUID,
        t3.Name              AS PersonnelType,
        t2.Text4                   AS CompanyName,   -- âœ… company
     t2.Text5                   AS PrimaryLocation, -- âœ… location
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                     AS CardNumber,
        t5a.value            AS AdmitCode,
        t5d.value            AS Direction,
        CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) AS SwipeDate
      FROM [ACVSUJournal_00011029].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        ${locationFilter}
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            >= DATEADD(DAY, -${days}, CONVERT(DATE, GETDATE()))
    )
    SELECT *
    FROM Hist
    ORDER BY LocaleMessageTime ASC;
  `;

  const req = pool.request();
  if (location) req.input('location', sql.NVarChar, location);
  const result = await req.query(query);
  return result.recordset;
};

/**
 * Public wrapper: always last 7 days, all or by location.
 */
exports.fetchHistoricalOccupancy = async (location) => {
  return exports.fetchHistoricalData({ days: 7, location: location || null });
};

module.exports.partitionList = partitionList;


// C:\Users\W0024618\Desktop\emea-occupancy-backend\src\controllers\occupancy.controller.js

const service = require('../services/occupancy.service');
 const doorMap = require('../utils/doorMap'); 
 const timezones = require('../utils/timezones');
//  const normalize  = name => name.trim();        // simple normalizer

 const normalize = s =>
   s
     .trim()
     .toLowerCase()
     .replace(/[^a-z0-9]+/g, ' ')   // non-alphanum â†’ space
     .replace(/\s+/g, ' ')          // collapse multi-spaces
     .trim();

/**
 * Returns true if this PersonnelType counts as Employee.
 * Everything else (including blank) counts as Contractor.
 */
function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

/**
 * Look up floor for a given record by matching door + partition.
 */

function lookupFloor(partition, door, direction, unmappedSet) {
  const normDoor = normalize(door);
  // 1) try exact (post-normalization)
  let entry = doorMap.find(d =>
    d.partition === partition &&
    normalize(d.door) === normDoor
  );
  // 2) fallback: partial match if exact fails
  if (!entry) {
    entry = doorMap.find(d =>
      d.partition === partition &&
      normalize(d.door).includes(normDoor)
    );
  }
  if (!entry) {
    unmappedSet.add(`${partition} | ${door}`);
    return null;
  }
  return direction === 'InDirection'
    ? entry.inDirectionFloor
    : entry.outDirectionFloor;
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};


// exports.getLiveSummary = async (req, res) => {
//   try {
//     const swipes = await service.fetchLiveOccupancy();

//     // 1. TODAYâ€™S HEADCOUNT: first swipe per person
//     const firstByPerson = {};
//     swipes.forEach(r => {
//       const prev = firstByPerson[r.PersonGUID];
//       const t = new Date(r.LocaleMessageTime).getTime();
//       if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
//         firstByPerson[r.PersonGUID] = r;
//       }
//     });
//     const todayRecs = Object.values(firstByPerson);
//     const today = { total: 0, Employee: 0, Contractor: 0 };
//     todayRecs.forEach(r => {
//       today.total++;
//       if (isEmployeeType(r.PersonnelType)) today.Employee++;
//       else today.Contractor++;
//     });

//     // 2. REAL-TIME: last swipe per person
//     const lastByPerson = {};
//     swipes.forEach(r => {
//       const prev = lastByPerson[r.PersonGUID];
//       const t = new Date(r.LocaleMessageTime).getTime();
//       if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
//         lastByPerson[r.PersonGUID] = r;
//       }
//     });

//     const realtime = {};
//     const unmappedDoors = new Set();

//     Object.values(lastByPerson).forEach(r => {
//       // Resolve floor up-front (this will also populate unmappedDoors if necessary)
//       const rawFloor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
//       const floorNorm = rawFloor ? String(rawFloor).trim().toLowerCase() : '';

//       // STRICT RULE: if resolved Floor equals "Out of office" -> skip counting
//       if (floorNorm === 'out of office') {
//         return;
//       }

//       // Continue with existing OutDirection logic only if needed (original intent preserved)
//       // (Note: we already removed any record whose mapped floor is "Out of office" regardless of direction)

//       const p = r.PartitionName2;
//       if (!realtime[p]) {
//         realtime[p] = { total: 0, Employee: 0, Contractor: 0, floors: {} };
//       }

//       realtime[p].total++;
//       if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
//       else realtime[p].Contractor++;

//       const normFloorLabel = rawFloor ? String(rawFloor).trim() : 'Unmapped';
//       realtime[p].floors[normFloorLabel] = (realtime[p].floors[normFloorLabel] || 0) + 1;
//     });

//     if (unmappedDoors.size) {
//       console.warn('Unmapped doors:\n' + Array.from(unmappedDoors).join('\n'));
//     }

//     // Build enriched details array, but filter out any whose resolved Floor is "Out of office"
//     const details = Object.values(lastByPerson)
//       .map(r => {
//         const rawFloor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
//         const floor = rawFloor ? String(rawFloor).trim() : null;
//         return {
//           ...r,
//           Floor: floor
//         };
//       })
//       // Strictly remove records whose Floor is "Out of office"
//       .filter(d => {
//         const f = d.Floor;
//         return !(f && String(f).trim().toLowerCase() === 'out of office');
//       });

//     return res.json({
//       success: true,
//       today,
//       realtime,
//       details
//     });
//   } catch (err) {
//     console.error(err);
//     return res.status(500).json({ success: false, message: 'Live summary failed' });
//   }
// };






// ðŸ“ðŸ“ðŸ“ðŸ“ðŸ“ new code wiht time zone  â¬‡ï¸â¬‡ï¸start

// ðŸ“ Updated getLiveSummary â€” enforces partition-local "today" for both today + realtime
exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // helper: returns YYYY-MM-DD for a given date in the partition's timezone
    function getLocalDateString(dateInput, partition) {
      const tz = timezones[partition] || 'UTC';
      try {
        const d = new Date(dateInput);
        return new Intl.DateTimeFormat('en-CA', { timeZone: tz }).format(d);
      } catch (e) {
        return new Date(dateInput).toISOString().slice(0, 10);
      }
    }

    // PRE-CALCULATE "today" per partition (so we don't call Intl repeatedly)
    const partitionToday = {};
    swipes.forEach(r => {
      const p = r.PartitionName2;
      if (!partitionToday[p]) {
        partitionToday[p] = getLocalDateString(new Date(), p);
      }
    });

    // --- 1) TODAYâ€™S HEADCOUNT: first swipe per person but ONLY for swipes where
    // the swipe's partition-local date === that partition's current local date.
    const filteredSwipesForToday = swipes.filter(r => {
      const p = r.PartitionName2;
      return getLocalDateString(r.LocaleMessageTime, p) === partitionToday[p];
    });

    const firstByPerson = {};
    filteredSwipesForToday.forEach(r => {
      const prev = firstByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
        firstByPerson[r.PersonGUID] = r;
      }
    });

    const todayRecs = Object.values(firstByPerson);
    const today = { total: 0, Employee: 0, Contractor: 0 };
    todayRecs.forEach(r => {
      today.total++;
      if (isEmployeeType(r.PersonnelType)) today.Employee++;
      else today.Contractor++;
    });

    // --- 2) REALTIME: build lastByPerson, but only from swipes that are on the partition's LOCAL "today".
    // This removes partitions that only have older swipes.
    const lastByPerson = {};
    swipes.forEach(r => {
      const p = r.PartitionName2;
      // skip any swipe that is NOT on this partition's current local date
      if (getLocalDateString(r.LocaleMessageTime, p) !== partitionToday[p]) return;

      const prev = lastByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });

    // Build realtime counts only from the filtered lastByPerson
    const realtime = {};
    const unmappedDoors = new Set();

    Object.values(lastByPerson).forEach(r => {
      const rawFloor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
      const floorNorm = rawFloor ? String(rawFloor).trim().toLowerCase() : '';

      // STRICT: drop 'Out of office' from realtime details and counts
      if (floorNorm === 'out of office') return;

      const p = r.PartitionName2;
      if (!realtime[p]) {
        realtime[p] = { total: 0, Employee: 0, Contractor: 0, floors: {} };
      }

      realtime[p].total++;
      if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else realtime[p].Contractor++;

      const normFloorLabel = rawFloor ? String(rawFloor).trim() : 'Unmapped';
      realtime[p].floors[normFloorLabel] = (realtime[p].floors[normFloorLabel] || 0) + 1;
    });

    if (unmappedDoors.size) {
      console.warn('Unmapped doors:\n' + Array.from(unmappedDoors).join('\n'));
    }

    // details: use the filtered lastByPerson values (and drop Out of office)
    const details = Object.values(lastByPerson)
      .map(r => {
        const rawFloor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
        const floor = rawFloor ? String(rawFloor).trim() : null;
        return { ...r, Floor: floor };
      })
      .filter(d => {
        const f = d.Floor;
        return !(f && String(f).trim().toLowerCase() === 'out of office');
      });

    return res.json({
      success: true,
      today,
      realtime,
      details
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};

// ðŸ“ðŸ“ðŸ“ðŸ“ðŸ“ðŸ“new code wiht time zone end




exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    const raw = await service.fetchHistoricalOccupancy(location);

    // first swipe per person per date
    const byDate = raw.reduce((acc, r) => {
      const iso = (r.LocaleMessageTime instanceof Date)
        ? r.LocaleMessageTime.toISOString()
        : r.LocaleMessageTime;
      const date = iso.slice(0,10);
      acc[date] = acc[date] || {};
      const prev = acc[date][r.PersonGUID];
      if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
        acc[date][r.PersonGUID] = { ...r, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    const summaryByDate = [];
    const details = [];

    Object.keys(byDate).sort().forEach(date => {
      const recs = Object.values(byDate[date]);
      details.push(...recs);

      // initialize counts
      const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
      const partitionCounts = {};

      recs.forEach(r => {
        regionCounts.total++;
        if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
        else regionCounts.Contractor++;

        if (!location) {
          const p = r.PartitionName2;
          if (!partitionCounts[p]) {
            partitionCounts[p] = { total: 0, Employee: 0, Contractor: 0 };
          }
          partitionCounts[p].total++;
          if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;
        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday:'long' }),
        region: location
          ? { name: location, ...regionCounts }
          : { name: 'EMEA', ...regionCounts },
        partitions: location ? undefined : partitionCounts
      });
    });

    return res.json({ success: true, summaryByDate, details });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};

