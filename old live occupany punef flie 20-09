


// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\liveOccupancyController.js


const { DateTime }   = require('luxon');
// const { poolConnect, pool, sql } = require('../config/db');
const { sql, getPool } = require('../config/db');

const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// track which doorâ†’zone keys we've already warned on
const warnedKeys = new Set();

//update
function getTodayString() {
  return DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');
}




function normalizeZoneKey(rawDoor, rawDir) {
  // 1) Ensure itâ€™s a string and trim whitespace
  let door = String(rawDoor || '').trim();

  // 2) Strip any "_HH:MM:SS" or "_XX:XX:XX" suffix (hex codes or times at end)
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');

  // 3) Collapse multiple spaces into one, then uppercase
  door = door.replace(/\s+/g, ' ').toUpperCase();

  // 4) Pick the direction token exactly as doorZoneMap expects
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';

  return `${door}___${dir}`;
}

/** Normalize "Last, First" or "First Last" â†’ lowercase "first last" */
function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

/**
 * Map a swipeâ€™s door+direction â†’ zone using exactly doorZoneMap.
 * If not in doorZoneMap, log once and return "Unknown Zone".
 * If OutDirection but not "Out of office", strip off " Zone" suffix.
 */
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = doorZoneMap[key];

  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('â›” Unmapped doorâ€“direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }

  // If it's an OutDirection but not the real "Out of office", remove trailing " Zone"
  if (rawDir === 'OutDirection' && zone !== 'Out of office') {
    return zone.replace(/\s+Zone$/i, '');
  }

  return zone;
}


async function fetchNewEvents(since) {
  // await the shared pool promise instead of poolConnect
  const pool = await getPool();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

// console.log('ðŸ”Ž [Pune] fetchNewEvents called with since =', since.toISOString());
  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
       DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       


        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >@since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // console.log(`ðŸ“¥ [Pune] fetched ${recordset.length} rows:`,
    // recordset.map(r => r.LocaleMessageTime.toISOString()));

  return recordset;
}



async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zoneRaw  = mapDoorToZone(Door, Direction);
    const zone     = zoneRaw && zoneRaw.toLowerCase();

 // â”€â”€â”€ 1) If we canâ€™t map door+direction to a valid zone, skip this event entirely. â”€â”€â”€
    //     (prevents "Unknown Zone" from ever entering uniquePeople/current)
    if (zoneRaw === 'Unknown Zone') {
      // We warned once in mapDoorToZone already; just ignore.
      continue;
    }

    const zoneLower = zoneRaw.toLowerCase();



    // 1) True "Out of office" â†’ full eviction
    if (Direction === 'OutDirection' && zone === 'out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      continue;
    }



if (Direction === 'OutDirection') {
  // Compare lowercased zone safely
  const zoneLower = String(zone).toLowerCase();

  // Only full eviction when it's the real "Out of office"
  if (zoneLower === 'out of office') {
    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  } else {
    // Keep the person in current headcount for all other OutDirection cases
    // Update their last-seen metadata (zone, door, Direction)
    uniquePeople.set(dedupKey, PersonnelType);
    current[dedupKey] = {
      Dateonly, Swipe_Time,
      EmployeeID, ObjectName1, CardNumber,
      PersonnelType,
      zone: zoneRaw,
      door: Door,
      Direction
    };
  }
  continue;
}



    // 3) InDirection â†’ normal check-in
    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType,
        zone: zoneRaw,
        door: Door,
        Direction
      };
      continue;
    }

    // 4) Catch-all eviction
    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  }

  // live headcounts (only from uniquePeople, which has already evicted all true out-of-office)
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  // Build zoneâ†’people map, but filter out any out-of-office at this final step too
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    const zKey = emp.zone.toLowerCase();
    if (zKey === 'out of office') continue;
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  // zoneDetails
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType]||0) + 1;
        return acc;
      }, {});
      return [ zone, { total: emps.length, byPersonnelType: byType, employees: emps } ];
    })
  );

  // floorBreakdown
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt]||0) + c;
    }
  }


  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        // pick the correct name field (JSON uses "Name")
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);


        // find a matching swipe in current[]
        const matchEvt = Object.values(current).find(e => {
          return normalizePersonName(e.ObjectName1) === expected;
        });

        return {
          ...m,
          present: !!matchEvt,
          zone:    matchEvt ? matchEvt.zone : null
        };
     });
      return [ role, list ];
    })
  );



  return {
    asOf:             new Date().toISOString(),
    summary:          Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown:    Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown:   Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
     ertStatus,
  

  personnelBreakdown: (() => {
    const map = new Map();
    // uniquePeople: Map<dedupKey, PersonnelType>
    for (const pt of uniquePeople.values()) {
      map.set(pt, (map.get(pt) || 0) + 1);
    }
    return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
  })(),



  };
}

// ##########################################
// ##########################################
// ##########################################

// function buildVisitedToday(allEvents) {
//   // â€œTodayâ€ in Asia/Kolkata, formatted as â€œyyyy-MM-ddâ€
//   const today = DateTime.now()
//     .setZone('Asia/Kolkata')
//     .toFormat('yyyy-LL-dd');

//   // Use evt.Dateonly (already â€œyyyy-MM-ddâ€ in local zone) to pick out today's InDirection swipes
//   const todayIns = allEvents.filter(evt => {
//     return (
//       evt.Direction === 'InDirection' &&
//       evt.Dateonly === today
//     );
//   });

//   // Dedupe by PersonGUID â†’ keep the latest swipe
//   const dedup = new Map();
//   for (const e of todayIns) {
//     const key = e.PersonGUID;
//     const prev = dedup.get(key);
//     if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
//       dedup.set(key, e);
//     }
//   }

//   const finalList = Array.from(dedup.values());

//   // Separate employees vs contractors
//   const employees = finalList.filter(e =>
//     !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
//       .includes(e.PersonnelType)
//   ).length;
//   const contractors = finalList.length - employees;

//   return { employees, contractors, total: finalList.length };
// }


// ##########################################
// ##########################################
// ##########################################



// ________________________________________________________________________
// _________________________NEW CODE_______________________________________
// ________________________________________________________________________

/**
 * Build â€œvisited todayâ€ from the same inâ€memory stream
 *
 * @param {Array} allEvents  - events where evt.Dateonly is already local yyyy-MM-dd
 * @param {DateTime|Date|string} [asOf] - optional Luxon DateTime, JS Date or yyyy-MM-dd string.
 *                                       If provided, "today" will be computed from this instead
 *                                       of DateTime.now().setZone('Asia/Kolkata').
 */
function buildVisitedToday(allEvents, asOf) {
  // Determine "today" in Asia/Kolkata:
  let today;
  if (asOf) {
    // Accept Luxon DateTime, JS Date, or plain yyyy-MM-dd string
    if (typeof asOf === 'string') {
      today = asOf; // assume already 'yyyy-LL-dd'
    } else if (asOf instanceof Date) {
      today = DateTime.fromJSDate(asOf, { zone: 'Asia/Kolkata' }).toFormat('yyyy-LL-dd');
    } else if (asOf && typeof asOf.toFormat === 'function') {
      // assume Luxon DateTime
      today = asOf.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    } else {
      // fallback to now
      today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    }
  } else {
    // default behaviour: "today" is now in Kolkata
    today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
  }

  // Use evt.Dateonly (already â€œyyyy-MM-ddâ€ in local zone) to pick out today's InDirection swipes
  const todayIns = allEvents.filter(evt => {
    return (
      evt.Direction === 'InDirection' &&
      evt.Dateonly === today
    );
  });

  // Dedupe by PersonGUID â†’ keep the latest swipe
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID; // same as original logic
    const prev = dedup.get(key);
    // Compare LocaleMessageTime lexicographically is fine for ISO strings; keep original behavior
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  // Separate employees vs contractors (preserve original classification list)
  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}


// ________________________________________________________________________
// ________________________________________________________________________
// ________________________________________________________________________


/** Serverâ€Sentâ€Events endpoint */
exports.getLiveOccupancy = async (req, res) => {
 

  try {
    // wait for the shared pool to be ready
    await getPool();

    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    // pull last 24h on startup
    // let lastSeen = new Date(Date.now() - 24*60*60*1000);
    let lastSeen = new Date();
    const events = [];

    const push = async () => {




    // Option B: Recompute date from the JS timestamp in Asia/Kolkata:
    const todayKolkata = DateTime.now().setZone('Asia/Kolkata').toISODate();
    for (let i = events.length - 1; i >= 0; i--) {
      const ts = DateTime.fromJSDate(events[i].LocaleMessageTime, { zone: 'utc' })
                     .setZone('Asia/Kolkata')
                     .toISODate();
      if (ts !== todayKolkata) {
        events.splice(i, 1);
      }
    }


//  console.log('ðŸ”„ [PUSH] Running at:', new Date().toISOString());
  // console.log('ðŸ” Last seen swipe time:', lastSeen);


      const fresh = await fetchNewEvents(lastSeen);

      //  console.log('ðŸ“¥ New events fetched:', fresh.length);




      if (fresh.length) {
        // lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
         lastSeen = new Date();
        events.push(...fresh);
      }

    

      // build occupancy + today counts
      const occupancy  = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday      = {
        employees:   todayStats.employees,
        contractors: todayStats.contractors,
        total:       todayStats.total
      };

   


      // add an `id:` so EventSource treats even identical payloads as â€œnewâ€
      
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);

    
      if (typeof res.flush === 'function') {
        res.flush();
      }

     };
    await push();
    const timer = setInterval(push, 2000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};



// GET /api/occupancy-at-time-pune?date=YYYY-MM-DD&time=HH:MM[:SS]
exports.getPuneSnapshotAtDateTime = async (req, res) => {
  try {
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({
        error: 'missing query params: expected ?date=YYYY-MM-DD&time=HH:MM[:SS]'
      });
    }

    // Validate date
    const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(date);
    if (!dateMatch) {
      return res.status(400).json({ error: 'invalid "date" format; expected YYYY-MM-DD' });
    }

    // Validate time
    const timeMatch = /^([0-1]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/.exec(time);
    if (!timeMatch) {
      return res.status(400).json({ error: 'invalid "time" format; expected HH:MM or HH:MM:SS' });
    }

    const year   = Number(dateMatch[1]);
    const month  = Number(dateMatch[2]);
    const day    = Number(dateMatch[3]);
    const hour   = Number(timeMatch[1]);
    const minute = Number(timeMatch[2]);
    const second = timeMatch[3] ? Number(timeMatch[3]) : 0;

    // Build Pune-local datetime
    const atDt = DateTime.fromObject(
      { year, month, day, hour, minute, second, millisecond: 0 },
      { zone: 'Asia/Kolkata' }
    );

    if (!atDt.isValid) {
      return res.status(400).json({ error: 'invalid date+time combination' });
    }

    // Convert to UTC for SQL boundary
    const untilUtc = atDt.setZone('utc').toJSDate();

    // -----------------
    // Step 1: fetch events in 24h window ending at atDt
    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('until', sql.DateTime2, untilUtc);

    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,   -- always UTC
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          COALESCE(
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
            sc.value
          ) AS CardNumber,
          t5a.value AS AdmitCode,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
          ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType     = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC <= @until
          AND DATEADD(HOUR, -24, @until) < t1.MessageUTC
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    // -----------------
    // Step 2: convert UTC â†’ Asia/Kolkata
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' })
                            .setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // -----------------
    // Step 3: filter only same Pune date
    const targetDate = atDt.toFormat('yyyy-LL-dd');
    const filtered = events.filter(e => e.Dateonly === targetDate);

    // Step 4: build occupancy snapshot
    const occupancy = await buildOccupancy(filtered);

    // Step 5: visited-today counts aligned to atDt
    // const visitedStats = buildVisitedToday(filtered);
    
    const visitedStats = buildVisitedToday(filtered, atDt);  // this add new code as per function buildVisitedToday change ðŸ“ ðŸ“

    // ---- Output timestamps ----
    occupancy.asOfLocal = atDt.toISO(); // Pune-local with offset
    occupancy.asOfUTC   = `${date}T${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}:${String(second).padStart(2,'0')}Z`;

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = visitedStats;

    return res.json(occupancy);
  } catch (err) {
    console.error('getPuneSnapshotAtDateTime error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};

// //////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////\


// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    const startUtc = start.setZone('utc').toJSDate();
    const endUtc   = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    const { recordset } = await reqDb.query(`
      SELECT
        t1.MessageUTC,
        t1.ObjectName1,  -- Person name
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND t1.MessageUTC BETWEEN @start AND @end
      ORDER BY t1.MessageUTC ASC;
    `);

    // Convert to Pune local time
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toJSDate(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Get all dates in the month
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // Group by day
    const byDay = new Map();
    for (const evt of events) {
      if (!byDay.has(evt.Dateonly)) byDay.set(evt.Dateonly, []);
      byDay.get(evt.Dateonly).push(evt);
    }

    const dailySummaries = [];
    const peakOccupancy = [];
    const visitCounter = new Map();       // track total visits
    const presenceByPerson = new Map();   // track which days each person was present

    // Process each day
    for (const [date, dayEvents] of byDay.entries()) {
      // --- Unique daily headcount ---
      const uniquePeople = new Set(dayEvents.map(e => e.PersonGUID));
      dailySummaries.push({ date, total: uniquePeople.size });

      // --- Peak occupancy counter ---
      let currentCount = 0;
      let maxCount = 0;
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') {
          currentCount++;
        } else if (e.Direction === 'OutDirection') {
          currentCount = Math.max(0, currentCount - 1);
        }
        if (currentCount > maxCount) maxCount = currentCount;
      }
      peakOccupancy.push({ date, peak: maxCount });

      // --- Track visits & attendance ---
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') {
          const key = e.PersonGUID || e.EmployeeID || e.ObjectName1;

          // Track visits
          if (!visitCounter.has(key)) {
            visitCounter.set(key, {
              count: 0,
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType
            });
          }
          visitCounter.get(key).count++;

          // Track attendance
          if (!presenceByPerson.has(key)) {
            presenceByPerson.set(key, {
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType,
              days: new Set()
            });
          }
          presenceByPerson.get(key).days.add(date);
        }
      }
    }

    // --- Final aggregates ---
    const avgDailyHeadcount =
      dailySummaries.reduce((sum, d) => sum + d.total, 0) / dailySummaries.length || 0;

    const top10 = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({
        employeeId: v.employeeId,
        name: v.name,
        personnelType: v.personnelType,
        visits: v.count
      }));

    // --- Attendance sheet ---
    const attendanceSheet = Array.from(presenceByPerson.values()).map(p => {
      const daily = {};
      let presentCount = 0;

      for (const d of allDates) {
        if (p.days.has(d)) {
          daily[d] = "P"; // Present
          presentCount++;
        } else {
          daily[d] = "A"; // Absent
        }
      }

      return {
        employeeId: p.employeeId,
        name: p.name,
        personnelType: p.personnelType,
        ...daily,
        daysPresent: presentCount,
        daysAbsent: allDates.length - presentCount,
        attendancePercent: ((presentCount / allDates.length) * 100).toFixed(1) + "%"
      };
    });

    return res.json({
      month,
      avgDailyHeadcount: Math.round(avgDailyHeadcount),
      peakOccupancy,
      top10Visitors: top10,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};




////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////









// src/components/FloorInOutTable.jsx
import React, { useEffect, useMemo, useState } from 'react';
import { Card, Table, Modal, OverlayTrigger, Tooltip, Button } from 'react-bootstrap';

import * as XLSX from 'xlsx'

// Accent palette (gold / yellow)
const GOLD = '#FFC72C';
const GOLD_DEEP = '#FFDD00';
const BLACK_BG = '#0b0b0b';
// const ROW_COLORS = [GOLD, '#C9A9A6', '#FFE680', '#FFF5EE', '#FFD11A', '#96DED1', '#FFEB99'];

 // small helpers for theme
  const headerStyle = { background: GOLD_DEEP, color: '#000', fontWeight: '700' };
  const modalHeaderStyle = { background: BLACK_BG, color: GOLD, borderBottom: `2px solid ${GOLD_DEEP}` };
  const footerBtnStyle = { background: GOLD_DEEP, borderColor: GOLD_DEEP, color: '#000' };


// Accent palette
const ROW_COLORS = [
  '#FFC72C', '#C9A9A6', '#FFE680',
  '#FFF5EE', '#FFD11A', '#96DED1', '#FFEB99',
];

// Security Employee IDs (hardcoded)
const SECURITY_IDS = [
  "W0023386", "W0026455", "W0028120","62082475","W0027913","C676439","W0026151","W0027745"
].map(id => id.toUpperCase());

const normalizeId = v => String(v || '').trim().toUpperCase();

// normalize floor names so "Floor 01" == "Floor 1"
const normalizeFloorName = (f) => {
  if (!f && f !== 0) return '';
  return String(f).replace(/^Floor\s0*/, 'Floor ').trim();
};



// Export helpers for rejections (creates a nicer Excel workbook with a small summary sheet)
const mapRejectionForExport = (r) => {
  let localDate = '';
  let localTime = '';
  try {
    if (r.LocaleMessageTime) {
      const dt = new Date(r.LocaleMessageTime);
      localDate = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
      localTime = dt.toLocaleTimeString('en-GB', { timeZone: 'America/Denver' });
    } else if (r.DateOnly) {
      localDate = (typeof r.DateOnly === 'string' ? r.DateOnly.slice(0,10) : new Date(r.DateOnly).toISOString().slice(0,10));
      localTime = r.SwipeTime || '';
    }
  } catch (e) {
    localDate = (r.DateOnly || '').slice(0,10);
    localTime = r.SwipeTime || '';
  }

  return {
    Date: localDate,
    Time: localTime,
    Name: r.ObjectName1 || '',
    EmployeeID: r.EmployeeID || '',
    CardNumber: r.CardNumber || '',
    PersonnelType: r.PersonnelType || '',
    Door: r.Door || r.Location || '',
    RejectionType: r.RejectionType || '',
    DerivedFloor: deriveFloorFromRecord(r) || ''
  };
};

const exportRejectionsToExcel = (rows, fileName = 'rejections.xlsx') => {
  if (!rows || rows.length === 0) return;
  const mapped = rows.map(mapRejectionForExport);

  // main sheet
  const ws = XLSX.utils.json_to_sheet(mapped, { header: ['Date','Time','Name','EmployeeID','CardNumber','PersonnelType','Door','RejectionType','DerivedFloor'] });

  // set some column widths for a nicer look
  ws['!cols'] = [
    { wch: 6 },  // index column (we'll keep # when viewing)
    { wch: 12 }, // Date
    { wch: 10 }, // Time
    { wch: 28 }, // Name
    { wch: 14 }, // EmployeeID
    { wch: 14 }, // CardNumber
    { wch: 16 }, // PersonnelType
    { wch: 48 }, // Door
    { wch: 20 }, // RejectionType
    { wch: 12 }  // DerivedFloor
  ];

  // Summary sheet with small metadata
  const summary = [
    { Key: 'Export Date', Value: new Date().toLocaleString('en-CA') },
    { Key: 'Record Count', Value: mapped.length },
    { Key: 'Generated By', Value: 'FloorInOutTable' }
  ];
  const wsSummary = XLSX.utils.json_to_sheet(summary);
  wsSummary['!cols'] = [{ wch: 20 }, { wch: 30 }];

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Rejections');
  XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

  // force download
  XLSX.writeFile(wb, fileName);
};






// Try to extract floor number from Door/Location strings robustly
function deriveFloorFromRecord(rec) {
  // Prefer explicit floor field if present
  if (rec.floor && String(rec.floor).trim()) return normalizeFloorName(rec.floor);

  const door = String(rec.Door || rec.door || rec.Location || '').trim();

  if (!door) return 'Unknown';

  // Common patterns: "US.CO.HQ. 12. South ..." or "US.CO.HQ. 06" or "US.CO.HQ 12"
  // Look for HQ[.]? <num>
  const mHQ = door.match(/HQ[.\s]*\s*(\d{1,2})\b/i);
  if (mHQ && mHQ[1]) return `Floor ${parseInt(mHQ[1], 10)}`;

  // Sometimes the floor appears right after the site prefix (e.g. "US.CO.HQ 6")
  const mSimple = door.match(/\b(\d{1,2})\b/);
  if (mSimple && mSimple[1]) {
    // extra guard: don't accidentally pick small numbers from serials like "11:01:0A"
    // require that the matched number is followed by a dot, space, or end-of-string (typical in " 12." or " 12 ")
    const idx = door.indexOf(mSimple[1]);
    if (idx !== -1) {
      const after = door[idx + mSimple[1].length] || '';
      if (after === '' || /\s|\./.test(after)) {
        return `Floor ${parseInt(mSimple[1], 10)}`;
      }
    }
  }

  // If Location contains 'Floor X'
  const mFloorText = door.match(/Floor\s*(\d{1,2})/i);
  if (mFloorText && mFloorText[1]) return `Floor ${parseInt(mFloorText[1], 10)}`;

  return 'Unknown';
}

export default function FloorInOutTable({
  data = [],
  floorBreakdown = [],
  floorInOutSummary = []
  
}) {
  const securitySet = useMemo(() => new Set(SECURITY_IDS), []);

  // Security modal state
  const [showSecurityModal, setShowSecurityModal] = useState(false);
  const [selectedFloorSecurity, setSelectedFloorSecurity] = useState(null);
  const [selectedPeopleSecurity, setSelectedPeopleSecurity] = useState([]);

  // Rejection state (today only)
  const [rejectionDetails, setRejectionDetails] = useState({}); // { normFloor -> [records...] }
  const [rejectionSummaryMap, setRejectionSummaryMap] = useState({}); // { normFloor -> count }
  const [rejectionAllDetailsToday, setRejectionAllDetailsToday] = useState([]); // flat array of today's details
  const [rejectionsLoading, setRejectionsLoading] = useState(false);

  // Modal for showing today's rejection list
  const [showRejectionModal, setShowRejectionModal] = useState(false);
  const [selectedRejectionFloor, setSelectedRejectionFloor] = useState(null);
  const [selectedRejectionList, setSelectedRejectionList] = useState([]);

  // NEW: modals for header-clicks (show ALL security across floors, show ALL rejections today)
  const [showAllSecurityModal, setShowAllSecurityModal] = useState(false);
  const [showAllRejectionsModal, setShowAllRejectionsModal] = useState(false);

  // Build securityByFloor from occupants & inOnlyPersons
  const securityByFloor = useMemo(() => {
    const byFloor = {};

    (floorBreakdown || []).forEach(fb => {
      const people = [];
      (fb.occupants || []).forEach(o => {
        const empId = normalizeId(o.EmployeeID);
        if (securitySet.has(empId)) people.push(o);
      });
      if (people.length) {
        byFloor[fb.floor] = (byFloor[fb.floor] || []).concat(people);
      }
    });

    (floorInOutSummary || []).forEach(f => {
      (f.inOnlyPersons || []).forEach(pid => {
        const empId = normalizeId(pid);
        if (securitySet.has(empId)) {
          byFloor[f.floor] = (byFloor[f.floor] || []).concat([
            { EmployeeID: empId, ObjectName1: "(Unknown)", Swipe_Time: "â€”", Door: "â€”", PersonnelType: "â€”" }
          ]);
        }
      });
    });

    return byFloor;
  }, [floorBreakdown, floorInOutSummary, securitySet]);

  // NEW: flattened security list (each item gets a floor property)
  const securityFlat = useMemo(() => {
    const arr = [];
    Object.keys(securityByFloor || {}).forEach(f => {
      (securityByFloor[f] || []).forEach(p => arr.push({ ...p, floor: f }));
    });
    return arr;
  }, [securityByFloor]);

  // --- fetch rejections and keep only today's (Denver) records ---
  useEffect(() => {
    let mounted = true;

    async function loadRejectionsTodayOnly() {
      setRejectionsLoading(true);
      try {
        const res = await fetch('/api/rejections');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();

        // today in Denver (YYYY-MM-DD)
        const todayDenver = new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' });

        // collect today's details (flat)
        let detailsToday = [];
        const summaryMap = {};

        // Prefer backend dateWise (aggregates) for counts if available
        if (Array.isArray(payload.dateWise)) {
          const dayObj = payload.dateWise.find(d => d.date === todayDenver);
          if (dayObj && Array.isArray(dayObj.floors)) {
            dayObj.floors.forEach(f => {
              const key = normalizeFloorName(f.floor || '');
              if (!key) return;
              summaryMap[key] = Number(f.rejectionCount || 0);
            });
          }
          // build detailsToday from payload.details so we can populate modal content
          if (Array.isArray(payload.details)) {
            detailsToday = payload.details.filter(d => {
              const raw = d.LocaleMessageTime || d.DateOnly || d.LocaleMessageTime;
              if (!raw) return false;
              try {
                const dt = new Date(raw);
                const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                return dtStr === todayDenver;
              } catch (e) {
                return String(raw).slice(0, 10) === todayDenver;
              }
            });
          }
        } else {
          // fallback: filter details for today and aggregate counts
          if (Array.isArray(payload.details)) {
            detailsToday = payload.details.filter(d => {
              const raw = d.LocaleMessageTime || d.DateOnly || d.LocaleMessageTime;
              if (!raw) return false;
              try {
                const dt = new Date(raw);
                const dtStr = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                return dtStr === todayDenver;
              } catch (e) {
                return String(raw).slice(0, 10) === todayDenver;
              }
            });

            // derive floor per record and increment summary
            detailsToday.forEach(d => {
              const derived = deriveFloorFromRecord(d) || 'Unknown';
              const key = normalizeFloorName(derived);
              summaryMap[key] = (summaryMap[key] || 0) + 1;
            });
          }
        }

        // group detailsToday by normalized floor (derive floor if missing)
        const detailsByFloor = {};
        detailsToday.forEach(d => {
          const derived = deriveFloorFromRecord(d) || 'Unknown';
          const key = normalizeFloorName(derived) || 'Unknown';
          detailsByFloor[key] = detailsByFloor[key] || [];
          detailsByFloor[key].push(d);
        });

        if (!mounted) return;
        setRejectionSummaryMap(summaryMap);
        setRejectionDetails(detailsByFloor);
        setRejectionAllDetailsToday(detailsToday);
      } catch (err) {
        console.error('Failed to load rejections:', err);
        if (mounted) {
          setRejectionSummaryMap({});
          setRejectionDetails({});
          setRejectionAllDetailsToday([]);
        }
      } finally {
        if (mounted) setRejectionsLoading(false);
      }
    }

    loadRejectionsTodayOnly();
    return () => { mounted = false; };
  }, []);

  // Build sorted rows and attach securityCount & today's rejectionCount
  const sorted = useMemo(() => {
    const rows = (Array.isArray(data) ? data : []).map(({ floor, inSwipes, outSwipes }) => {
      const normFloor = normalizeFloorName(floor);
      return {
        floor,
        normFloor,
        inSwipes: Number(inSwipes || 0),
        outSwipes: Number(outSwipes || 0),
        inconsistency: Number(inSwipes || 0) - Number(outSwipes || 0),
        securityCount: (securityByFloor[floor] || []).length,
        rejectionCount: rejectionSummaryMap[normFloor] || 0
      };
    });
    return rows.sort((a, b) => b.inconsistency - a.inconsistency);
  }, [data, securityByFloor, rejectionSummaryMap]);

  const top = sorted[0];

  const handleSecurityCellClick = (floor) => {
    const people = securityByFloor[floor] || [];
    if (people.length > 0) {
      setSelectedFloorSecurity(floor);
      setSelectedPeopleSecurity(people);
      setShowSecurityModal(true);
    }
  };

  // when user clicks the rejection cell, open modal and show today's details for that normalized floor
  const handleRejectionCellClick = (normFloor, displayFloor) => {
    let list = rejectionDetails[normFloor] || [];

    // fallback: if grouped list empty but we have a count, try scanning flat details for the floor number
    if ((!list || list.length === 0) && (rejectionSummaryMap[normFloor] || 0) > 0) {
      const numMatch = (normFloor && normFloor.match(/\d+/)) ? normFloor.match(/\d+/)[0] : null;
      if (numMatch && Array.isArray(rejectionAllDetailsToday)) {
        const regex = new RegExp(`\\b${numMatch}\\b`);
        list = rejectionAllDetailsToday.filter(d => {
          const door = String(d.Door || d.door || d.Location || '');
          return regex.test(door);
        });
      }
    }

    setSelectedRejectionFloor(displayFloor || normFloor);
    setSelectedRejectionList(list || []);
    setShowRejectionModal(true);
  };

  // NEW: header click handlers
  const handleSecurityHeaderClick = () => {
    if ((securityFlat || []).length > 0) setShowAllSecurityModal(true);
  };

  const handleRejectionHeaderClick = () => {
    if ((rejectionAllDetailsToday || []).length > 0) setShowAllRejectionsModal(true);
  };

  // Tooltip content uses rejectionDetails (already filtered to today)
  const renderRejectionTooltip = (floor) => {
    const nf = normalizeFloorName(floor);
    const byFloor = rejectionDetails[nf] || [];
    if (!byFloor.length) return 'No rejections today';
    const lines = [`Total today: ${byFloor.length}`, '', 'Recent:'];
    byFloor.slice(0, 6).forEach(d => {
      const date = d.LocaleMessageTime ? d.LocaleMessageTime.slice(0,10) : (d.DateOnly ? (typeof d.DateOnly === 'string' ? d.DateOnly.slice(0,10) : new Date(d.DateOnly).toISOString().slice(0,10)) : '');
      const time = d.SwipeTime || (d.LocaleMessageTime ? d.LocaleMessageTime.slice(11,19) : '');
      lines.push(`${date} ${time} â€” ${d.RejectionType || ''} â€” ${d.Door || d.Location || ''}`);
    });
    if (byFloor.length > 6) lines.push(`â€¦ +${byFloor.length - 6} more`);
    return lines.join('\n');
  };

  return (
    <>
      <Card className="mb-4 shadow-sm" style={{ background: '#1a1a1a', border: '2px solid #FFC72C' }}>
        <Card.Header className="text-center fw-bold" style={{ background: '#000', color: '#FFC72C' }}>
          Floor In vs Out Swipe Summary (Rejections â€” Today)
        </Card.Header>

        <Card.Body style={{ height: 450, padding: '1rem', overflowY: 'auto' }}>
          {top && (
            <div className="mb-3" style={{ color: '#fff', fontSize: '1rem' }}>
              Highest inconsistency:&nbsp;
              <span style={{ color: '#FFC72C', fontWeight: 'bold' }}>{top.inconsistency}</span>
              &nbsp;on&nbsp;
              <span style={{ color: '#FFC72C', fontWeight: 'bold' }}>{top.floor}</span>
            </div>
          )}

          <Table striped bordered hover size="sm" variant="dark" className="mb-0">
            <thead>
              <tr>
                <th>Floor</th>
                <th>In Swipes</th>
                <th>Out Swipes</th>
                <th>In âˆ’ Out</th>
                <th
                  style={{ cursor: (securityFlat && securityFlat.length) ? 'pointer' : 'default', textDecoration: (securityFlat && securityFlat.length) ? 'underline' : 'none' }}
                  onClick={handleSecurityHeaderClick}
                  title={securityFlat && securityFlat.length ? `Show all security (${securityFlat.length})` : 'No security'}
                >
                  Security
                </th>
                <th
                  style={{ cursor: (rejectionAllDetailsToday && rejectionAllDetailsToday.length) ? 'pointer' : 'default', textDecoration: (rejectionAllDetailsToday && rejectionAllDetailsToday.length) ? 'underline' : 'none' }}
                  onClick={handleRejectionHeaderClick}
                  title={rejectionAllDetailsToday && rejectionAllDetailsToday.length ? `Show all rejections today (${rejectionAllDetailsToday.length})` : 'No rejections today'}
                >
                  Rejection
                </th>
              </tr>
            </thead>

            <tbody>
              {sorted.map((row, idx) => (
                <tr key={row.floor} style={{ backgroundColor: row.securityCount > 0 ? '#333300' : undefined }}>
                  <td style={{ color: '#fff' }}>{row.floor}</td>
                  <td style={{ color: ROW_COLORS[idx % ROW_COLORS.length] }}>{row.inSwipes}</td>
                  <td style={{ color: ROW_COLORS[(idx + 1) % ROW_COLORS.length] }}>{row.outSwipes}</td>
                  <td style={{ color: ROW_COLORS[(idx + 2) % ROW_COLORS.length], fontWeight: 'bold' }}>
                    {row.inconsistency}
                  </td>

                  {/* Security cell - clickable only this cell */}
                  <td
                    style={{
                      color: row.securityCount > 0 ? '#FFC72C' : '#aaa',
                      fontWeight: row.securityCount > 0 ? 'bold' : 'normal',
                      cursor: row.securityCount > 0 ? 'pointer' : 'default',
                      textDecoration: row.securityCount > 0 ? 'underline' : 'none'
                    }}
                    onClick={() => { if (row.securityCount > 0) handleSecurityCellClick(row.floor); }}
                  >
                    {row.securityCount}
                  </td>

                  {/* Rejection cell (today only) - clickable to open modal */}
                  <td style={{
                    color: row.rejectionCount > 0 ? '#FFCCCB' : '#aaa',
                    fontWeight: row.rejectionCount > 0 ? 'bold' : 'normal',
                    cursor: row.rejectionCount > 0 ? 'pointer' : 'default'
                  }}>
                    {row.rejectionCount > 0 ? (
                      <OverlayTrigger
                        placement="top"
                        overlay={<Tooltip id={`rej-tip-${row.normFloor.replace(/\s+/g,'_')}`}>{renderRejectionTooltip(row.normFloor || row.floor)}</Tooltip>}
                      >
                        <span
                          onClick={() => handleRejectionCellClick(row.normFloor, row.floor)}
                          style={{ textDecoration: 'underline', display: 'inline-block' }}
                        >
                          {row.rejectionCount}
                        </span>
                      </OverlayTrigger>
                    ) : 0}
                  </td>
                </tr>
              ))}
            </tbody>
          </Table>
        </Card.Body>
      </Card>

      {/* Security Modal */}
      <Modal show={showSecurityModal} onHide={() => setShowSecurityModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title>Security Occupants - {selectedFloorSecurity}</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Table striped bordered hover size="sm">
            <thead>
              <tr>
                <th>EmployeeID</th>
                <th>Name</th>
                <th>Swipe Time</th>
                <th>Door</th>
                <th>Type</th>
              </tr>
            </thead>
            <tbody>
              {selectedPeopleSecurity.map((p, idx) => (
                <tr key={idx}>
                  <td>{p.EmployeeID}</td>
                  <td>{p.ObjectName1 || "(Unknown)"}</td>
                  <td>{p.Swipe_Time || "â€”"}</td>
                  <td>{p.Door || "â€”"}</td>
                  <td>{p.PersonnelType || "â€”"}</td>
                </tr>
              ))}
            </tbody>
          </Table>
        </Modal.Body>
      </Modal>


     
      {/* NEW: All Security Modal (header click) */}
      <Modal show={showAllSecurityModal} onHide={() => setShowAllSecurityModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title style={{ textAlign:'center' }}>All Security Occupants</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {(!securityFlat || securityFlat.length === 0) ? (
            <div>No security occupants found</div>
          ) : (
            <Table striped bordered hover size="sm">
              <thead >
                <tr>
                  <th>Sr.no</th>
                  <th>Floor</th>
                  <th>EmployeeID</th>
                  <th>Name</th>
                  <th>Swipe Time</th>
                  <th>Door</th>
                </tr>
              </thead>
              <tbody>
                {securityFlat.map((p, i) => (
                  <tr key={i}>
                    <td>{i + 1}</td>
                    <td>{p.floor}</td>
                    <td>{p.EmployeeID}</td>
                    <td>{p.ObjectName1 || '(Unknown)'}</td>
                    <td>{p.Swipe_Time || 'â€”'}</td>
                    <td style={{ maxWidth: 240, wordBreak: 'break-word' }}>{p.Door || 'â€”'}</td>
                  </tr>
                ))}
              </tbody>
            </Table>
          )}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowAllSecurityModal(false)}>Close</Button>
        </Modal.Footer>
      </Modal>

      {/* Rejection details modal (today) */}
      {/* <Modal show={showRejectionModal} onHide={() => setShowRejectionModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title>Rejections Today - {selectedRejectionFloor}</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {selectedRejectionList.length === 0 ? (
            <div>No rejections recorded today for {selectedRejectionFloor}</div>
          ) : (
            <Table striped bordered hover size="sm">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Date</th>
                  <th>Time</th>
                  <th>Name</th>
                  <th>EmployeeID</th>
                  <th>CardNumber</th>
                  <th>PersonnelType</th>
                  <th>Door</th>
                  <th>RejectionType</th>
                </tr>
              </thead>
              <tbody>
                {selectedRejectionList.map((r, i) => {
                  // try to format date/time nicely; r.LocaleMessageTime is ISO in UTC
                  let localDate = '';
                  let localTime = '';
                  try {
                    if (r.LocaleMessageTime) {
                      const dt = new Date(r.LocaleMessageTime);
                      localDate = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                      localTime = dt.toLocaleTimeString('en-GB', { timeZone: 'America/Denver' });
                    } else if (r.DateOnly) {
                      localDate = (typeof r.DateOnly === 'string' ? r.DateOnly.slice(0,10) : new Date(r.DateOnly).toISOString().slice(0,10));
                      localTime = r.SwipeTime || '';
                    }
                  } catch (e) {
                    localDate = (r.DateOnly || '').slice(0,10);
                    localTime = r.SwipeTime || '';
                  }

                  return (
                    <tr key={i}>
                      <td>{i + 1}</td>
                      <td>{localDate}</td>
                      <td>{localTime}</td>
                      <td>{r.ObjectName1}</td>
                      <td>{r.EmployeeID}</td>
                      <td>{r.CardNumber || 'â€”'}</td>
                      <td>{r.PersonnelType || 'â€”'}</td>
                      <td style={{ maxWidth: 280, wordBreak: 'break-word' }}>{r.Door || r.Location || 'â€”'}</td>
                      <td>{r.RejectionType || 'â€”'}</td>
                    </tr>
                  );
                })}
              </tbody>
            </Table>
          )}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowRejectionModal(false)}>Close</Button>
        </Modal.Footer>
      </Modal> */}



      
{/* Rejection details modal (today) */}
<Modal show={showRejectionModal} onHide={() => setShowRejectionModal(false)} size="lg" centered>
  <Modal.Header closeButton>
    <Modal.Title>Rejections Today - {selectedRejectionFloor}</Modal.Title>
  </Modal.Header>
  <Modal.Body>
    {selectedRejectionList.length === 0 ? (
      <div>No rejections recorded today for {selectedRejectionFloor}</div>
    ) : (
      <Table striped bordered hover size="sm">
        <thead>
          <tr>
            <th>Sr.no</th>
            <th>Date</th>
            <th>Time</th>
            <th>Name</th>
            <th>EmployeeID</th>
            <th>CardNumber</th>
            <th>PersonnelType</th>
            <th>Door</th>
            <th>RejectionType</th>
          </tr>
        </thead>
        <tbody>
          {selectedRejectionList.map((r, i) => {
            let localDate = '';
            let localTime = '';
            try {
              if (r.LocaleMessageTime) {
                const dt = new Date(r.LocaleMessageTime);
                localDate = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                localTime = dt.toLocaleTimeString('en-GB', { timeZone: 'America/Denver' });
              } else if (r.DateOnly) {
                localDate = (typeof r.DateOnly === 'string' ? r.DateOnly.slice(0,10) : new Date(r.DateOnly).toISOString().slice(0,10));
                localTime = r.SwipeTime || '';
              }
            } catch (e) {
              localDate = (r.DateOnly || '').slice(0,10);
              localTime = r.SwipeTime || '';
            }

            return (
              <tr key={i}>
                <td>{i + 1}</td>
                <td>{localDate}</td>
                <td>{localTime}</td>
                <td>{r.ObjectName1}</td>
                <td>{r.EmployeeID}</td>
                <td>{r.CardNumber || 'â€”'}</td>
                <td>{r.PersonnelType || 'â€”'}</td>
                <td style={{ maxWidth: 280, wordBreak: 'break-word' }}>{r.Door || r.Location || 'â€”'}</td>
                <td>{r.RejectionType || 'â€”'}</td>
              </tr>
            );
          })}
        </tbody>
      </Table>
    )}
  </Modal.Body>
  <Modal.Footer>
    <Button
      style={{ background: '#FFC72C', borderColor: '#FFC72C', color: '#000', fontWeight: 600 }}
      onClick={() => exportRejectionsToExcel(selectedRejectionList, `rejections-${(selectedRejectionFloor||'floor').replace(/\s+/g,'_')}-${new Date().toISOString().slice(0,10)}.xlsx`)}
    >
      Export Excel
    </Button>
    <Button variant="secondary" onClick={() => setShowRejectionModal(false)}>Close</Button>
  </Modal.Footer>
</Modal>



      {/* NEW: All Rejections Modal (header click) */}
      {/* <Modal show={showAllRejectionsModal} onHide={() => setShowAllRejectionsModal(false)} size="lg" centered>
        <Modal.Header closeButton>
          <Modal.Title>All Rejections Today</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {(!rejectionAllDetailsToday || rejectionAllDetailsToday.length === 0) ? (
            <div>No rejections recorded today</div>
          ) : (
            <Table striped bordered hover size="sm">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Date</th>
                  <th>Time</th>
                  <th>Name</th>
                  <th>EmployeeID</th>
                  <th>CardNumber</th>
                  <th>PersonnelType</th>
                  <th>Door</th>
                  <th>RejectionType</th>
                </tr>
              </thead>
              <tbody>
                {rejectionAllDetailsToday.map((r, i) => {
                  let localDate = '';
                  let localTime = '';
                  try {
                    if (r.LocaleMessageTime) {
                      const dt = new Date(r.LocaleMessageTime);
                      localDate = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                      localTime = dt.toLocaleTimeString('en-GB', { timeZone: 'America/Denver' });
                    } else if (r.DateOnly) {
                      localDate = (typeof r.DateOnly === 'string' ? r.DateOnly.slice(0,10) : new Date(r.DateOnly).toISOString().slice(0,10));
                      localTime = r.SwipeTime || '';
                    }
                  } catch (e) {
                    localDate = (r.DateOnly || '').slice(0,10);
                    localTime = r.SwipeTime || '';
                  }

                  const derived = deriveFloorFromRecord(r) || 'Unknown';

                  return (
                    <tr key={i}>
                      <td>{i + 1}</td>
                      <td>{localDate}</td>
                      <td>{localTime}</td>
                      <td>{r.ObjectName1}</td>
                      <td>{r.EmployeeID}</td>
                      <td>{r.CardNumber || 'â€”'}</td>
                      <td>{r.PersonnelType || 'â€”'}</td>
                      <td style={{ maxWidth: 280, wordBreak: 'break-word' }}>{r.Door || r.Location || 'â€”'}</td>
                      <td>{r.RejectionType || 'â€”'}</td>
                    </tr>
                  );
                })}
              </tbody>
            </Table>
          )}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowAllRejectionsModal(false)}>Close</Button>
        </Modal.Footer>
      </Modal> */}





      
{/* NEW: All Rejections Modal (header click) */}
<Modal show={showAllRejectionsModal} onHide={() => setShowAllRejectionsModal(false)} size="lg" centered >
  <Modal.Header closeButton>
    <Modal.Title>All Rejections Today</Modal.Title>
  </Modal.Header>
  <Modal.Body> 
    {(!rejectionAllDetailsToday || rejectionAllDetailsToday.length === 0) ? (
      <div>No rejections recorded today</div>
    ) : (
      <Table striped bordered hover size="sm">
        <thead>
          <tr>
            <th>Sr.no</th>
            <th>Date</th>
            <th>Time</th>
            <th>Name</th>
            <th>EmployeeID</th>
            <th>CardNumber</th>
            <th>PersonnelType</th>
            <th>Door</th>
            <th>RejectionType</th>
          </tr>
        </thead>
        <tbody>
          {rejectionAllDetailsToday.map((r, i) => {
            let localDate = '';
            let localTime = '';
            try {
              if (r.LocaleMessageTime) {
                const dt = new Date(r.LocaleMessageTime);
                localDate = dt.toLocaleDateString('en-CA', { timeZone: 'America/Denver' });
                localTime = dt.toLocaleTimeString('en-GB', { timeZone: 'America/Denver' });
              } else if (r.DateOnly) {
                localDate = (typeof r.DateOnly === 'string' ? r.DateOnly.slice(0,10) : new Date(r.DateOnly).toISOString().slice(0,10));
                localTime = r.SwipeTime || '';
              }
            } catch (e) {
              localDate = (r.DateOnly || '').slice(0,10);
              localTime = r.SwipeTime || '';
            }

            return (
              <tr key={i}>
                <td>{i + 1}</td>
                <td>{localDate}</td>
                <td>{localTime}</td>
                <td>{r.ObjectName1}</td>
                <td>{r.EmployeeID}</td>
                <td>{r.CardNumber || 'â€”'}</td>
                <td>{r.PersonnelType || 'â€”'}</td>
                <td style={{ maxWidth: 280, wordBreak: 'break-word' }}>{r.Door || r.Location || 'â€”'}</td>
                <td>{r.RejectionType || 'â€”'}</td>
              </tr>
            );
          })}
        </tbody>
      </Table>
    )}
  </Modal.Body>
  <Modal.Footer>
    <Button
      style={{ background: '#FFC72C', borderColor: '#FFC72C', color: '#000', fontWeight: 600 }}
      onClick={() => exportRejectionsToExcel(rejectionAllDetailsToday, `all-rejections-${new Date().toISOString().slice(0,10)}.xlsx`)}
    >
      Export Excel
    </Button>
    <Button variant="secondary" onClick={() => setShowAllRejectionsModal(false)}>Close</Button>
  </Modal.Footer>
</Modal>



    </>
  );
}












