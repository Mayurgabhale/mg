why this error is came, how to  slove it ok 
<--- Last few GCs --->

[40056:0000014EE4455000]   665641 ms: Mark-Compact 3996.3 (4137.5) -> 3983.7 (4140.8) MB, pooled: 0 MB, 1408.98 / 0.00 ms  (average mu = 0.111, current mu = 0.027) allocation failure; scavenge might not succeed
[40056:0000014EE4455000]   668916 ms: Mark-Compact 3999.4 (4141.0) -> 3986.8 (4144.3) MB, pooled: 0 MB, 3244.39 / 0.00 ms  (average mu = 0.041, current mu = 0.009) allocation failure; scavenge might not succeed


<--- JS stacktrace --->

FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
----- Native stack trace -----

 1: 00007FF7DCB8542D node::SetCppgcReference+17693
 2: 00007FF7DCAE8248 SSL_get_quiet_shutdown+102712
 3: 00007FF7DD66ED41 v8::Isolate::ReportExternalAllocationLimitReached+65
 4: 00007FF7DD65B9C6 v8::Function::Experimental_IsNopFunction+2870
 5: 00007FF7DD4A8B10 v8::internal::StrongRootAllocatorBase::StrongRootAllocatorBase+31456
 6: 00007FF7DD4A5B7A v8::internal::StrongRootAllocatorBase::StrongRootAllocatorBase+19274
 7: 00007FF7DD4BB3D1 v8::Isolate::GetHeapProfiler+7793
 8: 00007FF7DD4BBC78 v8::Isolate::GetHeapProfiler+10008
 9: 00007FF7DD4C6EE1 v8::Isolate::GetHeapProfiler+55681
10: 00007FF7DD4D6977 v8::Isolate::GetHeapProfiler+119831
11: 00007FF7DD03D94E v8::base::bits::RoundUpToPowerOfTwo32+177838
12: 00007FF7DD2FF464 v8::MemorySpan<std::basic_string_view<char,std::char_traits<char> > const >::end+705748
13: 00007FF7DD6207C7 v8::SharedValueConveyor::SharedValueConveyor+334663
14: 00007FF7DD61F990 v8::SharedValueConveyor::SharedValueConveyor+331024
15: 00007FF77D6ED3FA
PS C:\Users\W0024618\desktop\swipeData\employee-ai-insights> npm start
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\config\db.js
// config/db.js
require('dotenv').config();
const sql = require('mssql');

// Pull and trim environment variables
const DB_USER     = (process.env.DB_USER     || '').trim();
const DB_PASSWORD = (process.env.DB_PASSWORD || '').trim();
const DB_SERVER   = (process.env.DB_SERVER   || '').trim();
const DB_DATABASE = (process.env.DB_DATABASE || '').trim();
const DB_PORT     = parseInt((process.env.DB_PORT || '').trim(), 10) || 1433;

const dbConfig = {
  user: DB_USER,
  password: DB_PASSWORD,
  server: DB_SERVER,
  port: DB_PORT,
  database: DB_DATABASE,
  options: { 
    encrypt: true,               // for Azure / secure connections
    trustServerCertificate: true,
    enableArithAbort: true
  },
  pool: {
    max: 20,                      // tuneable
    min: 1,
    idleTimeoutMillis: 30000,
    acquireTimeoutMillis: 60000
  },
  requestTimeout: 1800000,       // 30 minutes
  connectionTimeout: 60000       // 1 minute
};

let poolPromise = null;

async function getPool(attempts = 5) {
  if (poolPromise) return poolPromise;

  poolPromise = (async () => {
    try {
      const pool = await sql.connect(dbConfig);
      console.log('✅ MSSQL pool connected (Pune)');

      pool.on('error', err => {
        console.error('❌ MSSQL pool error (Pune):', err);
        poolPromise = null; // reset to allow reconnect
      });

      return pool;
    } catch (err) {
      console.error('❌ MSSQL pool connection failed (Pune):', err);
      poolPromise = null;
      if (attempts > 0) {
        console.log(`⏳ Retrying MSSQL connect (Pune) (${attempts} left)…`);
        await new Promise(res => setTimeout(res, 3000));
        return getPool(attempts - 1);
      }
      throw err;
    }
  })();

  // Global handler for MSSQL pool-level errors
  sql.on('error', err => {
    console.error('❌ MSSQL global error (Pune):', err);
    if (err && err.name === 'TimeoutError') poolPromise = null;
  });

  process.on('unhandledRejection', reason => {
    console.error('❌ Unhandled Rejection at (Pune):', reason);
  });

  process.on('uncaughtException', err => {
    console.error('❌ Uncaught Exception (will exit) (Pune):', err);
    // optional: process.exit(1);
  });

  return poolPromise;
}

module.exports = { sql, getPool };
===============================

// config/siteConfig.js
// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\config\siteConfig.js
const sqlModule = require('mssql');
const { poolPromise: sharedPoolPromise } = require('./db'); // Pune shared pool
const punePoolPromise = sharedPoolPromise;

// Denver config (tune as needed)
const denverConfig = {
  user:     'GSOC_Test',
  password: 'Westernccure@2025',
  server:   'SRVWUDEN0891V',
  database: 'ACVSUJournal_00010028',
  options: { encrypt: true, trustServerCertificate: true },
  pool: {
    max: 6, min: 0,
    idleTimeoutMillis: 30_000,
    acquireTimeoutMillis: 30_000
  },
  connectionTimeout: 30_000,
  requestTimeout: 30_000  // raise per-query default to 30s (you still control per-request timeouts)
};

let denverPoolPromise = null;

async function getDenverPool(attempts = 3) {
  if (denverPoolPromise) return denverPoolPromise;

  denverPoolPromise = (async () => {
    const pool = new sqlModule.ConnectionPool(denverConfig);

    pool.on('error', err => {
      console.error('❌ Denver MSSQL pool error:', err);
      denverPoolPromise = null;
    });

    try {
      await pool.connect();
      console.log('✅ Denver MSSQL pool connected');
      return pool;
    } catch (err) {
      console.error('❌ Denver pool connection failed:', err);
      denverPoolPromise = null;
      if (attempts > 0) {
        console.log(`⏳ Retrying Denver pool connect (${attempts} left)…`);
        await new Promise(res => setTimeout(res, 3000));
        return getDenverPool(attempts - 1);
      }
      throw err;
    }
  })().catch(err => {
    denverPoolPromise = null;
    return null;
  });

  return denverPoolPromise;
}

// Kick off an initial connect so poolPromise isn't null at first request
denverPoolPromise = getDenverPool().catch(() => null);

// Ping Denver every 5 minutes to keep the TCP connection alive; if ping fails, reset promise
setInterval(async () => {
  try {
    const pool = await getDenverPool();
    if (pool) {
      try {
        await pool.request().query('SELECT 1');
      } catch (err) {
        console.warn('⚠️ Denver keep-alive query failed, resetting poolPromise:', err);
        denverPoolPromise = null;
      }
    }
  } catch (err) {
    console.error('⚠️ Denver keep-alive failed to get pool:', err);
    denverPoolPromise = null;
  }
}, 5 * 60 * 1000);

module.exports = {
  pune: { name: 'Pune', poolPromise: punePoolPromise, sql: sqlModule },
  denver: {
    name: 'Denver',
    getPool: getDenverPool,
    // export initial poolPromise for backward-compat — but code should prefer getPool()
    poolPromise: denverPoolPromise,
    sql: sqlModule
  }
};
++++++++++++++++++\


// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\liveOccupancyController.js
const { DateTime } = require('luxon');
const { sql, getPool } = require('../config/db');

const doorZoneMap  = require('../data/doorZoneMap');
const zoneFloorMap = require('../data/zoneFloorMap');
const ertMembers   = require('../data/puneErtMembers.json');

// Track which door→zone keys we've already warned on
const warnedKeys = new Set();

// --- Helpers ---

function getTodayString() {
  return DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
}

function normalizeZoneKey(rawDoor, rawDir) {
  let door = String(rawDoor || '').trim();
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');
  door = door.replace(/\s+/g, ' ').toUpperCase();
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';
  return `${door}___${dir}`;
}

function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = doorZoneMap[key];
  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('⛔ Unmapped door–direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }
  return zone;
}

// --- Core functions ---

async function fetchNewEvents(since) {
  const pool = await getPool();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel] t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8), LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zoneRaw  = mapDoorToZone(Door, Direction);

    if (zoneRaw === 'Unknown Zone') continue;

    const zoneLower = zoneRaw.toLowerCase();

    if (Direction === 'OutDirection') {
      if (zoneLower === 'out of office') {
        uniquePeople.delete(dedupKey);
        delete current[dedupKey];
      } else {
        uniquePeople.set(dedupKey, PersonnelType);
        current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone: zoneRaw, door: Door, Direction };
      }
      continue;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone: zoneRaw, door: Door, Direction };
      continue;
    }

    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  }

  let employeeCount = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  const zoneMap = {};
  for (const emp of Object.values(current)) {
    const zKey = emp.zone.toLowerCase();
    if (zKey === 'out of office') continue;
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
    })
  );

  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);
        const matchEvt = Object.values(current).find(e => normalizePersonName(e.ObjectName1) === expected);
        return { ...m, present: !!matchEvt, zone: matchEvt ? matchEvt.zone : null };
      });
      return [role, list];
    })
  );

  return {
    asOf: new Date().toISOString(),
    summary: Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown: Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown: Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details: zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    ertStatus,
    personnelBreakdown: (() => {
      const map = new Map();
      for (const pt of uniquePeople.values()) map.set(pt, (map.get(pt)||0)+1);
      return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
    })()
  };
}

function buildVisitedToday(allEvents, asOf) {
  let today;
  if (asOf) {
    if (typeof asOf === 'string') today = asOf;
    else if (asOf instanceof Date) today = DateTime.fromJSDate(asOf, { zone: 'Asia/Kolkata' }).toFormat('yyyy-LL-dd');
    else if (asOf && typeof asOf.toFormat === 'function') today = asOf.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    else today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
  } else today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

  const todayIns = allEvents.filter(evt => evt.Direction === 'InDirection' && evt.Dateonly === today);
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID;
    const prev = dedup.get(key);
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) dedup.set(key, e);
  }
  const finalList = Array.from(dedup.values());
  const employees = finalList.filter(e => !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management'].includes(e.PersonnelType)).length;
  const contractors = finalList.length - employees;
  return { employees, contractors, total: finalList.length };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await getPool();

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    });
    res.write('\n');

    let lastSeen = new Date();
    const events = [];

    const push = async () => {
      // fetch only new events since lastSeen
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = new Date();
        events.push(...fresh);
      }

      // build live snapshot
      const occupancy = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);
      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday = { ...todayStats };

      // send snapshot every second
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);

      if (typeof res.flush === 'function') res.flush();
    };

    // push immediately, then every 1 second
    await push();
    const timer = setInterval(push, 1000);

    req.on('close', () => clearInterval(timer));
  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};
============================================

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey       = require('../data/normalizeKey');

const warnedKeys = new Set();



// safeQuery helper — cancels request if it exceeds timeoutMs (ms)
async function safeQueryWithTimeout(req, sqlText, timeoutMs = 20_000) {
  // req is a mssql Request: created from pool.request()
  let timer = null;
  let timedOut = false;

  const cancelIfTimeout = () => {
    timedOut = true;
    try {
      if (typeof req.cancel === 'function') req.cancel(); // cancel the underlying request
    } catch (e) {
      // ignore
    }
  };

  const qPromise = (async () => {
    try {
      const result = await req.query(sqlText);
      return result;
    } finally {
      if (timer) clearTimeout(timer);
    }
  })();

  timer = setTimeout(cancelIfTimeout, timeoutMs);

  try {
    const res = await qPromise;
    if (timedOut) throw new Error('Query canceled after timeout');
    return res;
  } catch (err) {
    if (timedOut) err.message = `Query timed out after ${timeoutMs}ms`;
    throw err;
  }
}

// build a Set of normalized door___direction keys
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(([door, dir]) => normalizeKey(door, dir))
);

/** Determine floor label, fallback to “HQ. N.” parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

/** Strip any trailing “_HH:MM:SS” from a door name **/
function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}

/**
 * Compare a DB row's Dateonly (yyyy-MM-dd) to either "today in Denver" OR a supplied reference DateTime (also Denver).
 * - dateOnly: string like '2025-09-11'
 * - referenceDt: optional luxon DateTime (zone 'America/Denver') to treat as "today"
 */
function isSameDenverDate(dateOnly, referenceDt = null) {
  if (!dateOnly) return false;
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' }).toFormat('yyyy-LL-dd');
  const today = referenceDt
    ? referenceDt.setZone('America/Denver').toFormat('yyyy-LL-dd')
    : DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}


async function fetchNewEvents(since) {
  let pool;
  try {
    // IMPORTANT: use denver.getPool() (not denver.poolPromise)
    pool = await denver.getPool();
  } catch (err) {
    console.error('❌ Failed to get Denver pool in fetchNewEvents():', err);
    return [];
  }
  if (!pool) {
    console.warn('⚠️ fetchNewEvents: no pool available, returning empty');
    return [];
  }

  const req = pool.request();
  req.input('since', sql.DateTime2, since);

  const queryText = `
  
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]' ,'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010029.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType   = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE,-1* t1.MessageLocaleOffset, t1.MessageUTC) >= @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID, PersonGUID, ObjectName1, PersonnelType,
      CardNumber, AdmitCode, Direction, Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `; // paste the same long query you already have

  const t0 = Date.now();
  try {
    const { recordset } = await safeQueryWithTimeout(req, queryText, 20_000); // 20s timeout
    const took = Date.now() - t0;
    console.log(`[DENVER] fetchNewEvents: got ${recordset ? recordset.length : 0} rows (took ${took}ms)`);
    return recordset || [];
  } catch (err) {
    console.error('❌ fetchNewEvents query error — resetting Denver pool and returning empty:', err);
    try {
      // Close pool to free resources; next getDenverPool will reconnect
      if (pool && typeof pool.close === 'function') {
        try { await pool.close(); } catch (e) { /* ignore */ }
      }
    } catch (e) { /* ignore */ }

    // set the exported promise to null so new callers will recreate
    try { denver._forceReset = true; } catch (e) { /* ignore */ }

    return [];
  }
}

// Live SSE endpoint with heartbeat + non-overlap + logging
exports.getDenverLiveOccupancy = async (req, res) => {
  try {
    // ensure poolPromise at least initialised (does not throw)
    const poolMaybe = await denver.poolPromise;
    if (!poolMaybe) {
      console.warn('⚠️ Denver poolPromise resolved to null — DB likely unavailable');
    }
  } catch (err) {
    console.error('❌ Failed to initialize Denver pool in SSE endpoint:', err);
    // still continue but logs will show missing DB
  }

  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.write('\n');

  // heartbeat comment every 15s so clients do not time out
  const heartbeat = setInterval(() => {
    try {
      // SSE comment keeps connection alive but is ignored by EventSource data parser
      res.write(': heartbeat\n\n');
      if (typeof res.flush === 'function') res.flush();
    } catch (err) {
      console.warn('⚠️ Failed to send heartbeat (connection likely closed):', err);
    }
  }, 15_000);

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];
  let pushRunning = false;
  let consecutiveDbErrors = 0;

  const push = async () => {
    if (pushRunning) {
      // console.debug('[DENVER] push already running — skipping this tick');
      return;
    }
    pushRunning = true;
    try {
      const fresh = await fetchNewEvents(lastSeen);

      if (fresh.length) {
        // update lastSeen to the latest event's LocaleMessageTime (string or Date)
        const lastEvt = fresh[fresh.length - 1];
        if (lastEvt && lastEvt.LocaleMessageTime) {
          lastSeen = new Date(lastEvt.LocaleMessageTime);
        } else {
          lastSeen = new Date();
        }
        events.push(...fresh);
        // console.log(`[DENVER] pushed ${fresh.length} new events — events buffer now ${events.length}`);
      }

      // prune events not on today's Denver date (keep memory small)
      const todayDenver = DateTime.now().setZone('America/Denver').toISODate();
      for (let i = events.length - 1; i >= 0; i--) {
        const ts = events[i].Dateonly || (events[i].LocaleMessageTime ? DateTime.fromISO(events[i].LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver').toISODate() : null);
        if (!ts || ts !== todayDenver) events.splice(i, 1);
      }

      // build payload
      let payload;
      try {
        payload = buildOccupancyForToday(events, fresh, null); // live mode (null => uses now)
      } catch (err) {
        console.error('[DENVER] Error building payload:', err);
        payload = {
          asOfLocal: DateTime.now().setZone('America/Denver').toISO(),
          asOfUTC: new Date().toISOString(),
          currentCount: 0,
          floorBreakdown: [],
          personnelSummary: { employees: 0, contractors: 0 },
          personnelBreakdown: [],
          totalVisitedToday: 0,
          visitedToday: { employees: 0, contractors: 0, total: 0 },
          swipeStats: { totalInSwipes: 0, totalOutSwipes: 0 },
          floorInOutSummary: []
        };
      }

      // write SSE event
      const sid = Date.now();
      try {
        res.write(`id: ${sid}\n`);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
        if (typeof res.flush === 'function') res.flush();
        // console.debug(`[DENVER] wrote payload id=${sid}`);
      } catch (err) {
        console.warn('[DENVER] Failed to write SSE payload (connection likely closed):', err);
      }

      consecutiveDbErrors = 0;
    } catch (err) {
      consecutiveDbErrors++;
      console.error('[DENVER] push top-level error:', err);
      // back off a bit if DB failing repeatedly
      if (consecutiveDbErrors > 3) {
        console.warn(`[DENVER] ${consecutiveDbErrors} consecutive DB errors — sleeping 5s before next try`);
        await new Promise(r => setTimeout(r, 5000));
      }
    } finally {
      pushRunning = false;
    }
  };

  await push();
  const timer = setInterval(push, 1000); // 1s interval (user requested)

  req.on('close', () => {
    clearInterval(timer);
    clearInterval(heartbeat);
    console.log('[DENVER] SSE client disconnected, cleared timers');
  });
};
