graph.js:301 Uncaught TypeError: Cannot convert undefined or null to object
    at Object.keys (<anonymous>)
    at updateDeviceHealthTable (graph.js:301:10)
    at renderGauges (graph.js:279:3)
    at HTMLDocument.<anonymous> (graph.js:34:3)
updateDeviceHealthTable	@	graph.js:301
renderGauges	@	graph.js:279
(anonymous)	@	graph.js:34



            <div class="bottom-row">

              <!-- <div class="gcard wide gcard-pie">
                <h4 class="gcard-title">Total Count </h4>
                <div class="chart-placeholder"></div>
              </div> -->
              <!-- <div class="gcard wide">
                <h4 class="gcard-title">LOC Count</h4>
                <div class="chart-placeholder"></div>
              </div> -->
              <div class="gcard wide" style="height:300px;">
                <h4 class="gcard-title">LOC Count</h4>
                <canvas id="cityBarChart"></canvas>
              </div>

              <div class="gcard wide">
                <h4 class="gcard-title">Failure Count</h4>
                <div class="chart-placeholder"></div>
              </div>



              <div class="gcard wide gcard-pie">
                <h4 class="gcard-title">Total Count </h4>
                <div class="chart-placeholder"></div>
              </div>

              <div class="gcard wide device-health-card">
                
  <h4 class="gcard-title">Device Health Overview</h4>
  <div class="device-health-content">
    <table id="device-health-table">
      <thead>
        <tr>
          <th>Device Type</th>
          <th>Total</th>
          <th>Active</th>
          <th>Inactive</th>
          <th>Trend</th>
        </tr>
      </thead>
      <tbody>
        <!-- Dynamic rows -->
      </tbody>
    </table>
  </div>
</div>

            </div>

C:\Users\W0024618\Desktop\NewFrontend\Device Dashboard\graph.js

function updateGauge(id, activeId, inactiveId, totalId) {
  const active = parseInt(document.getElementById(activeId).textContent) || 0;
  const inactive = parseInt(document.getElementById(inactiveId).textContent) || 0;
  const total = active + inactive;

  // element
  const gauge = document.getElementById(id);
  if (!gauge) return;

  // % calculation
  let percentage = total === 0 ? 0 : Math.round((active / total) * 100);

  // set values
  gauge.style.setProperty("--percentage", percentage);

  // update text inside semicircle
  gauge.querySelector(".total").textContent = total;
  gauge.querySelector(".active").textContent = active;
  gauge.querySelector(".inactive").textContent = inactive;

  // card footer also updates
  document.getElementById(totalId).textContent = total;
}

function renderGauges() {
  updateGauge("gauge-cameras", "camera-online", "camera-offline", "camera-total");
  updateGauge("gauge-archivers", "archiver-online", "archiver-offline", "archiver-total");
  updateGauge("gauge-controllers", "controller-online", "controller-offline", "controller-total");
  updateGauge("gauge-ccure", "server-online", "server-offline", "server-total");
}

document.addEventListener("DOMContentLoaded", () => {
  renderGauges();
  setInterval(renderGauges, 6000);
});


// ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è PIE chart




// --- Total Count doughnut chart (uses Chart.js) ---

let _totalCountChart = null;

/**
 * Find the chart-placeholder element inside the card whose title matches text.
 * Returns the placeholder element or null.
 */
function findChartPlaceholderByTitle(titleText) {
  const cards = document.querySelectorAll('.gcard.wide');
  for (let card of cards) {
    const h = card.querySelector('.gcard-title');
    if (h && h.textContent.trim().toLowerCase() === titleText.trim().toLowerCase()) {
      return card.querySelector('.chart-placeholder');
    }
  }
  return null;
}

/**
 * Collect totals from DOM. Add/remove device keys as needed.
 * Make sure IDs used here exist in your summary-section.
 */


function collectTotalCounts() {
  const keys = [
    { id: 'camera-total', label: 'Cameras' },
    { id: 'archiver-total', label: 'Archivers' },
    { id: 'controller-total', label: 'Controllers' },
    { id: 'server-total', label: 'CCURE' },
    { id: 'doorReader-total', label: 'Door' },
    { id: 'reader-total-inline', label: 'Reader' },
    { id: 'pc-total', label: 'Desktop' },
    { id: 'db-total', label: 'DB Server' }
  ];

  const labels = [];
  const values = [];

  keys.forEach(k => {
    const el = document.getElementById(k.id);
    const v = el
      ? parseInt((el.textContent || '0').replace(/,/g, '').trim(), 10)
      : 0;

    if (v > 0) {
      labels.push(k.label);
      values.push(v);
    }
  });

  if (values.length === 0) {
    return { labels: ['No devices'], values: [0] };  // ‚úÖ fixed
  }

  return { labels, values };
}

/**
 * Render or update the Total Count doughnut.
 */



function renderTotalCountChart() {
  if (typeof Chart === 'undefined') {
    console.warn('Chart.js not loaded ‚Äî add https://cdn.jsdelivr.net/npm/chart.js');
    return;
  }

  const placeholder = findChartPlaceholderByTitle('Total Count');
  if (!placeholder) return;

  let canvas = placeholder.querySelector('canvas');
  if (!canvas) {
    canvas = document.createElement('canvas');
    placeholder.innerHTML = '';
    placeholder.appendChild(canvas);
  }

  const ctx = canvas.getContext('2d');
  const data = collectTotalCounts();

  // calculate total
  //   const totalValue = data.values.reduce((a, b) => a + b, 0);
  const totalValue = data.labels[0] === 'No devices'
    ? 0
    : data.values.reduce((a, b) => a + b, 0);

  if (_totalCountChart) {
    _totalCountChart.destroy();
  }

  const palette = [
    '#10b981', '#f97316', '#2563eb',
    '#7c3aed', '#06b6d4', '#ef4444',
    '#f59e0b', '#94a3b8'
  ];

  // ---- Plugin for CENTER TEXT ----
  const centerTextPlugin = {
    id: 'centerText',
    afterDraw(chart) {
      const { ctx, chartArea } = chart;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;

      ctx.save();

      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Total label
      ctx.font = '14px Inter, Arial';
      // ctx.fillStyle = '#aaa';
      // Total label
      ctx.fillStyle = getComputedStyle(document.body)
        .getPropertyValue('--graph-card-footer-dark');

      ctx.fillText('TOTAL', centerX, centerY - 12);

      // Total value
      ctx.font = 'bold 20px Inter, Arial';
      // ctx.fillStyle = '#fff';
      // Total value
      ctx.fillStyle = getComputedStyle(document.body)
        .getPropertyValue('--graph-card-title-dark');
      ctx.fillText(totalValue, centerX, centerY + 12);

      ctx.restore();
    }
  };

  _totalCountChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: data.labels,
      datasets: [{
        data: data.values,
        backgroundColor: palette.slice(0, data.values.length),
        borderWidth: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '65%',
      plugins: {
        legend: {
          position: 'right',
          labels: {
            usePointStyle: true,
            padding: 12,

            // üî• THIS adds count next to label
            generateLabels: function (chart) {
              const dataset = chart.data.datasets[0];
              const labels = chart.data.labels;
              const bgColors = dataset.backgroundColor;

              return labels.map((label, i) => {
                return {
                  text: `${label} - ${dataset.data[i]}`,
                  fillStyle: bgColors[i],
                  strokeStyle: bgColors[i],
                  hidden: false,
                  index: i
                };
              });
            }
          }
        },

        tooltip: {
          callbacks: {
            label: function (ctx) {
              const label = ctx.label || '';
              const value = ctx.parsed || 0;
              return `${label} : ${value}`;
            }
          }
        }
      }
    },

    plugins: [centerTextPlugin]   // ‚úÖ center total plugin
  });
}




/**
 * Update the Total Count chart data in-place (if chart exists) otherwise render
 */
function updateTotalCountChart() {
  if (!_totalCountChart) {
    renderTotalCountChart();
    return;
  }
  const data = collectTotalCounts();
  _totalCountChart.data.labels = data.labels;
  _totalCountChart.data.datasets[0].data = data.values;
  _totalCountChart.data.datasets[0].backgroundColor = [

    '#10b981', '#f97316', '#2563eb', '#7c3aed', '#06b6d4', '#ef4444', '#f59e0b', '#94a3b8'
  ].slice(0, data.values.length);
  _totalCountChart.update();
}

// Hook it up: render on DOMContentLoaded and update when gauges refresh
document.addEventListener('DOMContentLoaded', () => {
  // initial render (if Chart.js loaded)
  renderTotalCountChart();

  // re-render on window resize (debounced)
  let resizeTO;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTO);
    resizeTO = setTimeout(() => {
      renderTotalCountChart(); // re-create with correct sizing
    }, 200);
  });
});

// Call updateTotalCountChart() whenever your data changes.
// We'll call it inside renderGauges() so it updates after gauges refresh.
function renderGauges() {
  updateGauge("gauge-cameras", "camera-online", "camera-offline", "camera-total");
  updateGauge("gauge-archivers", "archiver-online", "archiver-offline", "archiver-total");
  updateGauge("gauge-controllers", "controller-online", "controller-offline", "controller-total");
  updateGauge("gauge-ccure", "server-online", "server-offline", "server-total");

  // update Total Count pie
  updateDeviceHealthTable();
  updateTotalCountChart();
}






// ‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è
// ‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è




const PREVIOUS_COUNTS = {}; // to store previous values

function updateDeviceHealthTable(data) {
  // data = { cameras: { active, inactive }, archivers: {...}, ... }
  const tbody = document.querySelector('#device-health-table tbody');
  tbody.innerHTML = '';

  Object.keys(data).forEach(type => {
    const { active, inactive } = data[type];
    const total = active + inactive;

    // calculate trend
    const prev = PREVIOUS_COUNTS[type] || { active: 0, inactive: 0 };
    let trendSymbol = '';
    if (active > prev.active) trendSymbol = '‚ñ≤';
    else if (active < prev.active) trendSymbol = '‚ñº';
    const trendClass = active >= prev.active ? 'trend-up' : 'trend-down';

    PREVIOUS_COUNTS[type] = { active, inactive };

    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${type.charAt(0).toUpperCase() + type.slice(1)}</td>
      <td>${total}</td>
      <td>${active}</td>
      <td>${inactive}</td>
      <td class="${trendClass}">${trendSymbol}</td>
    `;
    tbody.appendChild(row);
  });
}

function updateHeatMap() {
  if (!realMap) return;
  if (heatLayer) realMap.removeLayer(heatLayer);

  const heatPoints = [];

  Object.keys(cityLayers).forEach(city => {
    const { deviceLayer } = cityLayers[city];
    let inactiveCount = 0;

    deviceLayer.eachLayer(marker => {
      if (marker.getTooltip && marker.getTooltip().getContent().includes('INACTIVE')) {
        inactiveCount++;
      }
    });

    const cityObj = CITY_LIST.find(c => c.city === city);
    if (cityObj && inactiveCount > 0) {
      heatPoints.push([cityObj.lat, cityObj.lon, inactiveCount]);
    }
  });

  heatLayer = L.heatLayer(heatPoints, { radius: 25, blur: 15, maxZoom: 10 }).addTo(realMap);
}

function refreshMapDevices() {
  Object.values(CITY_LIST).forEach(cityObj => {
    _placeDeviceIconsForCity(cityObj, cityObj.devices);
  });
  updateHeatMap(); // üî• show inactive intensity
}







// ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è----- LOC Count Bar Chart -----
