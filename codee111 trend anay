# ---------- START: REGION HELPERS & ENDPOINTS ----------
# (Insert into your FastAPI app file)
COUNTRY_TO_REGION = {
    # APAC (not exhaustive)
    'india': 'APAC', 'philippines': 'APAC', 'china': 'APAC', 'japan': 'APAC', 'australia': 'APAC',
    'singapore': 'APAC', 'malaysia': 'APAC', 'indonesia': 'APAC', 'thailand': 'APAC', 'vietnam': 'APAC',
    'south korea': 'APAC', 'hong kong': 'APAC', 'taiwan': 'APAC', 'pakistan': 'APAC', 'bangladesh': 'APAC',

    # NAMER (North America)
    'united states': 'NAMER', 'usa': 'NAMER', 'canada': 'NAMER', 'mexico': 'NAMER',

    # LACA (Latin America & Caribbean)
    'brazil': 'LACA', 'argentina': 'LACA', 'chile': 'LACA', 'colombia': 'LACA', 'peru': 'LACA',
    'venezuela': 'LACA', 'panama': 'LACA', 'costa rica': 'LACA',

    # EMEA
    'united kingdom': 'EMEA', 'uk': 'EMEA', 'germany': 'EMEA', 'france': 'EMEA', 'spain': 'EMEA',
    'italy': 'EMEA', 'netherlands': 'EMEA', 'sweden': 'EMEA', 'norway': 'EMEA', 'denmark': 'EMEA',
    'switzerland': 'EMEA', 'belgium': 'EMEA', 'austria': 'EMEA', 'poland': 'EMEA', 'greece': 'EMEA',
    'turkey': 'EMEA', 'uae': 'EMEA', 'saudi arabia': 'EMEA', 'south africa': 'EMEA', 'egypt': 'EMEA'
}

DEFAULT_REGION = 'UNKNOWN'


def guess_region(country: Optional[str], location: Optional[str]) -> str:
    """Try country first, then look for location token matches, else return DEFAULT_REGION."""
    if country:
        c = str(country).strip().lower()
        if c in COUNTRY_TO_REGION:
            return COUNTRY_TO_REGION[c]
        # also try common short iso forms (USA -> united states)
        if c.replace('.', '').replace(' ', '') in COUNTRY_TO_REGION:
            return COUNTRY_TO_REGION[c]
    if location:
        s = str(location).strip().lower()
        # check if any known country name is present in the location string
        for name, reg in COUNTRY_TO_REGION.items():
            if name in s:
                return reg
        # city heuristics (simple tokens)
        if any(tok in s for tok in ('pune', 'mumbai', 'hyderabad', 'delhi', 'manila')):
            return 'APAC'
    return DEFAULT_REGION


def normalize_city(location: Optional[str]) -> Optional[str]:
    if not location or pd.isna(location):
        return None
    s = str(location).strip()
    if ',' in s:
        s = s.split(',')[0]
    return s.title().strip()


def build_regions_summary(items: list) -> dict:
    """Build nested summary from items list.
    Returns: dict keyed by region code with counts, cities and sample travelers.
    """
    regions = {}
    for it in items:
        # prefer "to_" fields, fallback to from_
        country = it.get('to_country') or it.get('from_country')
        loc = it.get('to_location') or it.get('from_location')
        region = guess_region(country, loc) or DEFAULT_REGION
        city = normalize_city(loc) or 'Unknown'

        if region not in regions:
            regions[region] = {
                'region_code': region,
                'total_count': 0,
                'active_count': 0,
                'cities': {}
            }

        regions[region]['total_count'] += 1
        if it.get('active_now'):
            regions[region]['active_count'] += 1

        city_bucket = regions[region]['cities'].setdefault(city, {
            'city_name': city,
            'total_count': 0,
            'active_count': 0,
            'sample_items': []
        })
        city_bucket['total_count'] += 1
        if it.get('active_now'):
            city_bucket['active_count'] += 1

        # Keep a small sample of items (full items are available in previous_data['items'])
        if len(city_bucket['sample_items']) < 10:
            city_bucket['sample_items'].append({
                'first_name': it.get('first_name'),
                'last_name': it.get('last_name'),
                'emp_id': it.get('emp_id'),
                'email': it.get('email'),
                'pnr': it.get('pnr'),
                'begin_dt': it.get('begin_dt'),
                'end_dt': it.get('end_dt'),
                'active_now': it.get('active_now')
            })

    # Sort cities by count for each region
    for reg in regions.values():
        reg['cities'] = dict(sorted(reg['cities'].items(), key=lambda kv: -kv[1]['total_count']))

    return regions


# New endpoints
@app.get('/regions')
async def get_regions():
    if previous_data.get('items') is None:
        raise HTTPException(status_code=404, detail='No travel data available')
    # compute on the fly (fast) or use cached copy
    regions = build_regions_summary(previous_data['items'])
    previous_data['regions_summary'] = regions
    return JSONResponse(content={'regions': regions})


@app.get('/regions/{region_code}')
async def get_region(region_code: str):
    if previous_data.get('items') is None:
        raise HTTPException(status_code=404, detail='No travel data available')
    regions = previous_data.get('regions_summary') or build_regions_summary(previous_data['items'])
    rc = region_code.upper()
    if rc not in regions:
        raise HTTPException(status_code=404, detail=f'Region {rc} not found')
    return JSONResponse(content={'region': regions[rc]})

# ---------- END: REGION HELPERS & ENDPOINTS ----------